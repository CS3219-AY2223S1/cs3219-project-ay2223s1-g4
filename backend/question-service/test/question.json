[
  {
    "id": 1,
    "title": "Two Sum",
    "problem": "\nGiven an array of integers, return **indices** of the two numbers such that they\n add up to a specific target.\n\n\nYou may assume that each input would have ***exactly*** one solution, and\n you may not use the *same* element twice.\n\n\n**Example:**\n\n\n\n```\n\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[**0**] + nums[**1**] = 2 + 7 = 9,\nreturn [**0**, **1**].\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/1.html>\n\n\n\n```\n\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers (both index1 and\nindex2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\nInput: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2\n\n\n```\n\nAlgorithm\n=========\n\n\nGenerally speaking, in order to increase the complexity of time, you need to use space for exchange. This is considered a trade off.\n\n\nBut here I only want to use linear time complexity to solve the problem, that is, only one number can be traversed, then another number, you can store it in advance and use a HashMap to establish the mapping between the number and its coordinate position.\n\n\nSince the HashMap is a constant-level search efficiency, when traversing the array, use the target to subtract the traversed number. It is another number you need, just look for it in the HashMap directly. Note that the number you find is not the first number. For example, if the target is 4 and a 2 is traversed, then the other 2 cannot be the previous one. 2.\n\n\nThe entire implementation steps are: first traverse the array once, establish a HashMap mapping, and then traverse again, start searching, and record the index when found.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.HashMap;\n\nclass Two\\_Sum {\n\n    public static void main(String[] args) {\n\n        Two\\_Sum out = new Two\\_Sum();\n        Solution s = out.new Solution();\n\n        int[] a = {2, 7, 11, 15};\n        int target = 9;\n\n        int[] result = s.twoSum(a, target);\n\n        for (int each : result) {\n            System.out.println(each);\n        }\n    }\n\n    // time: O(N)\n    // space: O(N)\n    public class Solution {\n\n        public int[] twoSum(int[] nums, int target) {\n\n            // set up hashmap: remaining to original. thread-unsafe but for here is ok\n            HashMap<Integer, Integer> hm = new HashMap<>();\n\n            for (int i = 0; i < nums.length; i++) {\n\n                // if key in hm, result found.\n                // so that only one pass\n                if (hm.containsKey(nums[i])) {\n                    int otherIndex = hm.get(nums[i]);\n\n                    return new int[]{Math.min(i, otherIndex) + 1, Math.max(i, otherIndex) + 1};\n                }\n                // put new record into hashmap\n                else {\n                    hm.put(target - nums[i], i);\n                }\n            }\n\n            return null;\n        }\n\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 2,
    "title": "Add Two Numbers",
    "problem": "\nYou are given two **non-empty** linked lists representing two non-negative integers. The\n digits are stored in **reverse order** and each of their nodes contain a single digit.\n Add the two numbers and return it as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0\n itself.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** (2 -> 4 -> 3) + (5 -> 6 -> 4)\n**Output:** 7 -> 0 -> 8\n**Explanation:** 342 + 465 = 807.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/2.html>\n\n\n\n```\n2\tAdd Two Numbers\n\nYou are given two linked lists representing two non-negative numbers. The digits are stored in\nreverse order and each of their nodes contain a single digit. Add the two numbers and return it as a\nlinked list.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nCreate a new linked list, and then push the input two linked lists from the beginning to the back, add every two, and add a new node to the back of the new linked list.\n\n\nIn order to prevent the two input linked lists from being empty at the same time, we create a dummy node, and add the new nodes generated by the addition of the two nodes to the dummy node in order.\n\n\nSince the dummy node itself cannot be changed, a pointer is used cur to point to the last node of the new linked list. Ok, you can start to add the two linked lists.\n\n\nThis problem is good because the lowest bit is at the beginning of the linked list, so you can directly add them in order from low to high while traversing the linked list. The condition of the while loop, as long as one of the two linked lists is not an empty row, since the linked list may be empty, when taking the current node value, judge first, if it is empty then value is 0, otherwise take the node value.\n\n\nThen add the two node values ​​together, and add `carry`. Then update carry, directly `sum/10`, and then create a new node with sum%10 as the value, connect it to the back of cur, and then move cur to the next node.\n\n\nThen update the two nodes, if they exist, point to the next location. After the while loop exits, the highest carry issue needs to be dealt with specially. If carry is 1, then another node with value 1 is created.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Add\\_Two\\_Numbers {\n\n\tpublic class Solution {\n\t    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\t        if (l1 == null || l2 == null) {\n\t            return l1 == null ? l2 : l1;\n\t        }\n\n\t        // boolean style, 0 or 1\n\t        int carry = 0;\n\n\t        ListNode dummy = new ListNode(0);\n\t        ListNode dummyCopy = dummy;\n\n\t        while (l1 != null || l2 != null) {\n\t            int sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n\n\t            // append to result list\n\t            dummy.next = new ListNode(sum % 10);\n\t            carry = sum >= 10 ? 1 : 0;\n\n\t            // move to next node\n\t            l1 = l1 == null ? null : l1.next;\n\t            l2 = l2 == null ? null : l2.next;\n\t            dummy = dummy.next;\n\t        }\n\n\t        // @note: I missed final check\n\t        if (carry == 1) {\n\t            dummy.next = new ListNode(carry);\n\t        }\n\n\t        return dummyCopy.next;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 3,
    "title": "Longest Substring Without Repeating Characters\n",
    "problem": "\nGiven a string, find the length of the **longest substring** without repeating characters.\n \n\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"abcabcbb\"\n**Output:** 3\n**Explanation:** The answer is \"abc\", with the length of 3.\n\n```\n\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"bbbbb\"\n**Output:** 1\n**Explanation:** The answer is \"b\", with the length of 1.\n\n```\n\n\n**Example 3:**\n\n\n\n```\n\n**Input:** \"pwwkew\"\n**Output:** 3\n**Explanation:** The answer is \"wke\", with the length of 3.\n             Note that the answer must be a **substring**, \"pwke\" is a *subsequence* and not a substring.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/3.html>\n\n\n\n```\n\n3. Longest Substring Without Repeating Characters\n\nGiven a string, find the length of the longest substring without repeating characters.\n\nFor example, the longest substring without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3.\n\nFor \"bbbbb\" the longest substring is \"b\", with the length of 1.\n\n\n```\n\nAlgorithm\n=========\n\n\nIf you give the example “abcabcbb” in an example, let you manually find the substring without repeated characters.\n\n\nI will traverse one character by character, such as a, b, c, and then another a appears, then the first occurrence of a should be removed at this time, and then afterward, another b appears, then Remove the one occurrence of b, and so on, and finally find that the longest length is 3.\n\n\nTherefore, it is necessary to record the characters that have appeared before. There are many ways to record. The most common is to count the number of characters, but the position of the character in this question is very important, so you can use HashMap to establish the character and its appearance. Mapping between.\n\n\nConsidering further, since the characters will appear repeatedly, should we save all occurrences or just record one location? The method we derive manually before is actually to maintain a sliding window, in which there are no repeated characters, and the size of the window needs to be enlarged as much as possible. Since the window is constantly sliding to the right, it only cares about the last position of each character and establishes a mapping.\n\n\nThe right border of the window is the position of the character currently traversed. In order to find the size of the window, a variable left is needed to point to the left border of the sliding window. In this way, if the character currently traversed has never appeared, the right border is directly expanded If it has appeared before, then it can be divided into two situations. It is in or not in the sliding window. If it is not in the sliding window, then it is fine. The current character can be added in. If it is, you need to remove this already in the sliding window. The characters that have appeared, the method of removing it does not need to traverse the left boundary left one by one to the right. Since the HashMap has saved the last position of the repeated character, it is enough to move the left pointer directly. Maintain a result res, and update the result res with the window size that has appeared, and you can get the final result.\n\n\nHere you can create a HashMap to create a mapping between each character and its last appearance position, and then you need to define two variables res and left, where res is used to record the length of the longest non-repeated substring, and left points to the non-repeated substring The previous one of the starting position on the left of the string, because it is the previous one, so the initialization is -1, and then traverse the entire string, for each traversed character, if the character already exists in the HashMap, and if its mapping value If it is greater than left, then update left to the current mapping value. Then the mapping value is updated to the current coordinate i, which ensures that left is always the previous position of the current boundary, and then when calculating the window length, use i-left directly to update the result res.\n\n\nHere is an explanation of the two conditions `m.count(s[i]) && m[s[i]]> left` in the if conditional statement in the program, because once the current character s[i] has been mapped in the HashMap, it means that the current The character of has already appeared, and if `m[s[i]]> left` is true, it means that the character that appeared before is in the window. If you want to add the current repeated character, you must remove the previous one, so Let left be assigned to `m[s[i]]`, since left is the previous position of the left border of the window (this is also the reason left is initialized to -1, because the left border of the window is traversed from 0), so it is equivalent to having moved Remove the sliding window. For the simplest example “aa”, when `i=0`, a mapping of a->0 is established, and the result res is updated to 1, then when `i=1`, a is found in the HashMap and the mapping The value 0 is greater than -1 for left, so at this time, left is updated to 0, and the mapping pair is updated to a->1, then at this time `i-left` is still 1, without updating the result res, then the final result res is still 1, which is correct.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.HashMap;\n\n\npublic class Longest\\_Substring\\_Without\\_Repeating\\_Characters {\n\n    public static void main(String[] args) {\n\n    \tLongest\\_Substring\\_Without\\_Repeating\\_Characters out = new Longest\\_Substring\\_Without\\_Repeating\\_Characters();\n        Solution s = out.new Solution();\n        int longest = s.lengthOfLongestSubstring(\"abcbefg\");\n\n        System.out.println(longest);\n    }\n\n    // ref: https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/\n    class Solution\\_map {\n        public int lengthOfLongestSubstring(String s) {\n            if (s == null || s.length() == 0) {\n                return 0;\n            }\n\n            int result = 0;\n            HashMap<Character, Integer> hm = new HashMap<>();\n\n            for (int left = 0, right = 0; right < s.length(); right++) {\n                char probeChar = s.charAt(right);\n                if (hm.containsKey(probeChar)) {\n                    // mast max check i\n                    // example \"abba\", last 'a' will result in index 0 if not max checking\n                    left = Math.max(left, hm.get(probeChar) + 1);\n                }\n                hm.put(probeChar, right);\n                result = Math.max(result, right - left + 1);\n            }\n\n            return result;\n        }\n    }\n\n    // @note: remove the final check outside while loop, cleaner code, run time: 7ms. above method 16ms\n    /\\*\n \\* optimization is:\n \\* 1. moving longest recording after\n \\* 2. no extra operation: removing first repeated char in inner while, then adding this char to set next looping\n \\* 3. \"Math.max(j - i + 1, maxLen)\" is cleaner than \"x>y ? x:y\"\n \\*\n \\*/\n    class Solution {\n        public int lengthOfLongestSubstring(String s) {\n\n            if (s == null || s.length() == 0) {\n                return 0;\n            }\n\n            int l = 0; // left\n            int r = 0; // right\n\n            int result = 0;\n            boolean[] isFoundInWindow = new boolean[256];\n\n            while (r < s.length()) {\n\n                while (isFoundInWindow[s.charAt(r)]) {\n                    isFoundInWindow[s.charAt(l)] = false;\n                    l++;\n                }\n\n                isFoundInWindow[s.charAt(r)] = true;\n\n                // check before shrink\n                result = Math.max(result, r - l + 1);\n\n                r++;\n            }\n\n            return result;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 4,
    "title": "Median of Two Sorted Arrays",
    "problem": "\nThere are two sorted arrays **nums1** and **nums2** of size m and n respectively.\n\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log\n (m+n)).\n\n\nYou may assume **nums1** and **nums2** cannot be both empty.\n \n\n\n**Example 1:**\n\n\n\n```\n\nnums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n\n```\n\n**Example 2:**\n\n\n\n```\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n\n```\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/4.html>\n\n\n4. Median of Two Sorted Arrays\n==============================\n\n\nLevel\n-----\n\n\nHard\n\n\nDescription\n-----------\n\n\nThere are two sorted arrays **nums1** and **nums2** of size m and n respectively.\n\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\n\nYou may assume **nums1** and **nums2** cannot be both empty.\n\n\n**Example 1:**\n\n\n\n```\nnums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n\n```\n\n**Example 2:**\n\n\n\n```\nnums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n\n```\n\nSolution\n--------\n\n\nUse the idea of binary search. First of all, if `nums1.length > nums2.length`, then swap the two arrays `nums1` and `nums2`.\n\n\nNext, search in the shorter array `nums1` to make the algorithm more efficient. Initially let `low` be 0 and `high` be `nums1.length`. Each time set `index1 = (high - low) / 2 + low`, and let `index2 = (nums1.length + nums2.length + 1) / 2 - index1`. If `nums1[index1] < nums2[index2 - 1]`, then set `low = index1 + 1`. If `nums1[index1 - 1] > nums2[index2]`, then set `high = index1 - 1`. Otherwise, if the sum of the two arrays’ lengths is odd, then the median is either `nums1[index1 - 1]` or `nums2[index2 - 1]`. If the sum of the two arrays’ lengths is even, then the other element that determines the median is either `nums1[index1]` or `nums[index2]`. Calculate the median accordingly.\n\n\nWhy is it ““target/2”” ??? For example, [1,3,5,…,99], [2,4,6,…,100] two cases\n\n\n1. A total of 100 numbers, then the 50th in all sorts. The average number from the two arrays is 25 numbers each\n2. If it is not average, then [1,2,3,…,50], [51,52,…,100] are all taken from the first array, that is, the first 25 must be From the first array\n\n\ncase m is much longer than n\nmidIndex/2 to check\n private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {\n\n\n### Pitfalls\n\n\n1. The k in dfs is the number of several, not the index. But start/end is index\n2. leftMedian and rightMedian are also numbers, not index\n int leftMedian = (m + n + 1) / 2;\n int rightMedian = (m + n + 2) / 2;\n3. dfs termination condition k==1\n if (k == 1) {\n return Math.min(nums1[start1], nums2[start2]);\n }\n\n\nsolution-2: The optimal solution O(log min(m,n)), a short array of binary search\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Median\\_of\\_Two\\_Sorted\\_Arrays {\n\n\n    // time: O(log(m,n))\n    // space: O(1)\n    class Solution {\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n            int m = nums1.length;\n            int n = nums2.length;\n            int leftMedian = (n + m + 1) / 2;\n            int rightMedian = (n + m + 2) / 2;\n\n            return (getKth(nums1, 0, m - 1, nums2, 0, n - 1, leftMedian) + getKth(nums1, 0, m - 1, nums2, 0, n - 1, rightMedian)) \\* 0.5;\n        }\n\n        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {\n            int len1 = end1 - start1 + 1;\n            int len2 = end2 - start2 + 1;\n\n            if (len1 > len2) {\n                return getKth(nums2, start2, end2, nums1, start1, end1, k);\n            }\n            if (len1 == 0) {\n                return nums2[start2 + k - 1];\n            }\n\n            if (k == 1) {\n                return Math.min(nums1[start1], nums2[start2]);\n            }\n\n            int i = start1 + Math.min(len1, k / 2) - 1;\n            int j = start2 + Math.min(len2, k / 2) - 1;\n\n            if (nums1[i] > nums2[j]) {\n                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));\n            } else {\n                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));\n            }\n        }\n    }\n\n\n    // good ref, with no array copy\n    // https://www.geeksforgeeks.org/median-two-sorted-arrays-different-sizes-ologminn-m/\n\n    // ref: https://leetcode.com/articles/median-of-two-sorted-arrays/\n    /\\*\n Time complexity: O(log(min(m,n))).\n At first, the searching range is [0, m].\n And the length of this searching range will be reduced by half after each loop.\n So, we only need log(m) loops.\n Since we do constant operations in each loop, so the time complexity is O(log(m)).\n Since m <= nm≤n, so the time complexity is O(log(min(m,n))).\n\n Space complexity: O(1)O(1).\n We only need constant memory to store 99 local variables, so the space complexity is O(1).\n \\*/\n    // time: O(log min(m,n))\n    // space: O(1)\n    class Solution\\_iteration {\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n            int length1 = nums1.length, length2 = nums2.length;\n            if (length1 > length2) {\n                int[] tempArray = nums1;\n                nums1 = nums2;\n                nums2 = tempArray;\n                int temp = length1;\n                length1 = length2;\n                length2 = temp;\n            }\n            int low = 0, high = length1, halfLength = (length1 + length2 + 1) / 2;\n            while (low <= high) {\n                int index1 = (high - low) / 2 + low;\n                int index2 = halfLength - index1;\n                if (index1 < high && nums1[index1] < nums2[index2 - 1])\n                    low = index1 + 1;\n                else if (index1 > low && nums1[index1 - 1] > nums2[index2])\n                    high = index1 - 1;\n                else {\n                    int maxLeft = index1 == 0 ? nums2[index2 - 1] : index2 == 0 ? nums1[index1 - 1] : Math.max(nums1[index1 - 1], nums2[index2 - 1]);\n                    if ((length1 + length2) % 2 == 1)\n                        return maxLeft;\n                    int minRight = index1 == length1 ? nums2[index2] : index2 == length2 ? nums1[index1] : Math.min(nums1[index1], nums2[index2]);\n                    return (maxLeft + minRight) / 2.0;\n                }\n            }\n            return 0.0;\n        }\n    }\n\n\n\n\tpublic class Solution2\\_bruteForce {\n\n\t    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n\t        if(nums1 == null || nums2 == null) {\n\t            return -10000;\n\t        }\n\n\t        int totalLength = nums1.length + nums2.length;\n\t        int mid = totalLength / 2;\n\n\t        if (totalLength % 2 == 1) {\n\t            return findTarget(nums1, nums2, mid);\n\t        } else {\n\t            return (findTarget(nums1, nums2, mid) + findTarget(nums1, nums2, mid - 1)) / 2;\n\t        }\n\t    }\n\n\t    // brute force, counting. O(m+n)\n\t    public double findTarget(int[] nums1, int[] nums2, int targetIndex) {\n\n\t        int p1 = 0;\n\t        int p2 = 0;\n\n\t        while(p1 < nums1.length || p2 < nums2.length) {\n\n\t            if(p1 + p2 == targetIndex) {\n\t                int v1updated = p1 < nums1.length ? nums1[p1] : Integer.MAX\\_VALUE;\n\t                int v2updated = p2 < nums2.length ? nums2[p2] : Integer.MAX\\_VALUE;\n\n\t                return Math.min(v1updated, v2updated);\n\t            }\n\n\t            int v1 = p1 < nums1.length ? nums1[p1] : Integer.MAX\\_VALUE;\n\t            int v2 = p2 < nums2.length ? nums2[p2] : Integer.MAX\\_VALUE;\n\n\t            if(v1 < v2) {\n\t                p1++;\n\n\t            } else {\n\t                p2++;\n\t            }\n\t        }\n\n\t        return -10000; // or throw exception \"result not found\"\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 5,
    "title": "Longest Palindromic Substring",
    "problem": "\nGiven a string **s**, find the longest palindromic substring in\n **s**. You may assume that the maximum length of **s** is 1000.\n \n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"babad\"\n**Output:** \"bab\"\n**Note:** \"aba\" is also a valid answer.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"cbbd\"\n**Output:** \"bb\"\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/5.html>\n\n\n\n```\n\n5\tLongest Palindromic Substring\n\n * Given a string S, find the longest palindromic substring in S.\n * You may assume that the maximum length of S is 1000,\n * and there exists one unique longest palindromic substring.\n *\n * A palindrome is a word, phrase, number, or other sequence of characters\n * which reads the same backward or forward\n *\n    Example 1:\n\n    Input: \"babad\"\n    Output: \"bab\"\n    Note: \"aba\" is also a valid answer.\n\n    Example 2:\n\n    Input: \"cbbd\"\n    Output: \"bb\"\n\n@tag-string\n@tag-dp\n\n\n```\n\nAlgorithm\n=========\n\n\nFirst, let me talk about what is a palindrome, that is, a string that reads the same in both front and back, such as “bob”, “level”, “noon” and so on.\n\n\nThen the longest palindrome substring is the longest palindrome substring in a string. There are five questions about palindrome in LeetCode. Except for this one, the other four are `Palindrome Number`, `Validate Palindrome`, `Palindrome Partitioning`, `Palindrome Partitioning II`. We know that the traditional method of verifying palindrome is two by two. Symmetric verification is equal, then for the problem of retrieving the text string, it is necessary to use each character as the center, like two-side diffusion to find the palindrome string. The time complexity of this algorithm is `O(n*n)`, and it can be through OJ .\n\n\nIt is to pay attention to the odd and even situation, because the length of the palindrome string can be odd or even, for example, “bob” is the palindrome in odd form, and “noon” is the palindrome in even form. Both forms of palindrome should be searched, for odd numbers Formally, we start from the traversed position as the center and spread to both sides. For even-numbered cases, we treat the current position and the next position as the middle two characters of the even-numbered palindrome, and then search to both sides.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Longest\\_Palindromic\\_Substring {\n\n    // dynamic programming, note to avoid expensive operation\n    public String longestPalindrome(String s) {\n        if(s == null || s.length() == 0) {\n            return \"\";\n        }\n\n        int longest = Integer.MIN\\_VALUE;\n        int start = 0;\n        int end = 0;\n\n        // initialization， default all false\n        // dp[i][j] meaning substring i-j is palindromic\n        boolean[][] dp = new boolean[s.length()][s.length()];\n\n        for(int i = 0; i < s.length(); i++) {\n\n        \t// @note: for the second pointer j, direction not important, same result\n            // for(int j = i; j >= 0; j--) {\n            for(int j = 0; j <= i; j++) {\n\n                if(i == j || (s.charAt(i) == s.charAt(j) && i - j < 2) || (s.charAt(i) == s.charAt(j) && dp[i - 1][j + 1])) {\n                    dp[i][j] = true;\n\n                    // check max\n                    if(i - j + 1 > longest) {\n                        // @note: below is expensive, over time\n                        // result = s.substring(j, i + 1);\n                        longest = i - j + 1;\n                        start = j;\n                        end = i;\n                    }\n                }\n            }\n        }\n\n        return s.substring(start, end + 1);\n    }\n\n\n\t// brute force, overtime\n\tpublic class Solution2 {\n\t    public String longestPalindrome(String s) {\n\t        if(s == null || s.length() == 0) {\n\t            return \"\";\n\t        }\n\n\t        String result = \"\";\n\n\t        for(int i = 0; i < s.length(); i++) {\n\t            for(int j = i + 1; j < s.length(); j++) {\n\t                String sub = s.substring(i, j + 1);\n\t                if(isPal(sub) && sub.length() > result.length()) {\n\t                    result = sub;\n\t                }\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    public boolean isPal(String s) {\n\t        char[] array = s.toCharArray();\n\t        int i = 0;\n\t        int j = array.length -1;\n\n\t        while(i <= j) {\n\t            if (array[i] != array[j]) {\n\t                return false;\n\t            }\n\t            i++;\n\t            j--;\n\t        }\n\n\t        return true;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 6,
    "title": "ZigZag Conversion",
    "problem": "\nThe string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given\n number of rows like this: (you may want to display this pattern in a fixed font for better\n legibility)\n\n\n\n```\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n\n\n```\n\nstring convert(string s, int numRows);\n```\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"PAYPALISHIRING\", numRows = 3\n**Output:** \"PAHNAPLSIIGYIR\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"PAYPALISHIRING\", numRows = 4\n**Output:** \"PINALSIGYAHRPI\"\n**Explanation:**\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/6.html>\n\n\n\n```\n 6. ZigZag Conversion\n\n\n The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n (you may want to display this pattern in a fixed font for better legibility)\n\n P   A   H   N\n A P L S I I G\n Y   I   R\n And then read line by line: \"PAHNAPLSIIGYIR\"\n\n Write the code that will take a string and make this conversion given a number of rows:\n\n string convert(string s, int numRows);\n Example 1:\n\n Input: s = \"PAYPALISHIRING\", numRows = 3\n Output: \"PAHNAPLSIIGYIR\"\n Example 2:\n\n Input: s = \"PAYPALISHIRING\", numRows = 4\n Output: \"PINALSIGYAHRPI\"\n Explanation:\n\n P     I    N\n A   L S  I G\n Y A   H R\n P     I\n\n\n```\n\nAlgorithm\n=========\n\n\nLaw: The first and last lines are added in the order of 2n-2. The position of the word diagonally across the line is the current column `j+(2n-2)-2i` (i is the index of the row).\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class ZigZag\\_Conversion {\n\n    public class Solution {\n        public String convert(String s, int nRows) {\n            if (s == null || s.length() <= nRows || nRows == 1) {\n                return s;\n            }\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < nRows; i++) {\n                if (i == 0 || i == nRows - 1) {\n                    int index = i;\n                    while (index < s.length()) {\n                        sb.append(s.charAt(index));\n                        index += 2 \\* (nRows - 1);\n                    }\n                } else {\n                    int index = i;\n                    while (index < s.length()) {\n                        sb.append(s.charAt(index));\n                        if (index + 2 \\* nRows - 2 \\* i - 2 < s.length()) {\n                            sb.append(s.charAt(index + 2 \\* nRows - 2 \\* i - 2));\n                        }\n                        index += 2 \\* (nRows - 1);\n                    }\n                }\n            }\n            return sb.toString();\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 7,
    "title": "Reverse Integer",
    "problem": "\nGiven a 32-bit signed integer, reverse digits of an integer.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 123\n**Output:** 321\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** -123\n**Output:** -321\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** 120\n**Output:** 21\n\n```\n\n**Note:**  \n\n Assume we are dealing with an environment which could only store integers within the 32-bit\n signed integer range: [−231,  231− 1]. For the\n purpose of this problem, assume that your function returns 0 when the reversed integer\n overflows.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/7.html>\n\n\n\n```\n7\tReverse Integer\n\nReverse digits of an integer.\n\nExample1: x = 123, return 321\nExample2: x = -123, return -321\nExample 3:\n\tInput: 120\n\tOutput: 21\n\n[click to show spoilers.]\n\nHave you thought about this?\nHere are some good questions to ask before coding. Bonus points for you if you have already thought through this!\n\nIf the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.\n\nDid you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?\n\nFor the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\nNote:\nThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\n\n\n```\n\nAlgorithm\n=========\n\n\nOne thing to pay attention to when flipping numbers is the overflow problem. After reading many online solutions, since the previous OJ did not test for overflow, many people’s solutions on the internet can pass OJ without dealing with the overflow problem.\n\n\nNow OJ has updated the overflow test, so it still needs to be considered. Why is there an overflow problem? Since the value range of the int type is -2147483648～2147483647, if you want to flip the number within the range of 1000000009 to get 9000000001, the number after the flip exceeds the range. The initial idea of ​​the blogger is to use long data, the value range of which is -9223372036854775808~9223372036854775807, which is much larger than int so that there will be no overflow problem.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Reverse\\_Integer {\n\n\tpublic static void main(String[] args) {\n\t\tReverse\\_Integer out = new Reverse\\_Integer();\n\t\tSolution s = out.new Solution();\n\n\t\tSystem.out.println(s.reverse(1234567899));\n\n\n\t\tSystem.out.println(1234567899 \\* 10); // output: -539222898\n\t}\n\n\t/\\*\n\n from online:\n\n If overflow exists, the new result will not equal previous one.\n No flags needed. No hard code like 0xf7777777 needed.\n \\*/\n\tpublic class Solution {\n\t\tpublic int reverse(int x) {\n\t\t\tint result = 0;\n\n\t\t\twhile (x != 0) {\n\t\t\t\tint tail = x % 10;\n\t\t\t\tint newResult = result \\* 10 + tail;\n\n\t\t\t\t// If overflow exists, the new result will not equal previous one.\n\t\t\t\t/\\*\n result = 998765432\n\n newResult = 1397719729 // here the program will do a cast, meaning overflow\n\n \\*/\n\t\t\t\tif ((newResult - tail) / 10 != result) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tresult = newResult;\n\n\t\t\t\tx = x / 10;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tpublic class Solution\\_longType {\n\t    public int reverse(int x) {\n\n\t        int flag = 1;\n\n\t        if (x < 0) {\n\t            x \\*= -1;\n\t            flag = -1;\n\t        }\n\n\t        long result = 0; // initialize as long type\n\n\t        while(x > 0) {\n\t            int least = x % 10;\n\t            result = result \\* 10 + least;\n\t            x /= 10;\n\t        }\n\n\t        // check overflow\n\t        if(result > Integer.MAX\\_VALUE || result \\* flag < Integer.MIN\\_VALUE) {\n\t            return 0;\n\t        }\n\n\t        return (int) (flag \\* result);\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 8,
    "title": "String to Integer (atoi)",
    "problem": "\nImplement `atoi` which converts a string to an integer.\n\n\nThe function first discards as many whitespace characters as necessary until the first\n non-whitespace character is found. Then, starting from this character, takes an optional\n initial plus or minus sign followed by as many numerical digits as possible, and interprets\n them as a numerical value.\n\n\nThe string can contain additional characters after those that form the integral number, which\n are ignored and have no effect on the behavior of this function.\n\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or\n if no such sequence exists because either str is empty or it contains only whitespace\n characters, no conversion is performed.\n\n\nIf no valid conversion could be performed, a zero value is returned.\n\n\n**Note:**\n\n\n* Only the space character `' '` is considered as whitespace character.\n* Assume we are dealing with an environment which could only store integers within the\n 32-bit signed integer range: [−231,  231−\n 1]. If the numerical value is out of the range of representable values, INT\\_MAX (231−\n 1) or INT\\_MIN (−231) is returned.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"42\"\n**Output:** 42\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"   -42\"\n**Output:** -42\n**Explanation:** The first non-whitespace character is '-', which is the minus sign.\n             Then take as many numerical digits as possible, which gets 42.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** \"4193 with words\"\n**Output:** 4193\n**Explanation:** Conversion stops at digit '3' as the next character is not a numerical digit.\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:** \"words and 987\"\n**Output:** 0\n**Explanation:** The first non-whitespace character is 'w', which is not a numerical\n             digit or a +/- sign. Therefore no valid conversion could be performed.\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:** \"-91283472332\"\n**Output:** -2147483648\n**Explanation:** The number \"-91283472332\" is out of the range of a 32-bit signed integer.\n             Thefore INT_MIN (−231) is returned.\n```\n\n\n### \n\n",
    "explanation": "Not Populated Yet."
  },
  {
    "id": 9,
    "title": "Palindrome Number",
    "problem": "\nDetermine whether an integer is a palindrome. An integer is a palindrome when\n it reads the same backward as forward.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 121\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome.\n\n```\n\n**Follow up:**\n\n\nCoud you solve it without converting the integer to a string?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/9.html>\n\n\n\n```\n9. Palindrome Number\n\nDetermine whether an integer is a palindrome. Do this without extra space.\n\nExample 1:\n\nInput: 121\nOutput: true\nExample 2:\n\nInput: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\n\nInput: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\nFollow up:\n\nCoud you solve it without converting the integer to a string?\n\n\n\nSome hints:\nCould negative integers be palindromes? (ie, -1)\n\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\n\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\",\nyou know that the reversed integer might overflow. How would you handle such case?\n\nThere is a more generic way of solving this problem.\n\n\n```\n\nAlgorithm\n=========\n\n\nFirst judge whether x is a negative number. A small trick can be used here, because the highest bit of an integer cannot be 0, so the lowest bit of the palindrome cannot be 0, except for the number 0, so if you find that the end of a positive number is 0 , Just return false directly. Well, let’s look at the specific solution below.\n\n\nTo verify the number of palindromes, you need to see if the front and back half are symmetrical. If you flip the second half, you can see if it is equal to the first half. So the method is to take out the second half of the number and reverse it.\n\n\nThe specific method is to take the remainder of 10 each time, take the lowest digit, and then add it to the end of the taken number, which is to multiply revertNum by 10 and add the remainder , So the flip is completed at the same time, every time a lowest digit is taken, x must be divided by 10. In this way, the loop stops when revertNum is greater than or equal to x.\n\n\nSince the number of palindromes can be even or odd,\n\n\n* if it is an even number, then revertNum should be equal to x;\n* if it is an odd number, then the middle number is at the lowest bit of revertNum, and it should be divided by 10 And x are equal\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Palindrome\\_Number {\n\n\tpublic static void main(String[] args) {\n\t\tPalindrome\\_Number out = new Palindrome\\_Number();\n\t\tSolution s = out.new Solution();\n\n\t\tSystem.out.println(s.isPalindrome(12321));\n\t\tSystem.out.println(s.isPalindrome(Integer.MAX\\_VALUE));\n\t}\n\n\tpublic class Solution {\n\t\tpublic boolean isPalindrome(int x) {\n\t\t\tif(x < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlong rev = 0;\n\n\t\t\tint y = x;\n\t\t\twhile(y > 0) {\n\t\t\t\tint remainder = y % 10;\n\t\t\t\ty /= 10;\n\n\t\t\t\trev = rev \\* 10 + remainder;\n\t\t\t}\n\n\t\t\tif(rev > Integer.MAX\\_VALUE) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ((int) rev) == x;\n\t\t}\n\t}\n\n\tpublic class Solution2 {\n\t    public boolean isPalindrome(int x) {\n\t        if (x < 0) {\n\t            return false;\n\t        }\n\n\t        int xorig = x;\n\t        int rev = 0;\n\t        while(x > 0) {\n\t            rev = rev \\* 10 + x % 10;\n\t            x /= 10;\n\t        }\n\n\t        return rev == xorig;\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 10,
    "title": "Regular Expression Matching",
    "problem": "\nGiven an input string (`s`) and a pattern (`p`), implement regular\n expression matching with support for `'.'` and `'*'`.\n \n\n\n\n```\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\n```\n\nThe matching should cover the **entire** input string (not partial).\n\n\n**Note:**\n\n\n* `s` could be empty and contains only lowercase letters `a-z`.\n* `p` could be empty and contains only lowercase letters `a-z`, and\n characters like `.` or `*`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\ns = \"aa\"\np = \"a\"\n**Output:** false\n**Explanation:** \"a\" does not match the entire string \"aa\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\ns = \"aa\"\np = \"a*\"\n**Output:** true\n**Explanation:** '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:**\ns = \"ab\"\np = \".*\"\n**Output:** true\n**Explanation:** \".*\" means \"zero or more (*) of any character (.)\".\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:**\ns = \"aab\"\np = \"c*a*b\"\n**Output:** true\n**Explanation:** c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\".\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:**\ns = \"mississippi\"\np = \"mis*is*p*.\"\n**Output:** false\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/10.html>\n\n\n\n```\n10\tRegular Expression Matching\n\nImplement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"aa\", \".*\") → true\nisMatch(\"ab\", \".*\") → true\nisMatch(\"aab\", \"c*a*b\") → true\n\n@tag-dp\n\n```\n\nAlgorithm\n=========\n\n\nThe general idea is as follows:\n\n\n* If p is empty, if s is also empty, return true, otherwise return false.\n* If the length of p is 1, if the length of s is also 1, and the same or p is’.’, it returns true, otherwise it returns false.\n* If the second character of p is not \\*, if s is empty at this time, false is returned, otherwise it is judged whether the first character matches, and the recursive function matching is called from the respective second character.\n* If the second character of p is \\*, perform the following loop. The condition is that if s is not empty and the first character matches (including p[0] as a dot), call the recursive function to match s and remove the first two characters of p( The reason for this is to assume that the role of the asterisk at this time is to make the preceding character appear 0 times to verify whether it matches), if the match returns true, otherwise the first letter of s is removed (because the first letter is matched at this time, we can remove the s Because of the asterisk, p can have any initials, so there is no need to remove them), and continue the loop.\n* Return the result of calling the recursive function to match s and remove the first two characters of p (the reason for this is to deal with the content that the asterisk cannot match, such as s=”ab”, p=”a*b”, and directly enter the while loop Later, we find that “ab” and “b” do not match, so s becomes “b”, then after jumping out of the loop, we go to the last return to compare “b” and “b” and return true. An example, such as s=””, p=”a*”, because s is empty, no if and while will be entered, and can only be compared at the last return and return true, correct).\n\n\n/\\*\n\n\n* 1. two cases, “\\*” is 0 or non-0:\n* 1.1: cccbbbaaa matching c*b*a\\*\n* 1.2: bbbaaa matching c*b*a\\*\n \\*\n \\*/\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Regular\\_Expression\\_Matching {\n\n\tpublic static void main(String[] args) {\n\t\tRegular\\_Expression\\_Matching out = new Regular\\_Expression\\_Matching();\n\t\tSolution s = out.new Solution();\n\n\t\tSystem.out.println(s.isMatch(\"aa\", \"a\\*\"));\n\n\t\tSystem.out.println(s.isMatch(\"aaa\", \"ab\\*a\")); // false. same as: \"aa\",\"b\\*a\"\n\n\t\tSystem.out.println(s.isMatch(\"cccbbbaaa\", \"c\\*b\\*a\\*\"));\n\t\tSystem.out.println(s.isMatch(\"bbbaaa\", \"c\\*b\\*a\\*\"));\n\n\t\tSolution s2 = out.new Solution();\n\t\tSystem.out.println(s2.isMatch(\"aaa\", \"ab\\*a\")); // false. same as: \"aa\",\"b\\*a\"\n\n\t}\n\n\n    public class Solution\\_iteration {\n        public boolean isMatch(String s, String p) {\n\n            int i = 0, j = 0, iStar = -1, jStar = -1, m = s.length(), n = p.length();\n\n            while (i < m) {\n                if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n                    ++i;\n                    ++j;\n                } else if (j < n && p.charAt(j) == '\\*') {\n                    iStar = i;\n                    jStar = j++;\n                } else if (iStar >= 0) {\n                    i = ++iStar;\n                    j = jStar + 1;\n                } else {\n                    return false;\n                }\n            }\n\n            while (j < n && p.charAt(j) == '\\*') {\n                ++j;\n            }\n\n            return j == n;\n        }\n\t}\n\n\tpublic class Solution {\n\t    public boolean isMatch(String s, String p) {\n\t        if(s == null || p == null) {\n\t            return false;\n\t        }\n\n\t        if(p.length() == 0) {\n\t            return s.length() == 0;\n\t        }\n\n\t        if(p.length() == 1) {\n\t            // @note: if(p.charAt(0) == \"\\*\"), not possible, since \\* must be following a char, cannot match \"aaaaa\" with \"\\*\", but with \"a\\*\"\n\t            return (s.length() == 1) && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.' || p.charAt(0) == '\\*');\n\t        }\n\n\t        // now p.length is at least 2\n\t        if(p.charAt(1) != '\\*') { // @note: char is single quote... if(p.charAt(1) != \"\\*\") {\n\t            if(s.length() == 0) {\n\t                return false;\n\t            } else {\n\t                return (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.') && isMatch(s.substring(1), p.substring(1));\n\t            }\n\t        }\n\n\t        // now 2nd char of p is \"\\*\"\n\t        // case 1.1: cccbbbaaa matching c\\*b\\*a\\*\n\t        int i = 0;\n\t        // @note: 1. missed p.charAt(0) == '.'\n\t        // @note: 2. order of conditions, first check if i is out of boundary, then check the rest\n\t        // while(s.charAt(i) == p.charAt(0) && i < s.length()) {\n\t        // while((s.charAt(i) == p.charAt(0) || p.charAt(0) == '.') && i < s.length()) {\n\t        while(i < s.length() && (s.charAt(i) == p.charAt(0) || p.charAt(0) == '.')) { // \"aa\",\"b\\*a\"\n\t            // one match is enough\n\t            if(isMatch(s.substring(i + 1), p.substring(2))) {\n\t                return true;\n\t            }\n\n\t            i++;\n\t        }\n\n\t        // case 1.2: bbbaaa matching c\\*b\\*a\\*\n\t        return isMatch(s, p.substring(2));\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 11,
    "title": "Container With Most Water",
    "problem": "\nGiven *n* non-negative integers *a1*, *a2*, ...,\n *an*, where each represents a point at coordinate (*i*, *ai*).\n *n* vertical lines are drawn such that the two endpoints of line *i* is at\n (*i*, *ai*) and (*i*, 0). Find two lines, which together with\n x-axis forms a container, such that the container contains the most water.\n\n\n**Note:**You may not slant the container and *n* is at least 2.\n\n\n \n\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\n\n\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case,\n the max area of water (blue section) the container can contain is 49.\n \n\n\n\n \n\n\n**Example:**\n\n\n\n```\n\n**Input:** [1,8,6,2,5,4,8,3,7]\n**Output:** 49\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/11.html>\n\n\n\n```\nGiven n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai).\n\nn vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).\n\nFind two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container.\n\nExample:\n\nInput: [1,8,6,2,5,4,8,3,7]\nOutput: 49\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nThe following is an example: [4,6,2,6,7,11,2] to explain.\n\n\n1 . First, suppose we find the vertical line that can take the maximum volume as i, j (assuming i<j), then the maximum volume C = min( ai, aj) \\* (j- i);\n\n\n2 . Below we look at such a property:\n\n\n* No line at the right end of j will be higher than it! Suppose there is k |( j<k && ak> aj), then ak> aj, so min(ai,aj, ak) =min(ai,aj), so the volume of the container formed by i, k C’= min(ai,aj) \\* (ki)> C, which is the most contradictory value with C, so there will be no line higher than it behind the proof j;\nTo\n* Similarly, there will be no higher line on the left side of i;\nTo\n What is this indicating? If we currently get the candidate: set x, y as two lines (x< y), then the two new edges that can be larger than it must be in the interval [x,y]\nAnd ax’> =ax, ay’>= ay;\n\n\n3 . So we move closer from the two ends to the middle, and update the candidate values ​​at the same time; when shrinking the interval, first shrink from the smaller edge of x, y;\n\n\nThe intuitive explanation is: volume is area, which is affected by length and height. When the length decreases, the height must increase to increase the area, so we start to decrease from the longest length, and then look for a higher line to update Alternate\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Container\\_With\\_Most\\_Water {\n\n\tpublic static void main(String[] args) {\n\t\tContainer\\_With\\_Most\\_Water out = new Container\\_With\\_Most\\_Water();\n\t\tSolution2 s = out.new Solution2();\n\n\t\tSystem.out.println(s.maxArea(new int[]{2,0,2}));\n\t}\n\n    // time: O(N)\n    // space: O(1)\n\tpublic class Solution {\n\t    public int maxArea(int[] height) {\n\t        int[] h = height;\n\n\t        if(h == null || h.length == 0) {\n\t            return 0;\n\t        }\n\n\t        int l = 0; // left\n\t        int r = h.length - 1; // right\n\n\t        int max = (r - l) \\* Math.min(h[l], h[r]); // possibly very first position is max area\n\t        while(l < r) {\n\t            if(h[l] < h[r]) {\n\t                l++;\n\t            } else {\n\t                r--;\n\t            }\n\n\t            max = Math.max(max, (r - l) \\* Math.min(h[l], h[r]));\n\t        }\n\n\t        return max;\n\t    }\n\t}\n\n\t// N^2. Time Limit Exceeded\n\tpublic class Solution2 {\n\t\tpublic int maxArea(int[] h) { // h: height\n\t\t\tif (h == null || h.length == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// possibly sanity check for negative int in array, throw something for debugging\n\t\t\t// never trust the passed in parameter!\n\n\t\t\tint i = 0;\n\t\t\tint max = Integer.MIN\\_VALUE;\n\t\t\twhile (i < h.length) {\n\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < h.length) {\n\n\t\t\t\t\tmax = Math.max(max, (j - i) \\* Math.min(h[i], h[j]));\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn max;\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 12,
    "title": "Integer to Roman",
    "problem": "\nRoman numerals are represented by seven different symbols: `I`,\n `V`, `X`, `L`, `C`, `D` and\n `M`.\n\n\n\n```\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\nFor example, two is written as `II` in Roman numeral, just two one's\n added together. Twelve is written as, `XII`, which is simply `X` +\n `II`. The number twenty seven is written as `XXVII`, which is\n `XX` + `V` + `II`.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the\n numeral for four is not `IIII`. Instead, the number four is written as\n `IV`. Because the one is before the five we subtract it making four. The same\n principle applies to the number nine, which is written as `IX`. There are six\n instances where subtraction is used:\n\n\n* `I` can be placed before `V` (5) and `X` (10) to make 4\n and 9.\n* `X` can be placed before `L` (50) and `C` (100) to make\n 40 and 90.\n* `C` can be placed before `D` (500) and `M` (1000) to\n make 400 and 900.\n\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range\n from 1 to 3999.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 3\n**Output:** \"III\"\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 4\n**Output:** \"IV\"\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** 9\n**Output:** \"IX\"\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:** 58\n**Output:** \"LVIII\"\n**Explanation:** L = 50, V = 5, III = 3.\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:** 1994\n**Output:** \"MCMXCIV\"\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/12.html>\n\n\n\n```\n 12. Integer to Roman\n\n Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n Symbol       Value\n I             1\n V             5\n X             10\n L             50\n C             100\n D             500\n M             1000\n\n For example, two is written as II in Roman numeral, just two one's added together.\n Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n\n Roman numerals are usually written largest to smallest from left to right.\n However, the numeral for four is not IIII. Instead, the number four is written as IV.\n Because the one is before the five we subtract it making four.\n The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n     I can be placed before V (5) and X (10) to make 4 and 9.\n     X can be placed before L (50) and C (100) to make 40 and 90.\n     C can be placed before D (500) and M (1000) to make 400 and 900.\n\n Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n Example 1:\n     Input: 3\n     Output: \"III\"\n\n Example 2:\n     Input: 4\n     Output: \"IV\"\n\n Example 3:\n     Input: 9\n     Output: \"IX\"\n\n Example 4:\n     Input: 58\n     Output: \"LVIII\"\n     Explanation: L = 50, V = 5, III = 3.\n\n Example 5:\n     Input: 1994\n     Output: \"MCMXCIV\"\n     Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n @tag-string\n\n```\n\nAlgorithm\n=========\n\n\nBecause the range of input numbers (1-3999) is limited in the question, the question becomes much simpler.\n\n\nI-1\n\n\nV-5\n\n\nX-10\n\n\nL-50\n\n\nC-100\n\n\nD-500\n\n\nM-1000\n\n\nFor example, the Roman numeral for the integer 1437 is MCDXXXVII. It is not difficult to find that the thousands, hundreds, tens, and ones digits are represented by Roman numerals. 1000-M, 400-CD, 30-XXX, 7-VII. So what we have to do is to use the quotient method to extract the numbers in each digit, and then express them separately:\n\n\n100-C\n\n\n200-CC\n\n\n300-CCC\n\n\n400-CD\n\n\n500-D\n\n\n600-DC\n\n\n700-DCC\n\n\n800-DCCC\n\n\n900-CM\n\n\nCan be divided into four categories, 100 to 300 category, 400 category, 500 to 800 category, 900 last category. The situation on digit is similar.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Integer\\_to\\_Roman {\n    public class Solution {\n\n        /\\*\n steps for Roman number:\n 1. 1 <= digit <= 3, append that digit number of Roman\n 2. digit = 4, append \"I\"+Roman\n 3. digit = 5,10, etc... append Roman\n 4. 6 <= digit <= 8, append Roman+\"I\"\n 5. digit = 9, append \"I\"+Roman\n \\*/\n        public String intToRoman(int num) {\n\n            // @note: pre-calculate 900,400,90,40,9,4\n            String[] symbols = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n\n            // order: descending\n            int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n            StringBuilder result = new StringBuilder();\n\n            for (int i = 0; i < values.length; i++) {\n                while (num >= values[i]) {\n                    result.append(symbols[i]);\n                    num -= values[i];\n                }\n            }\n\n            return new String(result);\n\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 13,
    "title": "Roman to Integer",
    "problem": "\nRoman numerals are represented by seven different symbols: `I`,\n `V`, `X`, `L`, `C`, `D` and\n `M`.\n\n\n\n```\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\nFor example, two is written as `II` in Roman numeral, just two one's\n added together. Twelve is written as, `XII`, which is simply `X` +\n `II`. The number twenty seven is written as `XXVII`, which is\n `XX` + `V` + `II`.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the\n numeral for four is not `IIII`. Instead, the number four is written as\n `IV`. Because the one is before the five we subtract it making four. The same\n principle applies to the number nine, which is written as `IX`. There are six\n instances where subtraction is used:\n\n\n* `I` can be placed before `V` (5) and `X` (10) to make 4\n and 9.\n* `X` can be placed before `L` (50) and `C` (100) to make\n 40 and 90.\n* `C` can be placed before `D` (500) and `M` (1000) to\n make 400 and 900.\n\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range\n from 1 to 3999.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"III\"\n**Output:** 3\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"IV\"\n**Output:** 4\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** \"IX\"\n**Output:** 9\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:** \"LVIII\"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:** \"MCMXCIV\"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/13.html>\n\n\n\n```\n 13\tRoman to Integer\n\n Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n Symbol       Value\n I             1\n V             5\n X             10\n L             50\n C             100\n D             500\n M             1000\n For example, two is written as II in Roman numeral, just two one's added together.\n Twelve is written as, XII, which is simply X + II.\n The number twenty seven is written as XXVII, which is XX + V + II.\n\n Roman numerals are usually written largest to smallest from left to right.\n However, the numeral for four is not IIII. Instead, the number four is written as IV.\n Because the one is before the five we subtract it making four.\n The same principle applies to the number nine, which is written as IX.\n There are six instances where subtraction is used:\n\n I can be placed before V (5) and X (10) to make 4 and 9.\n X can be placed before L (50) and C (100) to make 40 and 90.\n C can be placed before D (500) and M (1000) to make 400 and 900.\n Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n\n Example 1:\n\n Input: \"III\"\n Output: 3\n\n Example 2:\n\n Input: \"IV\"\n Output: 4\n\n Example 3:\n\n Input: \"IX\"\n Output: 9\n\n Example 4:\n\n Input: \"LVIII\"\n Output: 58\n Explanation: L = 50, V= 5, III = 3.\n\n Example 5:\n\n Input: \"MCMXCIV\"\n Output: 1994\n Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n @tag-string\n\n```\n\nAlgorithm\n=========\n\n\nI-1\n\n\nV-5\n\n\nX-10\n\n\nL-50\n\n\nC-100\n\n\nD-500\n\n\nM-1000\n\n\n1. The same number is written consecutively, the number represented is equal to the number obtained by adding these numbers, such as: Ⅲ = 3;\n2. The small number is on the right side of the big number, and the number represented is equal to the number obtained by adding these numbers, such as: Ⅷ = 8; Ⅻ = 12;\n3. Small numbers (limited to Ⅰ, X and C) are on the left side of large numbers, and the number represented is equal to the number obtained by reducing the large number, such as: Ⅳ = 4; Ⅸ = 9;\n4. In normal use, the consecutive number shall not be repeated more than three times. (The four o’clock “IIII” on the dial is an exception)\n5. Draw a horizontal line on top of a number, which means that the number is expanded 1000 times.\n\n\nThere are a few things to be aware of:\n\n\n1. Any one of the basic numbers I, X, and C can not exceed three if it is used to form a number by itself or is placed on the right side of a large number; only one can be used on the left side of a large number.\n2. You can’t put any of the basic numbers V, L, D as a decimal number on the left side of the large number and use subtraction to form the number; put it on the right side of the large number and use the addition method to form the number, only one can be used.\n3. The small numbers to the left of V and X can only use Ⅰ.\n4. The small numbers to the left of L and C can only be X.\n5. Only C can be used for the small numbers on the left of D and M.\n\n\nThe good thing about this question is that it didn’t let us verify whether the input string is a Roman numeral, which saves a lot of effort. You need to use the HashMap data structure to convert the letters of the Roman numerals into the corresponding integer values, because the input must be a Roman numeral, so just consider two cases:\n\n\n1. if the current number is the last number, or the following number is smaller than it, the current number is added.\n2. in other cases, this number is subtracted.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Roman\\_to\\_Integer {\n    class Solution {\n        public int romanToInt(String s) {\n\n\n            // pre-process array\n            int nums[] = new int[s.length()];\n            for (int i = 0; i < s.length(); i++) {\n                switch (s.charAt(i)) {\n                    case 'M':\n                        nums[i] = 1000;\n                        break;\n                    case 'D':\n                        nums[i] = 500;\n                        break;\n                    case 'C':\n                        nums[i] = 100;\n                        break;\n                    case 'L':\n                        nums[i] = 50;\n                        break;\n                    case 'X':\n                        nums[i] = 10;\n                        break;\n                    case 'V':\n                        nums[i] = 5;\n                        break;\n                    case 'I':\n                        nums[i] = 1;\n                        break;\n                }\n            }\n\n            // sum up\n            int sum = 0;\n            for (int i = 0; i < nums.length - 1; i++) {\n                if (nums[i] < nums[i + 1]) {\n                    sum -= nums[i];\n                } else {\n                    sum += nums[i];\n                }\n            }\n            return sum + nums[nums.length - 1];\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 14,
    "title": "Longest Common Prefix",
    "problem": "\nWrite a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string `\"\"`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [\"flower\",\"flow\",\"flight\"]\n**Output:** \"fl\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [\"dog\",\"racecar\",\"car\"]\n**Output:** \"\"\n**Explanation:** There is no common prefix among the input strings.\n\n```\n\n**Note:**\n\n\nAll given inputs are in lowercase letters `a-z`.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/14.html>\n\n\n\n```\n14\tLongest Common Prefix\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nExample 1:\n\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\n\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nNote:\nAll given inputs are in lowercase letters a-z.\n\n@tag-string\n\n```\n\nAlgorithm\n=========\n\n\nThere is no special skill, just a brainless search, define two variables i and j, where i is to traverse the characters in the search string, and j is to traverse each string in the string set.\n\n\nHere, if the words are arranged up and down, it is equivalent to a two-dimensional array with unequal line lengths. The traversal order is different from the general horizontal line-by-line traversal. Instead, the vertical traversal is adopted. No, it means it is the shortest word, because the length of the common prefix cannot be longer than the shortest word, so the common prefix that has been found is returned at this time.\n\n\nTake out the word at a certain position of the first string each time, and then traverse the corresponding positions of all other strings to see if they are equal, if there are unsatisfied, return res directly, if they are all the same, save the current character in the result, continue Check the character in the next position.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Longest\\_Common\\_Prefix {\n\n\tpublic class Solution {\n\t\tpublic String longestCommonPrefix(String[] s) {\n\t\t\tif (s == null || s.length == 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tint i = 0;\n\t\t\tStringBuilder result = new StringBuilder();\n\t\t\twhile (true) {\n\t\t\t\tfor (String each : s) {\n\t\t\t\t\tif (i >= each.length() || each.charAt(i) != s[0].charAt(i)) {\n\t\t\t\t\t\treturn result.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.append(s[0].charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 15,
    "title": "3Sum",
    "problem": "\nGiven an array `nums` of *n* integers, are there elements *a*,\n *b*, *c* in `nums` such that *a* + *b* + *c* =\n 0? Find all unique triplets in the array which gives the sum of zero.\n\n\n**Note:**\n\n\nThe solution set must not contain duplicate triplets.\n\n\n**Example:**\n\n\n\n```\n\nGiven array nums = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n```\n\n\n### \n\n",
    "explanation": "Not Populated Yet."
  },
  {
    "id": 16,
    "title": "3Sum Closest",
    "problem": "\nGiven an array `nums` of *n* integers and an integer `target`,\n find three integers in `nums` such that the sum is closest to `target`.\n Return the sum of the three integers. You may assume that each input would have exactly one\n solution.\n\n\n**Example:**\n\n\n\n```\n\nGiven array nums = [-1, 2, 1, -4], and target = 1.\n\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n```\n\n\n### \n\n",
    "explanation": "Not Populated Yet."
  },
  {
    "id": 17,
    "title": "Letter Combinations of a Phone Number",
    "problem": "\nGiven a string containing digits from `2-9` inclusive, return all possible letter\n combinations that the number could represent.\n\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that\n 1 does not map to any letters.\n\n\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)\n\n\n\n**Example:**\n\n\n\n```\n\n**Input:** \"23\"\n**Output:** [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n```\n\n**Note:**\n\n\nAlthough the above answer is in lexicographical order, your answer could be in any order you\n want.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/17.html>\n\n\n\n```\n17\tLetter Combinations of a Phone Number\n\nGiven a digit string, return all possible letter combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below.\n\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\n\n@June.18,2017:\n\tvariation-1: input with duplicate digits \"222222\", then it's a duplicate reduction process\n\t\t\t\t\tmaybe need to pre-sort the charArray of string\n\tvariation-2: now the result combination string length is the same as in put string\n\t\t\t\t\tbut result string length could from 1 to input string length\n\t\t\t\t\talso duplicate issue. \"222\" -> a,b,c,aa,ab,ac,bb,bc,cc,aaa,aab,aac,....ccc\n\t\t\t\t\tI'll use set of string to avoid duplicated string...\n@tag-string\n\n```\n\nAlgorithm\n=========\n\n\nSimilar topics include Path Sum II, Subsets II, Permutations, Permutations II, Combinations, Combination Sum and Combination Sum II and so on.\n\n\nHere you can use recursive Recursion to solve, you need to build a dictionary to store the string represented by each number, and then you need a variable level, which records the number of characters in the currently generated string, and realizes the routine and the above questions. similar. In the recursive function, the level is first judged. If the number of digits in digits is equal, the current combination is added to the result res, and then returned. We pass the number in digits to the dict to extract the string, then traverse the extracted string, add each character to the current combination, and call the recursive function.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Letter\\_Combinations\\_of\\_a\\_Phone\\_Number {\n\n\tpublic class Solution {\n\n\t    List<String> list = new ArrayList<String>();\n\t    ArrayList<String> eachDigit = new ArrayList<String>();\n\t    StringBuilder one = new StringBuilder();\n\n\t    public List<String> letterCombinations(String s) {\n\n\t        if (s == null)   return list;\n\t        if (s.length() == 0)    {   list.add(\"\");  return list; }\n\n\t        String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; // number 0, 1 is empty string\n\n\t        for (int i = 0; i < s.length(); i++) {\n\t            int num = s.charAt(i) - '0';\n\t            eachDigit.add(map[num]); // possible out of boundary, assumption is valid input\n\t        }\n\n\t        dfs(eachDigit, 0, s.length());\n\n\t        return list;\n\t    }\n\n\t    public void dfs(ArrayList<String> eachDigit, int index, int totalSize) {\n\n\t        if (index == totalSize) {\n\t            list.add(new String(one)); // or, just pass in a result string, and avoid append() then deleteLast()\n\t            return;\n\t        }\n\n\t        String current = eachDigit.get(index);\n\t        for (int i = 0; i < current.length(); i++) {\n\t            one.append(current.charAt(i));\n\t            dfs(eachDigit, index + 1, totalSize);\n\t            one.deleteCharAt(one.length() - 1); // if string, then it's s.substring(0, s.length() - 1)\n\t        }\n\t    }\n\t}\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 18,
    "title": "4Sum",
    "problem": "\nGiven an array `nums` of *n* integers and an integer `target`,\n are there elements *a*, *b*, *c*, and *d* in `nums`\n such that *a* + *b* + *c* + *d* = `target`? Find all\n unique quadruplets in the array which gives the sum of `target`.\n\n\n**Note:**\n\n\nThe solution set must not contain duplicate quadruplets.\n\n\n**Example:**\n\n\n\n```\n\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/18.html>\n\n\n\n```\nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target?\nFind all unique quadruplets in the array which gives the sum of target.\n\nNote:\nElements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)\nThe solution set must not contain duplicate quadruplets.\n    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.\n\n    A solution set is:\n    (-1,  0, 0, 1)\n    (-2, -1, 1, 2)\n    (-2,  0, 0, 2)\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nSort the original array, and then start traversing the sorted array. Note that the traversal is not to the last stop, but to the third from the bottom. Here you can do a pruning optimization first, that is, break when traversing to a positive number, why, because the array is now ordered, if the first number to be fixed is a positive number, then the following numbers\n\n\nIf they are all positive numbers, the sum will never be zero. Then add the process of skipping if repeated. The processing method is to start with the second number.\n\n\nIf it is equal to the previous number, skip it because you don’t want to fix the same number twice. For the traversed number, subtract the fix number from 0 to get a target, and then only need to find the sum of the two numbers is equal to the target.\n\n\nUse two pointers to point to the first and last two numbers of the array starting after the fix number. If the sum of the two numbers happens to be the target, then the two numbers and the fix number are stored in the result together. Then is to skip the step of repeating numbers. Both pointers need to detect repeated numbers. If the sum of the two numbers is less than the target, move the pointer i on the left one bit to the right to increase the number pointed to. In the same way, if the sum of the two numbers is greater than the target, move the pointer j on the right to the left to reduce the number pointed to.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n// general solution, k-sum\n// https://leetcode.com/problems/4sum/solution/\nclass Solution {\n\n\tpublic List<List<Integer>> fourSum(int[] nums, int target) {\n\t\tArrays.sort(nums);\n\t\treturn kSum(nums, target, 0, 4);\n\t}\n\n\tpublic List<List<Integer>> kSum(int[] nums, int target, int start, int k) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif (start == nums.length || nums[start] \\* k > target || target > nums[nums.length - 1] \\* k)\n\t\t\treturn res;\n\t\tif (k == 2)\n\t\t\treturn twoSum(nums, target, start);\n\t\tfor (int i = start; i < nums.length; ++i)\n\t\t\tif (i == start || nums[i - 1] != nums[i]) // 'i == start' is key, since it could be in a following recurion of [1,1,1] where start is 3rd '1'\n\t\t\t\tfor (List<Integer> set : kSum(nums, target - nums[i], i + 1, k - 1)) {\n\t\t\t\t\tres.add(new ArrayList<>(Arrays.asList(nums[i])));\n\t\t\t\t\tres.get(res.size() - 1).addAll(set);\n\t\t\t\t}\n\t\treturn res;\n\t}\n\n\tpublic List<List<Integer>> twoSum(int[] nums, int target, int start) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tint lo = start, hi = nums.length - 1;\n\t\twhile (lo < hi) {\n\t\t\tint sum = nums[lo] + nums[hi];\n\t\t\tif (sum < target || (lo > start && nums[lo] == nums[lo - 1]))\n\t\t\t\t++lo;\n\t\t\telse if (sum > target || (hi < nums.length - 1 && nums[hi] == nums[hi + 1]))\n\t\t\t\t--hi;\n\t\t\telse\n\t\t\t\tres.add(Arrays.asList(nums[lo++], nums[hi--]));\n\t\t}\n\t\treturn res;\n\t}\n}\n\n\npublic class Four\\_Sum {\n\n    public static void main(String[] args) {\n        Four\\_Sum out = new Four\\_Sum();\n        Solution s = out.new Solution();\n// SolutionForLoop s= out.new SolutionForLoop();\n\n        List<List<Integer>> result = s.fourSum(new int[]{1, 0, -1, 0, -2, 2}, 0);\n\n        for (List<Integer> each : result) {\n            String one = \"\";\n\n            for (int e : each) {\n                one = one + \" \" + e;\n            }\n\n            System.out.println(one);\n        }\n    }\n\n    // time: O(NlogN)\n    // space: O(1)\n    public class Solution {\n        public List<List<Integer>> fourSum(int[] nums, int target) {\n\n            List<List<Integer>> list = new ArrayList<>();\n\n            if (nums.length < 4) {\n                return list;\n            }\n\n            Arrays.sort(nums);\n\n            // improved based on 3-sum\n            int layer4 = 0;\n            while (layer4 < nums.length) {\n\n                // @note: below is causing me trouble when convert for to while\n                // in while, here \"layer4\" is never updated for case like {0,0,0,0}\n                // if(layer4 > 0 && nums[layer4] == nums[layer4 - 1]) continue;\n                if (layer4 > 0 && nums[layer4] == nums[layer4 - 1]) {\n                    layer4++;\n                }\n\n                // hold one pointer, other two pointer moving\n                int ancher = layer4 + 1;\n                while (ancher < nums.length) {\n\n                    int i = ancher + 1;\n                    int j = nums.length - 1;\n\n                    while (i < j) {\n\n                        int sum = nums[layer4] + nums[ancher] + nums[i] + nums[j];\n\n                        if (sum == target) {\n\n                            // @note: Arrays.asList()\n                            list.add(Arrays.asList(nums[layer4], nums[ancher], nums[i], nums[j]));\n\n                            // @note: dont forget move pointers\n                            i++;\n                            j--;\n\n                            // @note: optimization. above i,j is updated already, compare with previous position\n                            while (i < j && nums[i] == nums[i - 1]) {\n                                i++;\n                            }\n                            while (j > i && nums[j] == nums[j + 1]) {\n                                j--;\n                            }\n\n                        } else if (sum < target) {\n                            i++;\n\n                            // @note: same here, possibly updated already, note i-1 or i+1\n                            while (i < j && nums[i] == nums[i - 1]) {\n                                i++;\n                            }\n\n                        } else {\n                            j--;\n\n                            // @note: same here, possibly updated already, note i-1 or i+1\n                            while (j > i && j + 1 < nums.length && nums[j] == nums[j + 1]) {\n                                j--;\n                            }\n\n                        }\n                    }\n\n                    ancher++;\n\n                    // optimize for 2nd pointer\n                    while (ancher > layer4 && ancher < nums.length && nums[ancher] == nums[ancher - 1]) {\n                        ancher++;\n                    }\n\n                }\n\n                layer4++;\n\n                // optimize for 2nd pointer\n                while (layer4 < nums.length && nums[layer4] == nums[layer4 - 1]) {\n                    layer4++;\n                }\n            }\n\n            return list;\n        }\n    }\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 19,
    "title": "Remove Nth Node From End of List",
    "problem": "\nGiven a linked list, remove the *n*-th node from the end of list and return its head.\n \n\n\n**Example:**\n\n\n\n```\n\nGiven linked list: **1->2->3->4->5**, and ***n* = 2**.\n\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.\n\n```\n\n**Note:**\n\n\nGiven *n* will always be valid.\n\n\n**Follow up:**\n\n\nCould you do this in one pass?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/19.html>\n\n\n\n```\n19\tRemove Nth Node From End of List\n\nGiven a linked list, remove the nth node from the end of list and return its head.\n\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\nGiven n will always be valid.\nTry to do this in one pass.\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nThe problem requires a single traversal to solve the problem, so you have to think of some more clever ways. For example, the first thing to consider is how to find the Nth node from the bottom. Since only one traversal is allowed, a complete traversal cannot be used to count the number of elements in the linked list. Instead, it should be removed after traversing to the corresponding position.\n\n\nSo you need to use two pointers to help solve the problem, pre and cur pointers. First, the cur pointer moves forward by N steps. If cur points to empty at this time, indicating that N is the length of the linked list, the first element that needs to be removed is the first element. Then return head->next at this time. If cur exists, continue to Go down, at this time the pre pointer also follows, until cur is the last element and stop, at this time pre points to the previous element of the element to be removed, and then modify the pointer to skip the element to be removed\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Remove\\_Nth\\_Node\\_From\\_End\\_of\\_List {\n\n\tpublic static void main(String[] args) {\n\n\t}\n\n\t/\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) { val = x; }\n \\* }\n \\*/\n\tpublic class Solution {\n\t    public ListNode removeNthFromEnd(ListNode head, int n) {\n\n\t        ListNode nBehindPrev = new ListNode(0);\n\t        ListNode nBehind = head;\n\t        nBehindPrev.next = nBehind;\n\n\t        ListNode headPrev = nBehindPrev;\n\t        headPrev.next = head;\n\n\t        ListNode current = head;\n\n\t        // nBehind starts moving after n steps of current\n\t        // Given linked list: 1->2->3->4->5, and n = 2.\n\t        int count = 0;\n\t        while (current != null) {\n\t            if (count >= n) {\n\t                nBehindPrev = nBehindPrev.next; // note order\n\t                nBehind = nBehind.next;\n\t            }\n\n\t            current = current.next;\n\t            count++;\n\t        }\n\n\t        // cut\n\t        nBehindPrev.next = nBehind.next;\n\t        nBehind.next = null; // maybe not required, both pointing to nBehind.next\n\n\t        return headPrev.next;\n\t    }\n\t}\n\n\tpublic class Solution\\_2Scan {\n\n\t\t// actually it's scanning twice\n\t    public ListNode removeNthFromEnd\\_refactor(ListNode head, int n) {\n\t        if(head == null) {\n\t            return head;\n\t        }\n\n\t        // move first node to desired position first, avoid flag and count etc.\n\t        int count = 0;\n\t        ListNode current = head;\n\t        while(count < n) {\n\t            count++;\n\t            current = current.next;\n\t        }\n\n\t        ListNode dummy = new ListNode(0);\n\t        dummy.next = head;\n\n\t        ListNode toDelete = head;\n\t        ListNode toDeletePrev = dummy;\n\n\t        while(current != null) {\n\n\t            current = current.next;\n\n\t            toDelete = toDelete.next;\n\t            toDeletePrev = toDeletePrev.next;\n\n\t        }\n\n\t        // remove the one\n\t        toDeletePrev.next = toDelete.next;\n\n\t        // return head;\n\t        return dummy.next;\n\t    }\n\n\n\t    public ListNode removeNthFromEnd(ListNode head, int n) {\n\t        if(head == null) {\n\t            return head;\n\t        }\n\n\t        ListNode dummy = new ListNode(0);\n\t        dummy.next = head;\n\n\t        // @note: key is the initialization. at first I set null,\n\t        // but if null and input only one node, cannot enter while loop and below 2 variables stay null\n\t        ListNode toDelete = head;\n\t        ListNode toDeletePrev = dummy;\n\n\t        boolean flag = false;\n\t        int count = 0;\n\t        ListNode current = dummy;\n\t        while(current != null) {\n\n\t            if(count > n && !flag) {\n\t                flag = true;\n\t                toDelete = head;\n\t                toDeletePrev = dummy;\n\t            }\n\n\t            current = current.next;\n\n\t            if(flag) {\n\t                toDelete = toDelete.next;\n\t                toDeletePrev = toDeletePrev.next;\n\t            }\n\n\t            count++;\n\t        }\n\n\t        // remove the one\n\t        toDeletePrev.next = toDelete.next;\n\n\t        // return head;\n\t        return dummy.next;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 20,
    "title": "Valid Parentheses",
    "problem": "\nGiven a string containing just the characters `'('`,\n `')'`, `'{'`, `'}'`, `'['`\n and `']'`, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\n\nNote that an empty string is also considered valid.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"()\"\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"()[]{}\"\n**Output:** true\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** \"(]\"\n**Output:** false\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:** \"([)]\"\n**Output:** false\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:** \"{[]}\"\n**Output:** true\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/20.html>\n\n\n\n```\n20\tValid Parentheses\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\n\nExample 1:\n\nInput: \"()\"\nOutput: true\n\nExample 2:\n\nInput: \"()[]{}\"\nOutput: true\n\nExample 3:\n\nInput: \"(]\"\nOutput: false\n\nExample 4:\n\nInput: \"([)]\"\nOutput: false\n\nExample 5:\n\nInput: \"{[]}\"\nOutput: true\n\n@tag-stack\n\n```\n\nAlgorithm\n=========\n\n\nHere you need to use a stack to start traversing the input string. If the current character is the left half bracket, it will be pushed onto the stack. If the right half bracket is encountered, if the stack is empty at this time, it will directly return false, such as If it is not empty, remove the top element of the stack, if it is the corresponding left half bracket, continue to loop, otherwise return false.\n\n\n### Pitfalls\n\n\n1. After the final for is over, it depends on whether the stack is empty or not, if it is all “((((((“)\n2. When popping, did not check if the stack is empty\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Stack;\n\npublic class Valid\\_Parentheses {\n\n\tpublic class Solution {\n\n\t    public boolean isValid(String s) {\n\n\t        if (s == null || s.length() == 0)   return false;\n\n\t        Stack<Character> sk = new Stack<>();\n\n\t        for (int i = 0; i < s.length(); i++) {\n\t            char c = s.charAt(i);\n\t            if (c == '(' || c == '{' || c == '[')   sk.push(c);\n\t            else if (c == ')' || c == '}' || c == ']') {\n\n\t                // @note: I missed stack check\n\t                if (sk.isEmpty())   return false;\n\n\t                char pop = sk.pop();\n\t                if (!valid(pop, c))   return false;\n\t            }\n\t            else    return false; // some other chars except parenthesis\n\t        }\n\n\n\t        // @note: i missed sanity check, what if only \"[\"\n\t        return sk.isEmpty() ? true : false;\n\t    }\n\n\t    public boolean valid(char left, char right) {\n\n\t        return (left == '(' && right == ')') || (left == '[' && right == ']') || (left == '{' && right == '}');\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 21,
    "title": "Merge Two Sorted Lists",
    "problem": "\nMerge two sorted linked lists and return it as a new list. The new list should be made by\n splicing together the nodes of the first two lists.\n\n\n**Example:**\n\n```\n\n**Input:** 1->2->4, 1->3->4\n**Output:** 1->1->2->3->4->4\n\n```\n\n\n\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/21.html>\n\n\n21. Merge Two Sorted Lists\n==========================\n\n\nLevel\n-----\n\n\nEasy\n\n\nDescription\n-----------\n\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n\n**Example:**\n\n\n**Input:** 1->2->4, 1->3->4\n\n\n**Output:** 1->1->2->3->4->4\n\n\nSolution\n--------\n\n\nCreate a `dummyHead` that occurs before the real head of the merged list. Use two pointers `temp1` and `temp2` to point to the current numbers in the two lists. Initially `temp1` and `temp2` point to the two lists’ heads respectively. While both `temp1` and `temp2` are in the lists, compare the numbers at `temp1` and `temp2`, add the smaller number to the merged list, and move the corresponding pointer one step ahead. If one pointer reaches the end of the list, which is `null`, then add the numbers of the other pointer to the merged list. Finally, return `dummyHead.next`.\n\n\ntwo pointers\n\n\nbig-o analysis\n\n\n\n```\ncurrent = current.next; // now current is the new end node, but still pointing to next node\n\ncurrent.next = null; // @note: key, cut this node from l1 or l2\n\n```\n\nCode\n====\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Merge\\_Two\\_Sorted\\_Lists {\n\n\t/\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) { val = x; }\n \\* }\n \\*/\n\n\t// Time complexity : O(N)\n\tpublic class Solution {\n\t    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n\t        ListNode dummy = new ListNode(0);\n\t        ListNode current = dummy;\n\n\t        while (l1 != null || l2 != null) {\n\t            int v1 = (l1 == null? Integer.MAX\\_VALUE : l1.val);\n\t            int v2 = (l2 == null? Integer.MAX\\_VALUE : l2.val);\n\n\t            if (v1 < v2) {\n\t                current.next = l1;\n\t                l1 = l1.next;\n\t            } else {\n\t                current.next = l2;\n\t                l2 = l2.next;\n\t            }\n\n\t            current = current.next; // now current is the new end node, but still pointing to next node\n\t            current.next = null; // @note: key, cut this node from l1 or l2\n\t        }\n\n\t        return dummy.next;\n\t    }\n\t}\n\n\tpublic class Solution\\_extraSpace {\n\t    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n\t        ListNode dummy = new ListNode(0);\n\t        ListNode current = dummy;\n\n\t        while (l1 != null || l2 != null) {\n\t            int v1 = l1 == null ? Integer.MAX\\_VALUE : l1.val;\n\t            int v2 = l2 == null ? Integer.MAX\\_VALUE : l2.val;\n\n\t            if (v1 < v2) {\n\t                current.next = new ListNode(v1); // requires extra o(N) space\n\t                l1 = l1.next;\n\t            }\n\t            else {\n\t                current.next = new ListNode(v2);\n\t                l2 = l2.next;\n\t            }\n\n\t            current = current.next;\n\t        }\n\n\t        return dummy.next;\n\t    }\n\t}\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 22,
    "title": "Generate Parentheses",
    "problem": "\n\n Given *n* pairs of parentheses, write a function to generate all combinations of\n well-formed parentheses.\n \n\n\n\n For example, given *n* = 3, a solution set is:\n \n\n\n\n```\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/22.html>\n\n\n\n```\n22\tGenerate Parentheses\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given n = 3, a solution set is:\n\n\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"\n\n@tag-string\n\n```\n\nAlgorithm\n=========\n\n\nThis kind of problem of listing all the results should first consider recursive to solve, because the string has only two characters:\n\n\n* left and right parentheses, and the final result must be 3 left parentheses and 3 right parentheses, \nso two are defined here The variables left and right respectively represent the number of left and right parentheses.\n\n\nIf the number of left parentheses is greater than the number of right parentheses in a certain recursion, it means that the number of right parentheses in the generated string is greater than the number of left parentheses. Number, an illegal string like `)(` will appear, so this case will be returned directly without further processing.\n\n\nIf both left and right are 0, it means that the generated string has 3 left brackets and 3 Right parenthesis, and the string is legal, it will be stored in the result and returned. If the above two conditions are not met, if left is greater than 0 at this time, then call the recursive function, pay attention to the update of the parameters, if right is greater than 0, call recursion Function, also update the parameters.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Generate\\_Parentheses {\n\n    public class Solution {\n        public List<String> generateParenthesis(int n) {\n            List<String> res = new ArrayList<String>();\n            dfs(n, n, \"\", res);\n            return res;\n        }\n\n        void dfs(int left, int right, String out, List<String> res) {\n            if (left < 0 || right < 0 || left > right) return;\n            if (left == 0 && right == 0) {\n                res.add(out);\n                return;\n            }\n            dfs(left - 1, right, out + \"(\", res);\n            dfs(left, right - 1, out + \")\", res);\n        }\n    }\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 23,
    "title": "Merge k Sorted Lists",
    "problem": "\nMerge *k* sorted linked lists and return it as one sorted list. Analyze and describe\n its complexity.\n\n\n**Example:**\n\n\n\n```\n\n**Input:**\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n**Output:** 1->1->2->3->4->4->5->6\n\n```\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/23.html>\n\n\n[23 - Merge k Sorted Lists](https://leetcode.ca/all/23.html)\n============================================================\n\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n\nExample:\n\n\nInput:\n[\n 1->4->5,\n 1->3->4,\n 2->6\n]\n\n\nOutput: 1->1->2->3->4->4->5->6\n\n\n### MergeSort solution\n\n\nThe first thing that comes to mind is the two-by-two merger, that is, the first two are merged first, and then the third is merged, and then the fourth to the kth. This kind of thinking is correct, but it is not efficient and cannot pass OJ, so we can only change the way of thinking. Divide and Conquer Approach are needed here.\n\n\nSimply, it is divided into half and half, for example, k linked lists are first divided into the task of merging two `k/2` linked lists, and then continuously divided down, until they are divided into tasks with only one or two linked lists, and start to merge.\n\n\nFor example, if you merge 6 linked lists, then according to the divide and conquer method, first merge 0 and 3, 1 and 4, and 2 and 5 respectively. So next time you only need to merge 3 linked lists, then merge 1 and 3, and finally merge with 2.\n\n\nThe k in the code is calculated by `(n+1)/2`, why add 1 here?\n\n\n* This is for when n is odd, k can always start from the second half,\n* for example, when n=5, then at this time k=3, then 0 and 3 are merged, 1 and 4 are merged, and the middle 2 is vacant.\n* When n is an even number, adding 1 will not have any effect. For example, when n=4 and k=2, then 0 and 2 are combined, and 1 and 3 are combined, which perfectly solves the problem.\n\n\n##### big-o analysis\n\n\ntime-complex `O(N*logK)`\n\n\n* `N` is the total number of nodes\n* `k` is the number of linked lists.\n\n\n\n```\n      public ListNode merge(ListNode[] lists, int start, int end) {\n\n          int mid = (end - start) / 2 + start;\n          ListNode leftHalf = merge(lists, start, mid);\n          ListNode rightHalf = merge(lists, mid + 1, end);\n\n```\n\n\nReference: <https://leetcode.com/problems/merge-k-sorted-lists/solution/>\n\n\n![i](https://leetcode.com/problems/merge-k-sorted-lists/Figures/23/23_divide_and_conquer_new.png)\n\n\n* We can merge two sorted linked list in `O(n)` time where n is the total number of nodes in two lists.\n* Sum up the merge process and we can get: sum all nodes `logk` times (height of tree) => `O(Nlogk)`\n\n\n\n```\n\npublic class Merge\\_k\\_Sorted\\_Lists {\n\n    public static void main(String[] args) {\n\n        Merge\\_k\\_Sorted\\_Lists out = new Merge\\_k\\_Sorted\\_Lists();\n        Solution s = out.new Solution();\n\n        ListNode l1 = null;\n        ListNode l2 = new ListNode(1);\n\n        s.mergeKLists(new ListNode[]{l1, l2});\n\n    }\n\n    public class Solution {\n        public ListNode mergeKLists(ListNode[] lists) {\n\n            if (lists == null || lists.length == 0) {\n                return null;\n            }\n\n            // same as merge sort array\n            return merge(lists, 0, lists.length - 1);\n        }\n\n        public ListNode merge(ListNode[] lists, int start, int end) {\n\n            // single list\n            if (start == end) {\n                return lists[start];\n            }\n\n            int mid = (end - start) / 2 + start;\n            ListNode leftHalf = merge(lists, start, mid);\n            ListNode rightHalf = merge(lists, mid + 1, end);\n\n            return mergeTwoLists(leftHalf, rightHalf);\n        }\n\n        // from previous question: 21 Merge Two Sorted Lists\n        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n            ListNode dummy = new ListNode(0);\n            ListNode current = dummy;\n\n            while (l1 != null || l2 != null) {\n                int v1 = (l1 == null ? Integer.MAX\\_VALUE : l1.val);\n                int v2 = (l2 == null ? Integer.MAX\\_VALUE : l2.val);\n\n                if (v1 < v2) {\n                    current.next = l1;\n                    l1 = l1.next;\n                } else {\n                    current.next = l2;\n                    l2 = l2.next;\n                }\n\n                current = current.next; // now current is the new end node, but still pointing to next node\n                current.next = null; // @note: key, cut this node from l1 or l2\n            }\n\n            return dummy.next;\n        }\n    }\n\n}\n\n\n\n```\n\n### Heap solution\n\n\nPut the smallest node of each list into a priority queue (min heap).\nEvery time a node is removed from the queue, the node is inserted into the next node in its list,\nAnd so on until all nodes have passed the priority queue.\n\n\nSince the size of the priority queue is always k, and the complexity of each insertion is log k, a total of nk nodes have been inserted.\n\n\nHeap solution: heap.offer(polled.next); Here, the offer() parameter of heap cannot be null, because polled is not null before updating currentNode\n\n\n\n```\n            if (polled.next != null) {\n                heap.offer(polled.next); // @note: offer()参数不能是null\n            }\n\n```\n\nThe time complexity is `O(n * k * logk)`, and the space complexity is `O(k)`.\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\nclass Solution\\_Heap {\n\tpublic ListNode mergeKLists(ListNode[] lists) {\n\n\t\tif (lists == null || lists.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tListNode dummy = new ListNode(0);\n\t\tListNode current = dummy;\n\n\t\t// put 1st of each list to heap\n\t\tPriorityQueue<ListNode> heap = new PriorityQueue<>(\n\t\t\t(a,b) -> a.val - b.val\n\t\t);\n\n\t\t//\n\t\tArrays.stream(lists).filter(Objects::nonNull).forEach(heap::offer);\n\n\t\twhile (heap.size() != 0) {\n\t\t\tListNode polled = heap.poll();\n\n\t\t\tcurrent.next = polled;\n\t\t\tcurrent = current.next;\n\n\t\t\tif (polled.next != null) {\n\t\t\t\theap.offer(polled.next); // @note: heap.offer()参数不能是null\n\t\t\t}\n\t\t}\n\n\t\treturn dummy.next;\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 24,
    "title": "Swap Nodes in Pairs",
    "problem": "\nGiven a linked list, swap every two adjacent nodes and return its head.\n\n\nYou may **not** modify the values in the list's nodes, only nodes itself may\n be changed.\n\n\n \n\n\n**Example:**\n\n\n\n```\n\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/24.html>\n\n\n\n```\n24\tSwap Nodes in Pairs\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n\nFor example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n\n@tag-linkedlist\n */\n\n/*\ncould be extended, swap k sublist\n\neg: k=3, 2->1->4->3->2->1->4->3\n\n2->1->4->3->2->1->4->3  ===>  (2->1->4)->(3->2->1)->4->3  ===>  4->1->2->1->2->3->4->3\n\nmethod: swapKNodes(ListNode head, int k)\n\nthen just extract a method of reversing a sublist, and update to next k nodes\n\n\n```\n\nAlgorithm\n=========\n\n\nCreate a `dummyHead` that occurs before `head`, that is, `dummyHead.next = head`. Each time take the two next nodes, and modify the next elements that each node points to. Suppose the current node is `temp`, and the next two nodes are `node1` and `node2` respectively, that is, `node1 = temp.next` and `node2 = temp.next.next`.\n\n\nIf `node1 == null` or `node2 == null`, then the end of the list is reached, so stop the process. Otherwise, change the nodes as follows. Let `temp.next = node2`, `node1.next = node2.next`, and `node2.next = node1`. After these steps, `node1` and `node2` are swapped. Move `temp` two steps forward (which should point to `node1` after moving two steps), and do swapping for the next nodes. Finally, return `dummyHead.next`.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Swap\\_Nodes\\_in\\_Pairs {\n\n    public static void main(String[] args) {\n\n        Swap\\_Nodes\\_in\\_Pairs out = new Swap\\_Nodes\\_in\\_Pairs();\n        Solution s = out.new Solution();\n    }\n\n    public class Solution {\n        public ListNode swapPairs(ListNode head) {\n// if (head == null) { // this will not pass while loop below\n// return head;\n// }\n\n            ListNode dummy = new ListNode(0);\n            dummy.next = head;\n\n            ListNode prev = dummy;\n\n            // if only one node left, then no swap\n            while (prev.next != null && prev.next.next != null) {\n\n                ListNode first = prev.next;\n                ListNode second = first.next;\n\n                ListNode third = second.next;\n\n                // swap\n                prev.next = second;\n                second.next = first;\n                first.next = third;\n\n                prev = prev.next.next;\n            }\n\n            return dummy.next;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 25,
    "title": "Reverse Nodes in k-Group",
    "problem": "\nGiven a linked list, reverse the nodes of a linked list *k* at a time and return its\n modified list.\n\n\n*k* is a positive integer and is less than or equal to the length of the linked list.\n If the number of nodes is not a multiple of *k* then left-out nodes in the end should\n remain as it is.\n\n\n\n\n**Example:**\n\n\nGiven this linked list: `1->2->3->4->5`\n\n\nFor *k* = 2, you should return: `2->1->4->3->5`\n\n\nFor *k* = 3, you should return: `3->2->1->4->5`\n\n\n**Note:**\n\n\n* Only constant extra memory is allowed.\n* You may not alter the values in the list's nodes, only nodes itself may be\n changed.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/25.html>\n\n\n\n```\n25\tReverse Nodes in k-Group\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nIf the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nYou may not alter the values in the nodes, only nodes itself may be changed.\n\nOnly constant memory is allowed.\n\nFor example,\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n\n\n```\n\nAlgorithm\n=========\n\n\nIn fact, the original linked list is divided into several small segments, and then they are flipped separately. Then there must be a total of two functions, one for segmentation and one for flipping. Take the example given in the title, for Given a linked list 1->2->3->4->5, generally when dealing with linked list problems, most of the time, a dummy node will be added at the beginning, because the head node may change when the linked list is flipped, in order to record the current latest, The dummy node introduced by the position of the head node of the dummy node, the linked list after adding the dummy node becomes -1->1->2->3->4->5. If k is 3, the goal is to change 1,2 ,3 If you flip it, you need some pointers. Pre and next point to the front and back positions of the linked list to be flipped. After flipping, the position of pre is updated to the following new position\n\n\n`prev` is dummy, then `current` is always node ‘1’, ‘1’ will move each iteration of while loop for k-group swap\n\n\n`prev` is static during the full while loop of `while (kcopy > 0)`\n // 1->2->3->4->5 , k=3\n // 2,1,3,4,5\n // 3,2,1,4,5\n // => always getting 1’s next for prev’s next => current (below) not changing in one-batch-swap\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Reverse\\_Nodes\\_in\\_k\\_Group {\n\n    class Solution {\n        public ListNode reverseKGroup(ListNode head, int k) {\n            ListNode dummy = new ListNode(0);\n            dummy.next = head;\n\n            ListNode prev = dummy;\n\n            // count total nodes\n            ListNode tmp = head;\n            int count = 0;\n            while (tmp != null) {\n                count++;\n                tmp = tmp.next;\n            }\n\n            // 1->2->3->4->5 , k=3\n            // 2,1,3,4,5\n            // 3,2,1,4,5\n            // => always getting 1's next for prev's next => current (below) not changing in one-batch-swap\n\n            // if only one node left, then no swap\n            while (count >= k) {\n\n                ListNode originalFirst = prev.next;\n\n                int kcopy = k - 1; // @note: since current node is already counted as 1\n                while (kcopy > 0) { // both prev and current, not changed in while loop\n\n                    ListNode nextNextCopy = originalFirst.next.next;\n                    ListNode firstInGroup = prev.next;\n\n                    prev.next = originalFirst.next;\n                    prev.next.next = firstInGroup;\n                    originalFirst.next = nextNextCopy;\n\n                    kcopy--;\n                }\n\n                // @note: update previous AND current. I forgot current...\n                prev = originalFirst; // now current is the last one of this group\n                count -= k;\n            }\n\n            return dummy.next;\n        }\n    }\n}\n\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 26,
    "title": "Remove Duplicates from Sorted Array",
    "problem": "\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once*\n and return the new length.\n\n\nDo not allocate extra space for another array, you must do this by **modifying the\n input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**\n with O(1) extra memory.\n\n\n**Example 1:**\n\n\n\n```\n\nGiven *nums* = **[1,1,2]**,\n\nYour function should return length = **`2`**, with the first two elements of *`nums`* being **`1`** and **`2`** respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n**Example 2:**\n\n\n\n```\n\nGiven *nums* = **[0,0,1,1,1,2,2,3,3,4]**,\n\nYour function should return length = **`5`**, with the first five elements of *`nums`* being modified to **`0`**, **`1`**, **`2`**, **`3`**, and **`4`** respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n\n```\n\n**Clarification:**\n\n\nConfused why the returned value is an integer but your answer is an array?\n\n\nNote that the input array is passed in by **reference**, which means\n modification to the input array will be known to the caller as well.\n\n\nInternally you can think of this:\n\n\n\n```\n\n// **nums** is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to **nums** in your function would be known by the caller.\n// using the length returned by your function, it prints the first **len** elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/26.html>\n\n\n\n```\nGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nFor example,\nGiven input array nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\nIt doesn't matter what you leave beyond the new length.\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nUse fast and slow pointers to record the traversed coordinates. At the beginning, both pointers point to the first number. If the two pointers point to the same number, the fast pointer will move forward. If they are different, both pointers will move forward. One step, so that when the fast pointer goes through the entire array, the current coordinate of the slow pointer plus 1 is the number of different numbers in the array.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\n// same thing, two pointers\npublic class Remove\\_Duplicates\\_from\\_Sorted\\_Array {\n\n\tpublic class Solution {\n\t    public int removeDuplicates(int[] nums) {\n\t        if(nums == null || nums.length == 0) {\n\t            return 0;\n\t        }\n\n\t        int i = 0; // slow pointer\n\t        int j = 0; // fast pointer\n\n\t        while(j < nums.length) {\n\t            while(j + 1< nums.length && nums[j] == nums[j + 1]) {\n\t                j++;\n\t            }\n\n\t            nums[i] = nums[j];\n\n\t            i++;\n\t            j++;\n\t        }\n\n\t        return i; // i is incremented, but is index. So same as length\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 27,
    "title": "Remove Element",
    "problem": "\nGiven an array *nums* and a value *val*, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.\n\n\nDo not allocate extra space for another array, you must do this by **modifying the\n input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**\n with O(1) extra memory.\n\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new\n length.\n\n\n**Example 1:**\n\n\n\n```\n\nGiven *nums* = **[3,2,2,3]**, *val* = **3**,\n\nYour function should return length = **2**, with the first two elements of *nums* being **2**.\n\nIt doesn't matter what you leave beyond the returned length.\n\n```\n\n**Example 2:**\n\n\n\n```\n\nGiven *nums* = **[0,1,2,2,3,0,4,2]**, *val* = **2**,\n\nYour function should return length = **`5`**, with the first five elements of *`nums`* containing **`0`**, **`1`**, **`3`**, **`0`**, and **4**.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n**Clarification:**\n\n\nConfused why the returned value is an integer but your answer is an array?\n\n\nNote that the input array is passed in by **reference**, which means\n modification to the input array will be known to the caller as well.\n\n\nInternally you can think of this:\n\n\n\n```\n\n// **nums** is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to **nums** in your function would be known by the caller.\n// using the length returned by your function, it prints the first **len** elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/27.html>\n\n\n\n```\nGiven an array and a value, remove all instances of that value in place and return the new length.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nExample 1:\n\nGiven nums = [3,2,2,3], val = 3,\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn't matter what you leave beyond the returned length.\n\nExample 2:\n\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\n\nClarification:\n\n    Confused why the returned value is an integer but your answer is an array?\n\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nA variable is needed for counting, and then the original array is traversed. If the current value is different from the given value, the current value will cover the position of the counting variable, and the counting variable will be incremented by 1.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Remove\\_Element {\n\n    // time: O(N)\n    // space: O(N)\n\tpublic class Solution {\n\t    public int removeElement(int[] nums, int val) {\n\t        if(nums == null || nums.length == 0) {\n\t            return 0;\n\t        }\n\n\t        int i = 0; // slow pointer\n\t        int j = 0; // fast pointer\n\n\t        while(j < nums.length) {\n\t            while(j < nums.length && nums[j] == val) {\n\t                j++;\n\t            }\n\n\t            // protect index j+1\n\t            if(j < nums.length) {\n\t                nums[i] = nums[j];\n\n\t                i++;\n\t                j++;\n\t            }\n\t        }\n\n\t        return i; // i is incremented, but is index. So same as length\n\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 28,
    "title": "Implement strStr()",
    "problem": "\nImplement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n \n\n\nReturn the index of the first occurrence of needle in haystack, or **-1** if\n needle is not part of haystack.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** haystack = \"hello\", needle = \"ll\"\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** haystack = \"aaaaa\", needle = \"bba\"\n**Output:** -1\n\n```\n\n**Clarification:**\n\n\nWhat should we return when `needle` is an empty string? This is a great question\n to ask during an interview.\n\n\nFor the purpose of this problem, we will return 0 when `needle` is an empty\n string. This is consistent to C's [strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)).\n\n\n\n### \n\n",
    "explanation": "Not Populated Yet."
  },
  {
    "id": 29,
    "title": "Divide Two Integers",
    "problem": "\nGiven two integers `dividend` and `divisor`, divide two integers\n without using multiplication, division and mod operator.\n\n\nReturn the quotient after dividing `dividend` by `divisor`.\n\n\nThe integer division should truncate toward zero.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** dividend = 10, divisor = 3\n**Output:** 3\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** dividend = 7, divisor = -3\n**Output:** -2\n```\n\n**Note:**\n\n\n* Both dividend and divisor will be 32-bit signed integers.\n* The divisor will never be 0.\n* Assume we are dealing with an environment which could only store integers within the\n 32-bit signed integer range: [−231,  231 − 1].\n For the purpose of this problem, assume that your function returns 231\n − 1 when the division result overflows.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/29.html>\n\n\n\n```\n29\tDivide Two Integers\n\nDivide two integers without using multiplication, division and mod operator.\n\nIf it is overflow, return MAX_INT.\n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\n\nNote:\n    Both dividend and divisor will be 32-bit signed integers.\n    The divisor will never be 0.\n    Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.\n\n@tag-math\n\n```\n\nAlgorithm\n=========\n\n\nYou can use another artifact bit to operate Bit Manipulation. The idea is that if the dividend is greater than or equal to the divisor, the following loop is performed, defining the variable t to be equal to the divisor, and defining the count p. When twice t is less than or equal to the dividend, the following loop is performed, t Double the expansion, double the expansion of p, and then update res and m.\n\n\nSome test cases given by the OJ of this question are very annoying, because the input is all int type, for example, the dividend is -2147483648, in the range of int, when the divisor is -1, the result exceeds the range of int, and INT\\_MAX needs to be returned.\n\n\nSo for this case, start with if judgment, and judge it together with the case where the divisor is 0, and return INT\\_MAX. Then the positive and negative of the return value must be determined according to the positive and negative of the dividend and the divisor. Here, the long integer type is used to complete all calculations, and the return value is multiplied by the sign.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\n/\\*\n \\* converting int to larger size type like long, or BigInteger.\n \\* since overflow on -2147483648 must be handled\n \\*/\npublic class Divide\\_Two\\_Integers {\n\n\tpublic static void main(String[] args) {\n\t\tDivide\\_Two\\_Integers out = new Divide\\_Two\\_Integers();\n\t\tSolution\\_recursion s = out.new Solution\\_recursion();\n\n\n\t\tSystem.out.println(s.divide(101, 10));\n\t\tSystem.out.println(s.divide(-2147483648, 2));\n\t}\n\n\n    // @note: give up on bit operation, biggest issue is, bit and negative int are hard to handle\n    public class Solution\\_bit\\_on\\_int {\n        public int divide(int n, int dsor) {\n            if(dsor == 0 || (n == Integer.MIN\\_VALUE && dsor == -1)) {\n                return Integer.MAX\\_VALUE;\n            }\n\n            // save operations\n            if(dsor == 1) {\n                return n;\n            }\n            if(dsor == -1) {\n                return n \\* -1;\n            }\n\n            int flag = 1;\n            if(n < 0) {\n                flag \\*= -1;\n                n \\*= -1; // @note: overflow... -2147483648/2\n            }\n            if(dsor < 0) {\n                flag \\*= -1;\n                dsor \\*= -1;\n            }\n\n            int count = 0;\n            // while(n > 0) {\n            // n -= dsor;\n            // count++;\n            // }\n\n            // moving faster than above while\n            while(n > 0 && n >= dsor) { // while(n > 0) { @note: I missed case: 1/2\n                int shift = 0; // bit shift\n\n\t            /\\* @note: below bit operation causes issue.\n 2147483647/1\n last loop, shift=31, dsor=1\n should not enter below while, but when divisor is 1 or 2 or 4, etc:\n\n 1<<31=(-2147483648)\n 2<<30=(-2147483648)\n 4<<29=(-2147483648)\n\n so, originally I was using \"(dsor << shift)\" as probe to see if over divident\n then I change it to be an int, and add extra overflow check\n \\*/\n\n                // while((dsor << shift) <= n) {\n                while((dsor << shift) <= n) { //@note: <n is non-stop loop, should be <=n. eg. 1/1\n                    n -= dsor << shift;\n                    count += 1 << shift;\n\n                    // check bit overflow\n                    if((Integer.MAX\\_VALUE >> 1) <= (dsor << shift)) {\n                        break;\n                    }\n\n                    shift++;\n                }\n            }\n\n            return count \\* flag;\n        }\n    }\n\n\n    public class Solution\\_recursion {\n\n\t\tint result = 0;\n\t\t/\\*\n \\* my way of acceleration, increase step size each iteration,\n \\*\n \\* eg:\n \\*\n \\* 101 / 10:\n \\* 101 - 10\\*1 = 91\n \\* 91 - 10\\*2 = 71\n \\* 71 - 10\\*4 = 31\n \\*\n \\* now 31 is less then 10\\*8, count=1+2+4=7 ok, send to next recursion\n \\*\n \\* 31 / 10: and repeat above acceleration, start again from step=1\n \\* 31 - 10\\*1 = 21\n \\* 21 - 10\\*2 = 1\n \\*\n \\* now 1 is less than 10\\*4, this recurion count=1+2=3\n \\*\n \\* add up all count=7+3=10\n \\*/\n\t    public int divide(int dividend, int divisor) {\n\n\t        // convert to long\n\t        long n = (long)dividend;\n\t        long dsor = (long)divisor;\n\n\t        if(dsor == 0 || (n == Integer.MIN\\_VALUE && dsor == -1)) {\n\t            return Integer.MAX\\_VALUE;\n\t        }\n\n\t        // save operations\n\t        if(dsor == 1) {\n\t            return (int)n;\n\t        }\n\t        if(dsor == -1) {\n\t            return (int)(n \\* -1);\n\t        }\n\n\t        int flag = 1;\n\t        if(n < 0) {\n\t            flag \\*= -1;\n\t            n \\*= -1; // @note: overflow... -2147483648\n\t        }\n\t        if(dsor < 0) {\n\t            flag \\*= -1;\n\t            dsor \\*= -1;\n\t        }\n\n\t        dfs(n, dsor);\n\n\t        return flag \\* result;\n\t    }\n\n\t    public void dfs(long n, long dsor) {\n\n// if(n <= 0) {\n\t    \tif(n < dsor) { // @note: missed here, end condition is not n\n\t    \t\treturn;\n\t    \t}\n\n\t    \tint step = 1;\n\n\t    \twhile (n >= (dsor \\* step)) { // @Note: should be >= , eg: 2/2 = 1\n\n\t    \t\tn -= (dsor \\* step);\n\n\t    \t\tresult += step;\n\n\t    \t\tstep \\*= 2; // acceleration of step size\n\t    \t}\n\n\t    \t// now start again with no acceleration dsor\n\t    \tdfs(n, dsor);\n\t    }\n\t}\n\n\t// @note: just convert to long, and solution AC. But code is ugly...\n\tpublic class Solution {\n\t    public int divide(int nn, int ddsor) {\n\n\t        // convert to long\n\t        long n = (long)nn;\n\t        long dsor = (long)ddsor;\n\n\t        if(dsor == 0 || (n == Integer.MIN\\_VALUE && dsor == -1)) {\n\t            return Integer.MAX\\_VALUE;\n\t        }\n\n\t        // save operations\n\t        if(dsor == 1) {\n\t            return (int)n;\n\t        }\n\t        if(dsor == -1) {\n\t            return (int)(n \\* -1);\n\t        }\n\n\t        int flag = 1;\n\t        if(n < 0) {\n\t            flag \\*= -1;\n\t            n \\*= -1; // @note: overflow... -2147483648\n\t        }\n\t        if(dsor < 0) {\n\t            flag \\*= -1;\n\t            dsor \\*= -1;\n\t        }\n\n\t        int count = 0;\n\t        // while(n > 0) {\n\t        // n -= dsor;\n\t        // count++;\n\t        // }\n\n\t        // moving faster than above while\n\t        while(n > 0 && n >= dsor) { // while(n > 0) { @note: I missed case: 1/2\n\t            int shift = 0; // bit shift\n\n\t            /\\* @note: below bit operation causes issue.\n 2147483647/1\n last loop, shift=31, dsor=1\n should not enter below while, but when divisor is 1 or 2 or 4, etc:\n\n 1<<31=(-2147483648)\n 2<<30=(-2147483648)\n 4<<29=(-2147483648)\n\n so, originally I was using \"(dsor << shift)\" as probe to see if over divident\n then I change it to be an int, and add extra overflow check\n \\*/\n\n\t            // while((dsor << shift) <= n) {\n\t            while((dsor << shift) <= n) { //@note: <n is non-stop loop, should be <=n. eg. 1/1\n\t                n -= dsor << shift;\n\t                count += 1 << shift;\n\n\t                // check bit overflow\n\t                if((Integer.MAX\\_VALUE >> 1) <= (dsor << shift)) {\n\t                    break;\n\t                }\n\n\t                shift++;\n\t            }\n\t        }\n\n\t        long result = count \\* flag;\n\t        if(result > Integer.MAX\\_VALUE) {\n\t            return Integer.MAX\\_VALUE;\n\t        } else if(result < Integer.MIN\\_VALUE) {\n\t            return Integer.MIN\\_VALUE;\n\t        } else {\n\t            return (int)result;\n\t        }\n\n\t    }\n\t}\n\n\n\tpublic class Solution\\_over\\_time\\_limit {\n\t    public int divide(int n, int dsor) {\n\t        if(dsor == 0 || (n == Integer.MIN\\_VALUE && dsor == -1)) {\n\t            return Integer.MAX\\_VALUE;\n\t        }\n\n\t        int flag = 1;\n\t        if(n < 0) {\n\t            flag \\*= -1;\n\t            n \\*= -1;\n\t        }\n\t        if(dsor < 0) {\n\t            flag \\*= -1;\n\t            dsor \\*= -1;\n\t        }\n\n\t        int count = 0;\n\t        while(n > 0) {\n\t            n -= dsor;\n\t            count++;\n\t        }\n\n\t        return count \\* flag;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 30,
    "title": "Substring with Concatenation of All\n                Words",
    "problem": "\nYou are given a string, **s**, and a list of words, **words**, that\n are all of the same length. Find all starting indices of substring(s) in **s**\n that is a concatenation of each word in **words** exactly once and without any\n intervening characters.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:\n s =** \"barfoothefoobarman\",\n **words =** [\"foo\",\"bar\"]\n**Output:** [0,9]\n**Explanation:** Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:\n s =** \"wordgoodgoodgoodbestword\",\n **words =** [\"word\",\"good\",\"best\",\"word\"]\n**Output:** []\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/30.html>\n\n\n\n```\n30. Substring with Concatenation of All Words\n\nYou are given a string, s, and a list of words, words, that are all of the same length.\n\nFind all starting indices of substring(s) in s that is a concatenation of each word in words exactly once\nand without any intervening characters.\n\nFor example, given:\ns: \"barfoothefoobarman\"\nwords: [\"foo\", \"bar\"]\n\nYou should return the indices: [0,9].\n(order does not matter).\n\n@tag-string\n\n```\n\nAlgorithm\n=========\n\n\nIt is necessary to frequently judge whether the substring of length len in the s string is a word in words. For quick judgment, you can use HashMap. At the same time, because the words array may have repeated words, you must use HashMap to create all words and their appearance times The mapping between, that is, count the number of times each word appears.\n\n\nTraverse all the substrings of length nxlen in s. When the length of the remaining substrings is less than nxlen, there is no need to judge. So i starts from 0 and ends at (int)s.size()-nxlen. Note that you must first convert s.size() to an integer before performing the solution. Be sure to form such a habit. Once size() is to be subtracted from a number, first switch to int type, because the return value of size() is unsigned.\n\n\nOnce you subtract a number larger than yourself, an error will occur. For each traversed substring of length `nxlen`, it is necessary to verify whether it is exactly composed of all words in words. The checking method is to take the substring of length len each time to see if it is a word in words. To facilitate comparison, create another HashMap.\n\n\nWhen the extracted word is not in words, break it directly, otherwise, add 1 to its mapping value in the new HashMap, and check if its mapping value exceeds the mapping value in the original HashMap, Also break off, because even if the current word is in words, if it appears more than the number of times in words, it is still unsatisfactory. Outside the for loop, if j is exactly equal to n, it means that the detected n substrings of length len are all words in words, and just form words, then the current position i is added to the result.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Substring\\_with\\_Concatenation\\_of\\_All\\_Words {\n\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Boolean> hm = new HashMap<String, Boolean>();\n\t\thm.put(\"a\", true);\n\n\t\t// @note: ugly type convert...\n\t\tHashMap<String, Boolean> copy = (HashMap<String, Boolean>) hm.clone();\n\t\tcopy.put(\"a\", false);\n\n\t\tSystem.out.println(hm.entrySet());\n\t\tSystem.out.println(copy.entrySet());\n\t}\n\n\tpublic class Solution {\n\n\t    List<Integer> list = new ArrayList<Integer>();\n\n        // pre-process a hashmap storing all short words, for quick look up\n\t    HashMap<String, Integer> hm = new HashMap<String, Integer>(); // L words to count\n\n\t    public List<Integer> findSubstring(String s, String[] words) {\n\n\t        if (s.length() == 0 || s == null || words.length == 0 || words == null || s.length() < words.length \\* words[0].length())\n\t            return list;\n\n\t        int eachlen = words[0].length();\n\t        int totalLength = words.length \\* words[0].length();\n\n\t        // pre-process hashmap\n\t        for (String e: words) {\n\t            if (hm.containsKey(e)) {\n\t                hm.put(e, hm.get(e) + 1);\n\t            } else {\n\t                hm.put(e, 1);\n\t            }\n\t        }\n\n\t        // go through s to find match\n\t        for (int i = 0; i <= s.length() - totalLength; i++) {\n\n\t            String sub = s.substring(i, i + totalLength);\n\t            if (isValid(sub, eachlen))\n\t                list.add(i);\n\n\t        }\n\n\t        return list;\n\t    }\n\n\n\t    public boolean isValid(String s, int eachlen) {\n\t        HashMap<String, Integer> hmcopy = new HashMap<String, Integer>(hm);\n\n\t        // increment i by eachlen\n\t        for (int i = 0; i <= s.length() - eachlen; i = i + eachlen) {\n\n\t            String current = s.substring(i, i + eachlen);\n\n\t            // if its count==0 then false, eg:foofoo\n\t            if (hmcopy.containsKey(current) && hmcopy.get(current) > 0) {\n\t                // if hm has it, then decrease its count\n\t                hmcopy.put(current, hmcopy.get(current) - 1);\n\t            } else {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 31,
    "title": "Next Permutation",
    "problem": "\nImplement **next permutation**, which rearranges numbers into the\n lexicographically next greater permutation of numbers.\n\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie,\n sorted in ascending order).\n\n\nThe replacement must be **[in-place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only\n constant extra memory.\n\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are\n in the right-hand column.\n\n\n`1,2,3` → `1,3,2`  \n\n`3,2,1` → `1,2,3`  \n\n`1,1,5` → `1,5,1`\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/31.html>\n\n\n\n```\n31\tNext Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place, do not allocate extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n    1,2,3 → 1,3,2\n    3,2,1 → 1,2,3\n    1,1,5 → 1,5,1\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nThis question lets us find the next sort order. As can be seen from the example given in the question, if the given array is in descending order, it means that it is the last case of the full order, and the next order is the initial case. You can see The previous blog Permutations. Look at the following example again, there is an array as follows\n\n\n`1　　2　　7　　4　　3　　1`\n\n\nThe next arrangement is:\n\n\n`1　　3　　1　　2　　4　　7`\n\n\nSo how did we get it? By observing the original array, we can find that if we look forward from the end, the number gradually increases, and then decreases at 2, and then we look for the first number greater than 2 from the back, which is 3, then we exchange 2 and 3, and then transpose all the numbers after 3 at this time, the steps are as follows:\n\n\n\n```\n1　　2　　7　　4　　3　　1\n\n1　　2　　7　　4　　3　　1\n\n1　　3　　7　　4　　2　　1\n\n1　　3　　1　　2　　4　　7\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\n\npublic class Next\\_Permutation {\n\n    // time: O(N^2)\n    // space: O(1)\n    public class Solution {\n\n        public void nextPermutation(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return;\n            }\n\n            // 总体目标是，高位的小数字，换低位的大数字，才能得到next\n            for (int i = nums.length - 2; i >= 0; --i) { // 3, 4, 5, 2, 1 // 注意. i < Len - 1. 也就是停在倒数第二个\n                if (nums[i] < nums[i + 1]) { // 第一个波峰波谷 => 4\n                    for (int j = nums.length - 1; j > i; --j) {\n                        if (nums[j] > nums[i]) {\n                            // 找到第一个比nums-i大的数 => 5\n                            swap(nums, i, j); // 3,5,4,2,1\n\n                            // reverse 因为剩下部分肯定是从大到小\n                            // 找到第一个比nums-i大的数的一步，相当于是排序，找insert position\n                            reverse(nums, i + 1, nums.length - 1); // [4,2,1] reverse to [1,2,4] => 3, 5, 1, 2, 4\n                            return;\n                        }\n                    }\n\n                }\n            }\n\n            reverse(nums, 0, nums.length - 1); // for没有return，就整个翻转\n        }\n\n        private void swap(int[] nums, int i, int j) {\n\n            int tmp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = tmp;\n\n        }\n\n        private void reverse(int[] nums, int i, int j) {\n\n            while (i < j) {\n\n                int tmp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = tmp;\n\n                i++;\n                j--;\n            }\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 32,
    "title": "Longest Valid Parentheses",
    "problem": "\nGiven a string containing just the characters `'('` and\n `')'`, find the length of the longest valid (well-formed) parentheses\n substring.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"(()\"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is \"()\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \")()())\"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is \"()()\"\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/32.html>\n\n\n\n```\n32\tLongest Valid Parentheses\n\nGiven a string containing just the characters '(' and ')',\nfind the length of the longest valid (well-formed) parentheses substring.\n\nExample 1:\n\nInput: \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\"\n\nExample 2:\n\nInput: \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\"\n\n@tag-stack\n\n```\n\nAlgorithm\n=========\n\n\nTo solve with the help of the stack, you need to define a `start` variable to record the starting position of the valid bracket string.\n\n\nTraverse the string,\n\n\n* if it encounters a left bracket, push the current index onto the stack,\n* if it encounters a right bracket,\n\t+ if the current stack is empty, the next index position is recorded to be `start`,\n\t+ if the stack is not empty, the top element of the stack is taken out, at this time,\n\t\t- if the stack is empty, update the result and the larger value of i-start + 1,\n\t\t- otherwise update the result and i-the greater value in st.top()\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Longest\\_Valid\\_Parentheses {\n\n    class Solution\\_noExtraSpace {\n        public int longestValidParentheses(String s) {\n            int res = 0, left = 0, right = 0, n = s.length();\n\n            // from left to right, '(()' => will never hit left==right\n            for (int i = 0; i < n; ++i) {\n                if (s.charAt(i) == '(') ++left;\n                else ++right;\n\n                if (left == right) res = Math.max(res, 2 \\* right);\n                else if (right > left) left = right = 0;\n            }\n\n            // from right to left, '())' => will never hit left==right\n            left = right = 0;\n            for (int i = n - 1; i >= 0; --i) {\n                if (s.charAt(i) == '(') ++left;\n                else ++right;\n\n                if (left == right) res = Math.max(res, 2 \\* left);\n                else if (left > right) left = right = 0;\n            }\n            return res;\n\n        }\n    }\n\n    class Solution\\_stack {\n        public int longestValidParentheses(String s) {\n            Stack<Integer> sk = new Stack<>();\n            int start = 0;\n            int result = 0;\n            for (int i = 0;i < s.length(); i++) {\n                if(s.charAt(i) == '(') {\n                    sk.push(i);\n                } else {\n                    if (sk.empty()) {\n                        start = i + 1;\n                    } else {\n                        sk.pop();\n                        result = Math.max(result, sk.isEmpty() ? i - start + 1 : i - sk.peek());\n                    }\n                }\n            }\n            return result;\n\n        }\n    }\n\n    // @note: scan direction: right pointer from start to end, left pointer from right pointer to start\n    public class Solution\\_start\\_to\\_end {\n\n        public int longestValidParentheses(String s) {\n\n            if (s == null || s.length() == 0) {\n                return 0;\n            }\n\n            int longest = 0;\n            int j = 1;\n\n            // this map will mark, from index=0 to position x, longest so far\n            // 注意，这里是保证 s[i][j]是连续的valid，所以才可以用 \"i = j - skipLeft - 1;\"来找左边的 '('\n            int[] longestSoFar = new int[s.length()];\n\n            while(j < s.length()) {\n\n                int skipLeft = longestSoFar[j - 1];\n                int i = j - skipLeft - 1; // to find left \"(\"\n\n                // @note: I missed boundary check for i\n                // if (s.charAt(i) == '(' && s.charAt(j) == ')') {\n                if (i >= 0 && s.charAt(i) == '(' && s.charAt(j) == ')') {\n\n                    longestSoFar[j] = j - i + 1; // @note: or, longestSoFar[j - 1] += 2;\n                    // System.out.println(i + \" \" + j);\n\n                    // probe previous valid segement\n                    if (i - 1 >= 0 && longestSoFar[i - 1] > 0) {\n                        longestSoFar[j] += longestSoFar[i - 1];\n                    }\n\n                    longest = Math.max(longest, longestSoFar[j]);\n                }\n\n                j++;\n            }\n\n            return longest;\n        }\n    }\n\n\n    // @note: scan direction: left pointer from end to start, right pointer from left pointer to end\n    public class Solution\\_end\\_to\\_start {\n        public int longestValidParentheses(String s) {\n\n            if (s == null || s.length() == 0)   return 0;\n\n            // 注意，这里是保证 s[i][j]是连续的valid，所以才可以用 \"j = i + skip + 1;\"来找右边的 '('\n            int[] dp = new int[s.length()];\n            int max = 0;\n\n            // scan from end to start\n            for (int i = s.length() - 2; i >= 0; i--) {\n\n                // check how many to skip\n                int skip = dp[i + 1];\n                int j = i + skip + 1;\n\n                // @note: i missed boundray check for j\n                if (j > s.length() - 1) {\n                    continue;\n                }\n\n                if (s.charAt(i) == '(' && s.charAt(j) == ')') {\n                    dp[i] = dp[i + 1] + 2;\n\n                    // check position after j, eg: ))((()))()()((\n                    if (j + 1 < s.length() && dp[j + 1] > 0)\n                        dp[i] += dp[j + 1];\n\n                    max = max > dp[i] ? max : dp[i];\n                }\n            }\n\n            return max;\n        }\n    }\n\n\n    // @note: 2-d dp array, over time\n    public int longestValidParentheses(String s) {\n\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n\n        int longest = Integer.MIN\\_VALUE;\n        int j = 0;\n\n        // marking, from i to j is valid parenthesis\n        boolean[][] dp = new boolean[s.length()][s.length()];\n\n        // @note: eg. \")()())\", need another map to record previous longest valid\n        // this map will mark, at position x, longest so far\n        int[] longestSoFar = new int[s.length()];\n\n        while(j < s.length()) {\n\n            int i = 0;\n            while(i <= j) {\n\n                // check if valid\n                if ((s.charAt(i) == '(' && s.charAt(j) == ')') && (j - i <= 1 || dp[i + 1][j - 1])) {\n\n                    dp[i][j] = true;\n                    // System.out.println(i + \" \" + j);\n\n                    // probe previous valid segement\n                    int prev = i > 0 ? longestSoFar[i - 1] : 0;\n\n                    // check longest\n                    longest = Math.max(longest, j - i + 1 + prev);\n\n                    // @note: record longest so far\n                    longestSoFar[j] = longest;\n                }\n\n                i++;\n            }\n\n            j++;\n        }\n\n        return longest;\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 33,
    "title": "Search in Rotated Sorted Array\n",
    "problem": "\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you\n beforehand.\n\n\n(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).\n\n\nYou are given a target value to search. If found in the array return its index, otherwise\n return `-1`.\n\n\nYou may assume no duplicate exists in the array.\n\n\nYour algorithm's runtime complexity must be in the order of *O*(log *n*).\n \n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [4,5,6,7,0,1,2], target = 0\n**Output:** 4\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [4,5,6,7,0,1,2], target = 3\n**Output:** -1\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/33.html>\n\n\n33. Search in Rotated Sorted Array\n==================================\n\n\nLevel\n-----\n\n\nMedium\n\n\nDescription\n-----------\n\n\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n\n(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).\n\n\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\n\n\nYou may assume no duplicate exists in the array.\n\n\nYour algorithm’s runtime complexity must be in the order of O(log *n*).\n\n\n**Example 1:**\n\n\n**Input:** nums = [4,5,6,7,0,1,2], target = 0\n\n\n**Output:** 4\n\n\n**Example 2:**\n\n\n**Input:** nums = [4,5,6,7,0,1,2], target = 3\n\n\n**Output:** -1\n\n\nSolution\n--------\n\n\nTo solve the problem in O(log *n*) runtime complexity, use binary search. Since the sorted array is rotated at some pivot, the logic is a little different from traditional binary search.\n\n\nUse two pointers `low` and `high`, which initially point to the begin and the end of the array respectively. The loop condition is `low <= high`. Each time choose `mid` as the average of `low` and `high`. If `nums[mid] == target`, then return `mid`. Otherwise, decide which half should be searched next, `[low, mid - 1]` or `[mid + 1, high]`. Two cases may exist. The first case is that `nums[low] <= nums[mid]`, which means the rotation point is on the right of `mid`. Search in `[low, mid - 1]` if `target` is between `nums[low]` and `nums[mid]`, and otherwise search in `[mid + 1, high]`. The first case is that `nums[low] > nums[mid]`, which means the rotation pointer is on the left of `mid`. Search in `[mid + 1, high]` if `target` is between `nums[mid]` and `nums[high]`, and otherwise search in `[low, mid - 1]`. If `target` is not found, return `-1`.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Search\\_in\\_Rotated\\_Sorted\\_Array {\n\n    // time: O(1)\n    // space: O(N)\n    public class Solution {\n\n        public int search(int[] nums, int target) {\n\n            if (nums == null || nums.length == 0) {\n                return -1;\n            }\n\n            int i = 0; // left pointer\n            int j = nums.length - 1; // right pointer\n\n            while (i <= j) {\n                int mid = (i + j) / 2; // @note: possible overflow, use: int mid = i + (j - i) / 2\n\n                if (nums[mid] == target) {\n                    return mid;\n                }\n\n\t\t        /\\*\n @note: I missed case when nums[mid] is the max of the values, then both mid-left-half and mid-right-half are ordered:\n array=[3,5,1], target=1\n array=[3,5,1], target=3\n \n array=[4,5,6, 7, 1,2,3]\n \n @note: question is, how to deal with case where mid-value is max-value?\n initially I was thinking compare mid with mid-1 value and mid+1 value, but tedious\n simple solution is, add another condition to make a range query:\n nums[i] < target and target < nums[mid]\n \\*/\n\n                // @note: if (nums[0] <= nums[mid]) {\n                if (nums[i] <= nums[mid]) { // left half ordered, right half not ordered\n\n                    // if (target <= nums[mid]) {\n                    if (nums[i] <= target && target <= nums[mid]) {\n                        j = mid - 1;\n                    } else {\n                        // i++; //[NOT binary]\n                        i = mid + 1;\n                    }\n                } else { // right half ordered, left half not ordered\n\n                    // if (target <= nums[mid]) {\n                    if (nums[mid] <= target && target <= nums[j]) {\n                        i = mid + 1;\n                    } else {\n                        // j--; //[NOT binary]\n                        j = mid - 1;\n                    }\n                }\n            }\n\n            return -1;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 34,
    "title": "Find First and Last Position of\n                Element in Sorted Array",
    "problem": "\nGiven an array of integers `nums` sorted in ascending order, find the starting and\n ending position of a given `target` value.\n\n\nYour algorithm's runtime complexity must be in the order of *O*(log *n*).\n \n\n\nIf the target is not found in the array, return `[-1, -1]`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [5,7,7,8,8,10], target = 8\n**Output:** [3,4]\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [5,7,7,8,8,10], target = 6\n**Output:** [-1,-1]\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/34.html>\n\n\n34. Find First and Last Position of Element in Sorted Array\n===========================================================\n\n\nLevel\n-----\n\n\nMedium\n\n\nDescription\n-----------\n\n\nGiven an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.\n\n\nYour algorithm’s runtime complexity must be in the order of O(log *n*).\n\n\nIf the target is not found in the array, return `[-1, -1]`.\n\n\n**Example 1:**\n\n\n**Input:** nums = [5,7,7,8,8,10], target = 8\n\n\n**Output:** [3,4]\n\n\n**Example 2:**\n\n\n**Input:** nums = [5,7,7,8,8,10], target = 6\n\n\n**Output:** [-1,-1]\n\n\nSolution\n--------\n\n\nSince the runtime complexity is restricted to be in the order of O(log *n*), and the array is sorted, binary search is an ideal solution.\n\n\nDo binary search two rounds. The first round finds whether the given `target` is in the array `nums`, and if `target` exists, get the index of `target` (if there are duplicates, find any index that has the number `target`).\n\n\nIf the given `target` is not in the array, return `[-1, -1]`.\n\n\nIf the given `target` is in the array, do binary search for the second round. Do binary search at both sides of the index found in the first round, and find the leftmost index and the rightmost index of `target`. In the second round, the loop condition of binary search is that the left pointer is less than the right poiner and the equal case is not included in the loop condition, which is a little different from traditional binary search.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Find\\_First\\_and\\_Last\\_Position\\_of\\_Element\\_in\\_Sorted\\_Array {\n\n    class Solution {\n\n        public int[] searchRange(int[] nums, int target) {\n            int[] targetRange = {-1, -1};\n\n            int leftIdx = extremeInsertionIndex(nums, target, true);\n\n            // assert that `leftIdx` is within the array bounds and that `target`\n            // is actually in `nums`.\n            if (leftIdx == nums.length || nums[leftIdx] != target) {\n                return targetRange;\n            }\n\n            targetRange[0] = leftIdx;\n            targetRange[1] = extremeInsertionIndex(nums, target, false) - 1; // @note: -1 to get right most index\n\n            return targetRange;\n        }\n\n        // returns leftmost (or rightmost) index at which `target` should be\n        // inserted in sorted array `nums` via binary search.\n        private int extremeInsertionIndex(int[] nums, int target, boolean isLeft) {\n            int lo = 0;\n            int hi = nums.length;\n\n            while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                if (nums[mid] > target || (isLeft && target == nums[mid])) {\n                    hi = mid;\n                }\n                else {\n                    lo = mid+1;\n                }\n            }\n\n            return lo;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 35,
    "title": "Search Insert Position",
    "problem": "\nGiven a sorted array and a target value, return the index if the target is found. If not,\n return the index where it would be if it were inserted in order.\n\n\nYou may assume no duplicates in the array.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [1,3,5,6], 5\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [1,3,5,6], 2\n**Output:** 1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** [1,3,5,6], 7\n**Output:** 4\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:** [1,3,5,6], 0\n**Output:** 0\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/35.html>\n\n\n\n```\nGiven a sorted array and a target value, return the index if the target is found.\nIf not, return the index where it would be if it were inserted in order.\n\nYou may assume no duplicates in the array.\n\nHere are few examples.\n[1,3,5,6], 5 → 2\n[1,3,5,6], 2 → 1\n[1,3,5,6], 7 → 4\n[1,3,5,6], 0 → 0\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nBinary search.\n\n\n### Notes\n\n\nThe difference between » and »>,\n\n\n* `>>>` appending 0 on the left\n* `>>` no 0 on the left\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\n\npublic class Search\\_Insert\\_Position {\n\n\n\tpublic static void main (String[] args) {\n\t\tSearch\\_Insert\\_Position out = new Search\\_Insert\\_Position();\n\t\tSolution s = out.new Solution();\n\t\tSystem.out.println(s.searchInsert(new int[]{1}, 0));\n\n\n\n\t\tSystem.out.println(\"(3 + 2)>>1: \" + ((3 + 2)>>1));\n\t\tSystem.out.println(\"(3 + 2)>>>1: \" + ((3 + 2)>>>1));\n\t}\n\n\tpublic class Solution {\n\t    public int searchInsert(int[] nums, int target) {\n\t        if(nums == null || nums.length == 0) {\n\t            return 0;\n\t        }\n\n\t        int i = 0;\n\t        int j = nums.length - 1;\n\n\t        while(i <= j) {\n\n\t            int mid = i + (j - i) / 2;\n\n\t            if(nums[mid] == target) { // if found\n\t                return mid;\n\t            // } else if(mid - 1 >= 0 && mid + 1 < nums.length && nums[mid - 1] < target && target < nums[mid]) { // if not found\n\t            // return mid;\n\t            // } else if(i == 0 && target < nums[i]) { // corner case\n\t            // return i;\n\t            } else if(nums[mid] < target) {\n\t                i = mid + 1;\n\t            } else {\n\t                j = mid - 1;\n\t            }\n\t        }\n\n\t        return i; // @note: accepted\n\t        // return i + 1; // @note: wrong\n\t        // return j + 1; // @note: accepted\n\t    }\n\t}\n\n\t// lazy\n\tpublic class Solution222 {\n\t    public int searchInsert(int[] A, int target) {\n\n\t        if (A == null || A.length == 0) return 0;\n\n\t        /\\*\n \\* @note: Returns:\n \\* index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1)\n \\*/\n\t        int ind = Arrays.binarySearch(A, target);\n\n\t        if (ind >= 0)   return ind;\n\n\t        else return (ind + 1) \\* (-1);\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 36,
    "title": "Valid Sudoku",
    "problem": "\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be\n validated **according to the following rules**:\n\n\n1. Each row must contain the digits `1-9` without repetition.\n2. Each column must contain the digits `1-9` without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits `1-9` without\n repetition.\n\n\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)  \n\nA partially filled sudoku which is valid.\n\n\n\nThe Sudoku board could be partially filled, where empty cells are filled with the character\n `'.'`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\n[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n**Output:** false\n**Explanation:** Same as Example 1, except with the **5** in the top left corner being\n    modified to **8**. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n```\n\n**Note:**\n\n\n* A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n* Only the filled cells need to be validated according to the mentioned rules.\n* The given board contain only digits `1-9` and the character `'.'`.\n* The given board size is always `9x9`.\n\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/36.html>\n\n\n36. Valid Sudoku\n================\n\n\nLevel\n-----\n\n\nMedium\n\n\nDescription\n-----------\n\n\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\n\n\n1. Each row must contain the digits `1-9` without repetition.\n2. Each column must contain the digits `1-9` without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\n\n![Image text](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)\n\n\nA partially filled sudoku which is valid.\n\n\nThe Sudoku board could be partially filled, where empty cells are filled with the character `'.'`.\n\n\n**Example 1:**\n\n\n\n```\nInput:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\nOutput: true\n\n```\n\n**Example 2:**\n\n\n\n```\nInput:\n[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n```\n\n**Note:**\n\n\n* A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n* Only the filled cells need to be validated according to the mentioned rules.\n* The given board contain only digits `1-9` and the character `'.'`.\n* The given board size is always `9x9`.\n\n\nAlgorithm\n=========\n\n\nThe criterion is to see whether there are repeated numbers in each row and column, and whether there are repeated numbers in each small 3x3 square matrix. If there are no repeats, the current matrix is a Sudoku matrix, but it does not mean that the Sudoku matrix to be solved has a solution, it simply judges whether the currently unfilled matrix is a Sudoku matrix.\n\n\nThen according to the definition of the Sudoku matrix, when traversing each number, look at the row and column containing the current position and whether the number has appeared in the 3x3 small square matrix.\n\n\nHere we need three boolean matrices with the same size as the original array Same, record each row, each column, each small square matrix whether there is a certain number, the row and column mark subscripts correspond well, that is, the subscripts of the small square matrix need to be slightly changed\n\n\nsubsquare indexing `i - i%3 + j/3` or `j - j%3 + i/3`\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Valid\\_Sudoku {\n\n\t/\\*\n \\* @note: 三个连续if-else可以优化到一个if-else\n \\*\n \\* 记住subsquare编号 i - i%3 + j/3\n \\* 或者 j - j%3 + i/3\n \\*/\n\n\n\tpublic class Solution\\_optimized {\n\n\t    // my thought is to use hashmap counting\n\t    // or maybe bitmap is better, less memory required\n\t    public boolean isValidSudoku(char[][] board) {\n\n\t\t\tfinal int SIZE = 9;\n\n\t        if(board == null || board.length != SIZE || board[0].length != SIZE) return false;\n\n\t        boolean[][] row = new boolean[SIZE][SIZE]; // i-th row, number j\n\t        boolean[][] col = new boolean[SIZE][SIZE];\n\t        boolean[][] matrix = new boolean[SIZE][SIZE];\n\n\t        for(int i = 0; i < SIZE; i++){\n\t            for(int j = 0; j < SIZE; j++){\n\t                if(board[i][j] == '.') continue;\n\n\t                // that number-1, is its index in every checking array\n\t                int n = board[i][j] - '1';\n\n\t                // check three array, if already set true\n\t                // sub-matrix index: i%3 + j%3\n\t                if(row[i][n] || col[j][n] || matrix[i - i % 3 + j / 3][n]){\n\t                    return false;\n\t                }\n\n\t                // if not set, now set this number exists\n\t                row[i][n] = true;\n\t                col[j][n] = true;\n\t                matrix[i - i % 3 + j / 3][n] = true;\n\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 37,
    "title": "Sudoku Solver",
    "problem": "\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n\n\nA sudoku solution must satisfy **all of the following rules**:\n\n\n1. Each of the digits `1-9` must occur exactly once in each row.\n2. Each of the digits `1-9` must occur exactly once in each\n column.\n3. Each of the the digits `1-9` must occur exactly once in each of the 9\n `3x3` sub-boxes of the grid.\n\n\nEmpty cells are indicated by the character `'.'`.\n\n\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)  \n\nA sudoku puzzle...\n\n\n\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)  \n\n...and its solution numbers marked in red.\n\n\n\n**Note:**\n\n\n* The given board contain only digits `1-9` and the character `'.'`.\n* You may assume that the given Sudoku puzzle will have a single unique solution.\n* The given board size is always `9x9`.\n\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/37.html>\n\n\n37. Sudoku Solver\n=================\n\n\nLevel\n-----\n\n\nHard\n\n\nDescription\n-----------\n\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n\n\nA sudoku solution must satisfy **all of the following rules**:\n\n\n1. Each of the digits `1-9` must occur exactly once in each row.\n2. Each of the digits `1-9` must occur exactly once in each column.\n3. Each of the the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\n\nEmpty cells are indicated by the character `'.'`.\n\n\n![Image text](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)\n\n\nA sudoku puzzle…\n\n\n![Image text](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)\n\n\n…and its solution numbers marked in red.\n\n\n**Note:**\n\n\n* The given board contain only digits `1-9` and the character `'.'`.\n* You may assume that the given Sudoku puzzle will have a single unique solution.\n* The given board size is always `9x9`.\n\n\nAlgorithm\n=========\n\n\nSimilar to this question, there are Permutations, Combinations, N-Queens, etc., especially the N-Queens’s problem-solving idea is very similar.\n\n\nFor each grid that needs to be filled with numbers, enter 1 to 9, and every time a number is substituted Determine whether it is legal. If it is legal, continue to the next recursion, and set the number back to’.’ at the end. When judging whether the newly added number is legal, you only need to determine whether the current number is legal, not whether the array is a Sudoku array. Because the numbers added before are all legal, this can make the program more efficient.\n\n\nThe overall idea is this, but it can be implemented in different forms. One form of implementation is to recursively bring the horizontal and vertical coordinates. Since it is filled with numbers line by line, and starts from line 0, when i reaches 9, it means that all the numbers have been successfully filled in and return to true directly. When j is greater than or equal to 9, the current line is filled, and you need to switch to the next line to continue filling, then continue to call the recursive function, and the abscissa will bring i+1. Otherwise, if the current number is not a point, it means that the current position does not need to fill in a number, so call recursion on the right position.\n\n\nIf you need to fill in a number at the current position, you should try to fill in all the numbers from 1 to 9 and let c traverse from 1 to 9. Whenever you try to fill in a number, you need to check whether there is a conflict, and use another sub-function isValid To check whether it is legal, if not legal, skip the current number.\n\n\n* If it is valid, assign the current position to this number, and call recursion on the right position. If the recursive function returns true, it means that it can be filled successfully and returns true directly.\n* If it doesn’t work, you need to reset the state to restore the current position to a point. If all numbers are tried, but still fails, it will eventually return false.\n\n\nThe principle of checking whether the current array is valid is very similar to the previous Valid Sudoku, but it is simpler, because here we only need to check whether the newly added number will conflict with other positions, and detect the ranks and positions of the newly added numbers. Whether there are repeated numbers in the interval.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Sudoku\\_Solver {\n\n\n\tpublic class Solution {\n\n\t    boolean found = false;\n\n\t    public void solveSudoku(char[][] b) {\n\n\t        if (b == null || b.length == 0)     return;\n\n\t        dfs(b, 0, 0);\n\t    }\n\n\t    public void dfs (char[][] b, int row, int col) {\n\n\t        if (row == b.length) {\n\t            found = true;\n\t            return;\n\t        }\n\n\t        for (int i = row; i < b.length; i++) {\n\t            for (int j = col; j < b[0].length; j++) {\n\t                if (b[i][j] != '.') {\n\t                    continue;\n                    }\n\n\t                // try from 1 to 9\n\t                int num = 1;\n\t                while (num <= 9) {\n\n\t                    if (isValid(b, i, j, num)) {\n\t                        b[i][j] = (char)('0' + num); // @note@note: must add cast\n\n\t                        if (col < b[0].length - 1) {\n\t                            dfs(b, row, col + 1);\n\n\t                            if (found) {\n\t                                return;\n                                }\n\n\t                        } else {\n\t                            // dfs(b, row + 1, col);\n\t                            dfs(b, row + 1, 0); // @note@note: index-0 of next row\n\n\t                            if (found) {\n\t                                return;\n                                }\n\t                        }\n\n\t                        b[i][j] = '.'; // reset\n\t                    }\n\n\t                    num++;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    public boolean isValid (char[][] b, int row, int col, int num) {\n\n\t        // search row\n\t        for (int i = 0; i < b[0].length; i++) {\n\t            if (b[row][i] == '0' + num)     return false;\n\t        }\n\n\t        // search column\n\t        for (int i = 0; i < b.length; i++) {\n\t            if (b[i][col] == '0' + num)     return false;\n\t        }\n\n\t        // search sub-square\n\t        int rowSub = row / 3;\n\t        int colSub = col / 3;\n\t        for (int i = rowSub; i < rowSub + 3; i++) {\n\t            for (int j = colSub; j < colSub + 3; j++) {\n\t                if (b[i][j] == '0' + num)     return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\t}\n\n\n\tpublic class Solution\\_2 {\n\n\t    // +1 is for index simplicity\n\t    boolean[][] row = new boolean[9][9 + 1];\n\t    boolean[][] col = new boolean[9][9 + 1];\n\t    boolean[][] sub = new boolean[9][9 + 1];\n\n\t    // hard code number 9 is not good practise BTW\n\t    public void solveSudoku(char[][] board) {\n\t        if(board == null || board.length == 0) {\n\t            return;\n\t        }\n\n\t        solve(board, 0, 0);\n\t    }\n\n\t    public boolean solve(char[][] b, int i, int j) { // r: row, c: col\n\n\t        if(i == 8 && j == 9) { // reaching end of this matrix\n\t            return true;\n\t        }\n\n\t        if(b[i][j] != '.') {\n\t            char currentChar = b[i][j];\n\t            row[i][currentChar - '0'] = true;\n\t            col[j][currentChar - '0'] = true;\n\t            sub[i - i % 3 + j / 3][currentChar - '0'] = true;\n\n\t            if(i < 9) {\n\t                 solve(b, i + 1, j);\n\t            } else {\n\t                solve(b, i, j + 1);\n\t            }\n\n\t        } else {\n\n\t            for(int test = 1; test <= 9; test++) {\n\t                if(row[i][test] == false && col[j][test] == false && sub[i - i % 3 + j / 3][test] == false) {\n\t                    // set this test in marking map to be true\n\t                    row[i][test] = true;\n\t                    col[j][test] = true;\n\t                    sub[i - i % 3 + j / 3][test] = true;\n\n\t                    boolean isFound = false;\n\t                    if(i < 9) {\n\t                        isFound = solve(b, i + 1, j);\n\t                    } else {\n\t                        isFound = solve(b, i, j + 1);\n\t                    }\n\n\t                    if(isFound) {\n\t                        return true;\n\t                    }\n\n\t                    // reset test value\n\t                    row[i][test] = false;\n\t                    col[j][test] = false;\n\t                    sub[i - i % 3 + j / 3][test] = false;\n\n\t                }\n\t            }\n\t        }\n\n\t        return false;\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 38,
    "title": "Count and Say",
    "problem": "\nThe count-and-say sequence is the sequence of integers with the first five terms as\n following:\n\n\n\n```\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n\n```\n\n`1` is read off as `\"one 1\"` or `11`.  \n\n`11` is read off as `\"two 1s\"` or `21`.  \n\n`21` is read off as `\"one 2`, then `one 1\"` or\n `1211`.\n\n\nGiven an integer *n* where 1 ≤ *n* ≤ 30, generate the\n *n*th term of the count-and-say sequence.\n\n\nNote: Each term of the sequence of integers will be represented as a string.\n\n\n \n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 1\n**Output:** \"1\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 4\n**Output:** \"1211\"\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/38.html>\n\n\n\n```\n38\tCount and Say\n\nThe count-and-say sequence is the sequence of integers beginning as follows:\n1, 11, 21, 1211, 111221, ...\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\nGiven an integer n, generate the nth sequence.\n\nNote: The sequence of integers will be represented as a string.\n\n\n```\n\nAlgorithm\n=========\n\n\nThe algorithm is very simple, that is, for the previous number, find the number of the same element, and store the number and the element in the new string.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Count\\_and\\_Say {\n\n    public String countAndSay(int n) {\n\n        // @note: possibly overflow is n is large enough\n        if(n <= 0) {\n            return \"\";\n        }\n\n        String result = \"1\";\n\n        while(n > 1) {\n            char prev = result.charAt(0);\n            int count = 1;\n            String say = \"\";\n\n            int i = 1;\n            for(; i < result.length(); i++) {\n                char current = result.charAt(i);\n\n                if (current == prev) {\n                    count++;\n                } else {\n                    say += count + \"\" + prev;\n\n                    // reset count\n                    count = 1;\n                    prev = current;\n                }\n\n            }\n\n            // check for last digit say\n            say += count + \"\" + prev;\n\n            result = say;\n            n--;\n        }\n\n        // @note: string to int api: Integer.valueOf(result)\n        return result;\n    }\n\n\n\t/\\*\n \\* @note:\n \\*\n \\* 这道题非常的tricky\n \\* String的 += \"x\"的操作是比较expensive的，StringBuilder比较省\n \\*\n \\* StringBuilder的编译效率更高\n \\* ref:\n \\* http://stackoverflow.com/questions/14927630/java-string-concat-vs-stringbuilder-optimised-so-what-should-i-do\n \\*\n \\* 注意坑，就是每次for loop完了之后，还有最后的一个count和say要加到结果里\n \\*/\n\tpublic class Solution {\n\n\t    StringBuilder sb = new StringBuilder();\n\n\t    // my thought, use iteration\n\t    public String countAndSay(int n) {\n\n\t        sb.append(\"1\");\n\n\t        StringBuilder newsb = new StringBuilder();\n\n\t        for (int i = 1; i < n; i++) {\n\n\t            // go through this string\n\t            char previous = sb.charAt(0);\n\t            int count = 1;\n\n\t            // // add checking first input \"1\"...\n\t            // if (sb.length() == 1) {\n\t            // sb.append(count);\n\t            // sb.append(previous);\n\t            // }\n\n\n\t            for (int j = 1; j < sb.length(); j++) {\n\n\t                char curr = sb.charAt(j);\n\n\t                if (curr == previous) {\n\t                    count++;\n\t                }\n\t                // else if (curr != previous && j != sb.length() - 1) {\n\t                else {\n\t                    // sayIt(count, previous);\n\t                    newsb.append(count);\n\t                    newsb.append(previous);\n\n\t                    // update\n\t                    previous = curr;\n\t                    count = 1;\n\t                }\n\t                // else {\n\t                // // sayIt(count, previous);\n\t                // newsb.append(count);\n\t                // newsb.append(previous);\n\t                // }\n\t            }\n\n\t            // append the last one\n\t            newsb.append(count);\n\t            newsb.append(previous);\n\n\t            // update sb\n\t            sb = new StringBuilder(newsb);\n\t            // @note: sb has NO clear()\n\t            // newsb.clear();\n\t            newsb = new StringBuilder();\n\t        }\n\n\t        return sb.toString();\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 39,
    "title": "Combination Sum",
    "problem": "\nGiven a **set** of candidate numbers (`candidates`) **(without\n duplicates)** and a target number (`target`), find all unique combinations\n in `candidates` where the candidate numbers sums to `target`.\n\n\nThe **same** repeated number may be chosen from `candidates` unlimited\n number of times.\n\n\n**Note:**\n\n\n* All numbers (including `target`) will be positive integers.\n* The solution set must not contain duplicate combinations.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** candidates = [2,3,6,7], target = 7,\n**A solution set is:**\n[\n  [7],\n  [2,2,3]\n]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** candidates = [2,3,5], target = 8,\n**A solution set is:**\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/39.html>\n\n\n39. Combination Sum\n===================\n\n\nLevel\n-----\n\n\nMedium\n\n\nDescription\n-----------\n\n\nGiven a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.\n\n\nThe **same** repeated number may be chosen from `candidates` unlimited number of times.\n\n\n**Note:**\n\n\n* All numbers (including `target`) will be positive integers.\n* The solution set must not contain duplicate combinations.\n\n\n**Example 1:**\n\n\n\n```\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\n```\n\n**Example 2:**\n\n\n\n```\nInput: candidates = [2,3,5], target = 8,\nA solution set is:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n```\n\nAlgorithm\n=========\n\n\n### DFS\n\n\nSuch a result requires the return of all the questions that meet the requirements to solve the problem, in all likelihood, it is necessary to use recursion.\n\n\nAnd the idea of solving the problem is the same, similar questions include Path Sum II, Subsets II, Permutations, Permutations II, Combinations, etc. Here we add three new variables, start records the current recursive subscript, out is a solution, res saves everything that has been obtained The solution of each time a new recursive function is called, the target at this time must be subtracted from the current array.\n\n\n### DP\n\n\nWe can also use iterative solutions to create a `three-dimensional` array `dp`, where `dp[i]` represents the set of all solutions whose target number is `i+1`.\n\n\nHere i traverse from 1 to target. For each i, create a two-dimensional array cur, and then traverse the candidates array.\n\n\n* If the number traversed is greater than i, it means that the current and subsequent numbers cannot form i, directly break off.\n* Otherwise, if they are equal, the current numbers form an array by themselves and added to cur.\n* Otherwise, traverse all the arrays in `dp[i-candidates[j]-1]`. If the current number is greater than the first element of the array, skip it, because the result is required to be in order. Otherwise, add the current number to the beginning of the array, and put the array into cur.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class Combination\\_Sum {\n\n    public static void main(String[] args) {\n        Combination\\_Sum out = new Combination\\_Sum();\n        Solution\\_dp s = out.new Solution\\_dp();\n\n// System.out.println(s.combinationSum(new int[]{2,3,6,7}, 7)); // [[2,2,3],[7]]\n        System.out.println(s.combinationSum(new int[]{2,3,5}, 8)); // [[2,2,2,2],[2,3,3],[3,5]]\n    }\n\n    class Solution {\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\n            if (candidates == null || candidates.length == 0) {\n                return result;\n            }\n\n            dfs(candidates, target, 0, new ArrayList<Integer>());\n\n            return result;\n        }\n\n        private void dfs(int[] candidates, int target, int start, ArrayList<Integer> onePath) {\n\n            if (start >= candidates.length || target < 0) { // target<0, assumption is all positive\n                return;\n            }\n\n            if (target == 0) {\n                result.add(new ArrayList<>(onePath));\n                // continue, and possible 1,-1 are next ones\n            }\n\n            for (int i = start; i < candidates.length; i++) {\n                System.out.println(i);\n                onePath.add(candidates[i]);\n                dfs(candidates, target - candidates[i], i, onePath);\n                onePath.remove(onePath.size() - 1);\n            }\n        }\n    }\n\n    class Solution\\_dp {\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\n            // for each-target (from 1 to target), its dp[i][j] => so 3-D array dp[][][]\n            List<List<List<Integer>>> dp = new ArrayList<>();\n            Arrays.sort(candidates);\n\n            for (int i = 1; i <= target; ++i) {\n                List<List<Integer>> cur = new ArrayList<>();\n                for (int j = 0; j < candidates.length; ++j) {\n                    if (candidates[j] > i) break;\n                    if (candidates[j] == i) {\n                        ArrayList<Integer> one = new ArrayList<Integer>();\n                        one.add(candidates[j]);\n                        cur.add(one); // @note: one with proper <Integer>, or else unsupoorted operation error\n                        break;\n                    }\n                    for (List<Integer> a : dp.get(i - candidates[j] - 1)) {\n                        if (candidates[j] > a.get(0)) {\n                            continue;\n                        }\n\n                        ArrayList<Integer> deepCopied = new ArrayList<>(a); // @note: must have\n                        deepCopied.add(0, candidates[j]); // @note: largest at index=0 for the array\n                        cur.add(deepCopied);\n                    }\n                }\n                dp.add(cur);\n            }\n\n            return dp.get(dp.size() - 1);\n        }\n\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 40,
    "title": "Combination Sum II",
    "problem": "\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`),\n find all unique combinations in `candidates` where the candidate numbers\n sums to `target`.\n\n\nEach number in `candidates` may only be used **once** in the\n combination.\n\n\n**Note:**\n\n\n* All numbers (including `target`) will be positive integers.\n* The solution set must not contain duplicate combinations.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** candidates = [10,1,2,7,6,1,5], target = 8,\n**A solution set is:**\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** candidates = [2,5,2,1,2], target = 5,\n**A solution set is:**\n[\n  [1,2,2],\n  [5]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/40.html>\n\n\n\n```\n40. Combination Sum II\n\nGiven a collection of candidate numbers (C) and a target number (T),\nfind all unique combinations in C where the candidate numbers sums to T.\n\nEach number in C may only be used **once** in the combination.\n\nNote:\n    All numbers (including target) will be positive integers.\n    Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).\n    The solution set must not contain duplicate combinations.\n\nFor example, given candidate set 10,1,2,7,6,1,5 and target 8,\n\nA solution set is:\n[1, 7]\n[1, 2, 5]\n[2, 6]\n[1, 1, 6]\n\n\n```\n\nAlgorithm\n=========\n\n\nBased on Combination\\_Sum\\_I, add sorting to move duplicated numbers together and skip.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class Combination\\_Sum\\_II {\n\n    class Solution {\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n            if (candidates == null || candidates.length == 0) {\n                return result;\n            }\n\n            // nlogn\n            Arrays.sort(candidates);\n\n\n            dfs(candidates, target, 0, new ArrayList<Integer>());\n\n            return result;\n        }\n\n        private void dfs(int[] candidates, int target, int start, ArrayList<Integer> onePath) {\n\n            if (target < 0) { // target<0, assumption is all positive\n                return;\n            }\n\n            if (target == 0) {\n                result.add(new ArrayList<>(onePath));\n                // continue, and possible 1,-1 are next ones\n            }\n\n            for (int i = start; i < candidates.length; i++) {\n                if (i > start && candidates[i] == candidates[i - 1]) continue;\n                onePath.add(candidates[i]);\n                dfs(candidates, target - candidates[i], i+1, onePath); // i+1, to use only once\n                onePath.remove(onePath.size() - 1);\n            }\n        }\n    }\n\n    // https://leetcode.com/problems/combination-sum-ii/solution/\n    // official solution got \"Time Limit Exceeded\" error, funny but still a good idea solving this problem\n    class Solution\\_lc {\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n            // container to hold the final combinations\n            List<List<Integer>> results = new ArrayList<>();\n            LinkedList<Integer> comb = new LinkedList<>();\n\n            HashMap<Integer, Integer> counter = new HashMap<>();\n            for (int candidate : candidates) {\n                if (counter.containsKey(candidate))\n                    counter.put(candidate, counter.get(candidate) + 1);\n                else\n                    counter.put(candidate, 1);\n            }\n\n            // convert the counter table to a list of (num, count) tuples\n            List<int[]> counterList = new ArrayList<>();\n            counter.forEach((key, value) -> {\n                counterList.add(new int[]{key, value});\n            });\n\n            backtrack(comb, target, 0, counterList, results);\n            return results;\n        }\n\n        private void backtrack(LinkedList<Integer> comb,\n                               int remain, int curr,\n                               List<int[]> counter,\n                               List<List<Integer>> results) {\n\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n                return;\n            }\n\n            for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n                int[] entry = counter.get(nextCurr);\n                Integer candidate = entry[0], freq = entry[1];\n\n                if (freq <= 0)\n                    continue;\n\n                // add a new element to the current combination\n                comb.addLast(candidate);\n                counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n                // continue the exploration with the updated combination\n                backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n                // backtrack the changes, so that we can try another candidate\n                counter.set(nextCurr, new int[]{candidate, freq});\n                comb.removeLast();\n            }\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 41,
    "title": "First Missing Positive",
    "problem": "\nGiven an unsorted integer array, find the smallest missing positive integer.\n\n\n**Example 1:**\n\n\n\n```\n\nInput: [1,2,0]\nOutput: 3\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: [3,4,-1,1]\nOutput: 2\n\n```\n\n**Example 3:**\n\n\n\n```\n\nInput: [7,8,9,11,12]\nOutput: 1\n\n```\n\n**Note:**\n\n\nYour algorithm should run in *O*(*n*) time and uses constant extra space.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/41.html>\n\n\n\n```\nGiven an unsorted integer array, find the first missing positive integer.\n\nFor example,\nGiven [1,2,0] return 3,\nand [3,4,-1,1] return 2.\n\nYour algorithm should run in O(n) time and uses constant space.\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nPut `1` in the first position `nums[0]` of the array and `2` in the second position `nums[1]`, that is, you need to put `nums[i]` on `nums[nums[i]-1]` to traverse the entire array,\n\n\n* If `nums[i] != i + 1`, and `nums[i]` is an integer and is not greater than n, and `nums[i]` is not equal to `nums[nums[i]-1]`, swap the two positions,\n* if not satisfied above conditions are skipped directly, and the array is traversed again. If the number at the corresponding position is incorrect, the correct number will be returned.\n\n\n### Note\n\n\nThe key is to deal with the collision. If there are `repeated` numbers 1, 1, or 2, 2. If the collision means that there is the correct number at the correct position, `++` will go to the next one.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\nimport java.util.Arrays;\n\npublic class First\\_Missing\\_Positive {\n\n\tpublic class Solution {\n\t    public int firstMissingPositive(int[] nums) {\n\t        if (nums == null || nums.length == 0) {\n\t            return 1;\n\t        }\n\n\t        // two pointers, in plcace sort\n\t        int i = 0;\n\t        while (i < nums.length) {\n\n                while (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]) {\n                    // put nums[i] to index nums[i]-1\n                    int digit = nums[i];\n                    int swapIndex = digit - 1;\n\n                    int tmp = nums[swapIndex];\n                    nums[swapIndex] = digit;\n                    nums[i] = tmp;\n                }\n\n                i++;\n            }\n\n            // another scan for the missing one\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] != j + 1) {\n                    return j + 1;\n                }\n            }\n\n            // @note: case for [1,2,3,4,5]\n            return nums.length + 1;\n        }\n    }\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 42,
    "title": "Trapping Rain Water",
    "problem": "\nGiven *n* non-negative integers representing an elevation map where the width of each\n bar is 1, compute how much water it is able to trap after raining.\n\n\n\n![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)  \n\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this\n case, 6 units of rain water (blue section) are being trapped. **Thanks\n Marcos** for contributing this image!\n \n\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [0,1,0,2,1,0,1,3,2,1,2,1]\n**Output:** 6\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/42.html>\n\n\n\n```\nGiven n non-negative integers representing an elevation map where the width of each bar is 1,\ncompute how much water it is able to trap after raining.\n\nFor example,\nGiven [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nBased on Dynamic Programming, maintaining a one-dimensional dp array, this DP algorithm needs to traverse the array two passes.\n\n\nThe first pass stores the maximum value of the left position of i in dp[i], and then starts the second pass to traverse the array.\n\n\nIn the second traversal, find the maximum value on the right, and then compare it with the maximum on the left to take the smaller value, and compare it with the current value A[i]. If it is greater than the current value, store the difference in the result.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Trapping\\_Rain\\_Water {\n\n    public static void main(String[] args) {\n        Trapping\\_Rain\\_Water out = new Trapping\\_Rain\\_Water();\n        Solution\\_local\\_minimum s = out.new Solution\\_local\\_minimum();\n\n        System.out.println(s.trap(new int[]{5,2,1,2,1,5}));\n    }\n\n    // The short board effect, the storage capacity is related to the short board of the bucket.\n    // Find the longest slab in the height array, and then iterate from both ends to the long slab. When encountering a shorter one, find the storage capacity, and when encountering a longer one, update the edge.\n    public class Solution\\_optimize {\n        public int trap(int[] height) {\n\n            if (height == null || height.length == 0)     return 0;\n\n            int sum = 0;\n            int maxind = 0;\n            int max = Integer.MIN\\_VALUE;\n\n            // find max index\n            for (int i = 0; i < height.length; i++) {\n                if (height[i] > max) {\n                    max = height[i];\n                    maxind = i;\n                }\n            }\n\n            // left\n            int leftmax = height[0];\n            for (int i = 1; i < maxind; i++) {\n\n                if (leftmax < height[i]) {\n                    leftmax = height[i];\n                }\n\n                sum += leftmax - height[i];\n            }\n\n            // right\n            int rightmax = height[height.length - 1];\n            for (int i = height.length - 2; i > maxind; i--) {\n                if (rightmax < height[i]) {\n                    rightmax = height[i];\n                }\n\n                sum += rightmax - height[i];\n            }\n\n            return sum;\n        }\n    }\n\n    // local minimum solution is NOT doable. like [5,2,1,2,1,5], there are 2 local minimums with each holding 1 water\n    // but they are just part of a global minimum\n    class Solution\\_local\\_minimum {\n\n        public int trap(int[] height) {\n\n            // for each position, probe to left and right, find local minimum\n\n            if (height == null || height.length == 0)     return 0;\n\n            int sum = 0;\n\n            int i = 1; // index=0 or index=length-1 will not be a local min, since nothing on its left to hold water\n            while (i < height.length - 1) {\n\n                // only process local min index\n                if (height[i] < height[i - 1] && height[i] < height[i + 1]) {\n\n                    int left = i - 1;\n                    while (left - 1 >= 0 && height[left] < height[left - 1]) {\n                        left--;\n                    }\n\n                    int right = i + 1;\n                    while (right + 1 < height.length && height[right] < height[right + 1]) {\n                        right++;\n                    }\n\n                    // now find its highest bar on both sides\n                    int lower = Math.min(height[left], height[right]);\n\n                    // add up\n                    while (left < right) {\n\n                        if (height[left] < lower) {\n                            sum += lower - height[left];\n                        }\n\n                        left ++;\n                    }\n\n                    // update pointer to search next local minimum\n                    i = right;\n\n                } else {\n                    i++;\n                }\n            }\n\n            return sum;\n        }\n\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\nAlgorithm 2 - not finding the max height\n========================================\n\n\nIf `height` has length 0, then return 0.\n\n\nLoop over `height` in both directions and use two arrays `leftMax` and `rightMax` to store maximum height in both directions. Each element in the array `leftMax` represents the maximum height in the subarray from the leftmost index to the current index. Each element in the array `rightMax` represents the maximum height in the subarray from the current index to the rightmost index.\n\n\nFor each index `i`, the maximum amount of water trapped at the index is `Math.min(leftMax[i], rightMax[i]) - height[i]`. Thus the total amount of water trapped can be obtained.\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nclass Solution\\_notFindingMaxHeight {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0)\n            return 0;\n        int length = height.length;\n        int[] leftMax = new int[length]; // `leftMax` represents the maximum height in the subarray from the leftmost index to the current index\n        int[] rightMax = new int[length]; // `rightMax` represents the maximum height in the subarray from the current index to the rightmost index\n        leftMax[0] = height[0];\n        for (int i = 1; i < length; i++)\n            leftMax[i] = Math.max(height[i], leftMax[i - 1]);\n        rightMax[length - 1] = height[length - 1];\n        for (int i = length - 2; i >= 0; i--)\n            rightMax[i] = Math.max(height[i], rightMax[i + 1]);\n        int amount = 0;\n        for (int i = 0; i < length; i++)\n            amount += Math.min(leftMax[i], rightMax[i]) - height[i];\n        return amount;\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 43,
    "title": "Multiply Strings",
    "problem": "\nGiven two non-negative integers `num1` and `num2` represented as\n strings, return the product of `num1` and `num2`, also represented as\n a string.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** num1 = \"2\", num2 = \"3\"\n**Output:** \"6\"\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** num1 = \"123\", num2 = \"456\"\n**Output:** \"56088\"\n\n```\n\n**Note:**\n\n\n1. The length of both `num1` and `num2` is < 110.\n2. Both `num1` and `num2` contain only digits `0-9`.\n3. Both `num1` and `num2` do not contain any leading zero,\n except the number 0 itself.\n4. You **must not use any built-in BigInteger library** or **convert the\n inputs to integer** directly.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/43.html>\n\n\n\n```\n43. Multiply Strings\n\nGiven two non-negative integers num1 and num2 represented as strings,\nreturn the product of num1 and num2, also represented as a string.\n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\nNote:\n    The length of both num1 and num2 is < 110.\n    Both num1 and num2 contain only digits 0-9.\n    Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n    You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n\n```\n\nAlgorithm\n=========\n\n\nThe length of the product obtained by multiplying two numbers does `not` actually exceed the sum of the lengths of the two numbers. If the length of num1 is m and the length of num2 is n, the length of `num1 * num2` will not exceed `m+n`.\n\n\nUnderstand why it is misplaced when multiplying. For example, the 48 obtained by multiplying 6 by 8 should be added with the wrong 54 obtained by multiplying 6 by 9, because 8 is a number in the tens place, which is equivalent to 80, so the staggered one is actually Need to add 0 at the end. One more thing to observe is that if two digits at any position in num1 and num2 are multiplied, the position of the two digits obtained in the final result is determined. For example, the number at position i in num1 is multiplied by the position in num2. If it is the number of j, then the positions of the two digits obtained are i+j and i+j+1. After you understand these, you can perform misplaced addition and accumulate the final result.\n\n\nSince the multiplication starts from the ones digit, it traverses from the end of the num1 and num2 strings to extract the characters at the corresponding positions respectively, convert them to integers and multiply them.\n\n\nThen determine the positions p1 and p2 where the two digits after the multiplication are located. Since p2 is lower than p1, the two digits mul obtained are added to the position of p2 first, which may cause the number of p2 to be greater than 9, so the number in the ten’s place must be added to the high-order p1, and only the remainder is left in the p2 position, so that the number in each place becomes one. The next thing to do is to start from the high bit and store the number in the result res, remember that leading zeros should be skipped, and finally deal with the next corner case, that is, if the result res is empty, return “0”, otherwise return the result\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class Multiply\\_Strings {\n\n\tpublic static void main(String[] args) {\n\n\t\tint n = '9' - '0';\n\t\tSystem.out.println(n);\n\n\t\tMultiply\\_Strings out = new Multiply\\_Strings();\n\t\tSolution s = out.new Solution();\n\n\t\tSystem.out.println(s.multiply(\"123\", \"456\"));\n\n\t}\n\n\n\tpublic class Solution {\n\t    public String multiply(String num1, String num2) {\n\n\t    \t// validation as to according to description, should also check length<110 and no leading zero\n\t        if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) {\n\t            return \"\";\n\t        }\n\n\t        // @note: proof: 999 \\* 999 = (1000 - 1)^2 < 1000^2=1000000\n\t        // i.e.: n1\\*n2 < 10^(len1+len2) <=> n1\\*n2 <= 999...99(length=len1+len2)\n\t        int[] result = new int[num1.length() + num2.length()];\n\n\t        // @note: reverse is better for store in results, or else reverse direction is annoying\n\t        String n1 = new StringBuilder(num1).reverse().toString();\n\t        String n2 = new StringBuilder(num2).reverse().toString();\n\n\t        int carry = 0;\n\t        int i = 0; // @note: for final check\n\t        int j = 0; // @note: for final check\n\t        for ( ; i < n1.length(); i++) {\n\n\t        \tcarry = 0; // @note: i missed this one, every out loop should update carry!\n\t            int d1 = n1.charAt(i) - '0'; // digit of n1\n\n\n\t            // for (; j < n2.length(); j++) { // @note: here j is not re-set to 0 in another i-loop\n\t            \t\t\t\t\t\t\t\t  // that's why I like while() !!!\n\t            for ( ; j < n2.length(); j++) {\n\n\t                // first calculate this d1\\*n2\n\t                int d2 = n2.charAt(j) - '0';\n\n\t                int single = d1 \\* d2;\n\t                int addCarry = single + carry;\n\n\t                // add up to result array\n\t                // i is also the indicator of start index in result array\n\t                result[i + j] += addCarry;\n\n\t                // @note: careful using if-else, and if carry<10 it's not updated\n\t                // if (single >= 10) {\n\t                // carry += result[i + j] / 10;\n\t                // single = result[i + j] % 10;\n\t                // }\n\t                carry = result[i + j] / 10;\n\t                result[i + j] = result[i + j] % 10;\n\n\t            }\n\n\t            // @note: outside inner loop, there should be a final check (not outside both for-loop)\n\t            // eg.123\\*456\n\t            if (carry > 0) { // j is ++ already\n\t            \tresult[i + j] = carry;\n\t            }\n\t        }\n\n\t        // restore as string\n\t        String m = \"\";\n\t        for (i = 0; i < result.length; i++) {\n\t            m = result[i] + m;\n\t        }\n\n\t        while (m.length() > 1 && m.charAt(0) == '0') {\n\t            m = m.substring(1);\n\t        }\n\n\t        return m;\n\t    }\n\t}\n\n\n\t// but theoretical still overflow possibility\n\tpublic class Solution\\_big\\_integer {\n\t    public String multiply(String num1, String num2) {\n\n\t        BigInteger a = new BigInteger(num1);\n\t        BigInteger b = new BigInteger(num2);\n\n\t        a = a.multiply(b);\n\n\t        return a.toString();\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 44,
    "title": "Wildcard Matching",
    "problem": "\nGiven an input string (`s`) and a pattern (`p`), implement wildcard\n pattern matching with support for `'?'` and `'*'`.\n\n\n\n```\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\n```\n\nThe matching should cover the **entire** input string (not partial).\n\n\n**Note:**\n\n\n* `s` could be empty and contains only lowercase letters `a-z`.\n* `p` could be empty and contains only lowercase letters `a-z`, and\n characters like `?` or `*`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\ns = \"aa\"\np = \"a\"\n**Output:** false\n**Explanation:** \"a\" does not match the entire string \"aa\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\ns = \"aa\"\np = \"*\"\n**Output:** true\n**Explanation:** '*' matches any sequence.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:**\ns = \"cb\"\np = \"?a\"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input:**\ns = \"adceb\"\np = \"*a*b\"\n**Output:** true\n**Explanation:** The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input:**\ns = \"acdcb\"\np = \"a*c?b\"\n**Output:** false\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/44.html>\n\n\n\n```\nImplement wildcard pattern matching with support for '?' and '*'.\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"*\") → true\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"ab\", \"?*\") → true\nisMatch(\"aab\", \"c*a*b\") → false\n\n\n```\n\nAlgorithm\n=========\n\n\nPay attention to distinguish it from another `Regular Expression Matching` question. The functions of the asterisks in the two questions are different. Pay attention to contrast and distinguish.\n\n\nThe biggest difficulty of this question is that for the processing of asterisks, it can match any string, which is almost like a hang, that is, before the corresponding position of the asterisk, no matter if there is any string in your s, I have a big asterisk to match. But there is a problem that it cannot handle, that is, once there is a character in p that does not exist in s, then it must not be matched, because the asterisk can only add characters, not eliminate characters, and if there are characters, it will be a star.\n\n\nOnce the character string to be matched is determined, the matching situation after the asterisk position is beyond reach. Therefore, the position of the asterisk in the p string is very important. It is represented by jStar, and the position where the asterisk matches in the s string is represented by iStart. Here iStar and jStar are initialized to -1, which means that there is no star by default. Number. Then use two variables i and j to point to the traversed position in the current s string and p string, respectively.\n\n\nStart matching, if i is less than the length of the s string, perform a while loop.\n\n\n* If the current two characters are equal, or the character in p is a question mark, then i and j are increased by 1.\n* If p[j] is an asterisk, to record the position of the asterisk, jStar is assigned to j, at this time j is incremented by 1, and iStar is assigned to i.\n* If the current p[j] is not an asterisk and cannot match p[i], the asterisk must be used at this time. If the asterisk has not appeared before, then return false directly, such as s = “aa” and p = “c\\*”, at this time s[0] and p[0] cannot match. Although p[1] is an asterisk, it cannot match still.\n* If the asterisk has appeared before, such as s = “aa” and p = “\\*c”, when it is found that s[1] and p[1] cannot match, but fortunately before p[0 ] When an asterisk appears, give s[1] to the asterisk of p[0] to match. As for how to know if there is an asterisk before, you can see the role of iStar at this time, because it is initialized to -1, and when it encounters an asterisk, it will be updated to i. Just check the value of iStar, to decide if you can use asterisks to continue your life.\n\n\nAlthough all the characters in s were matched, the p string must be checked afterwards. At this time, only asterisks are left in the unmatched p string, and no other characters are allowed. The continuous asterisks are filtered out , If j is not equal to the length of p, return false.\n\n\n### Note\n\n\n1. Wildcard Matching\n\n\nImplement wildcard pattern matching with support for ‘?’ and ‘*’.\n‘?’ Matches any single character.\n‘*’ Matches any sequence of characters (including the empty sequence).\n\n\n1. Regular Expression Matching\n\n\nImplement regular expression matching with support for ‘.’ and ‘*’.\n‘.’ Matches any single character.\n‘*’ Matches zero or more of the preceding element.\n\n\nThe function prototypes for both topics are `bool isMatch(const char *s, const char *p)`;\n\n\nAt first glance, these two questions thought they were the same, but they were not. The first question was actually wildcard matching, which means that the ‘*’ sign can match any substring.\nThe second question is actually regular expression matching, that is, the ‘*’ sign means that the character before it can appear any number of times (including 0). This is actually the Klin closure described in the Long Book of Compilation Principles.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Wildcard\\_Matching {\n\n    public static void main(String[] args) {\n        Wildcard\\_Matching out = new Wildcard\\_Matching();\n        Solution\\_dp sdp = out.new Solution\\_dp();\n\n        System.out.println(sdp.isMatch(\"\", \"\\*\"));\n        System.out.println(sdp.isMatch(null, \"\\*\"));\n    }\n\n    public class Solution\\_dp {\n\n        public boolean isMatch(String s, String p) {\n\n            if (s == null || p == null) {\n                return false;\n            }\n\n            if (p.length() == 0) {\n                return s.length() == 0;\n            }\n\n            // @note: need to comment out below, or else fail test case\n            // s=\"\", p=\"\\*\\*\\*\\*\\*\\*\"\n// if (s.length() == 0) {\n// return p == \"\\*\"; // \\* matching emtpy string\n// }\n\n            int m = s.length();\n            int n = p.length();\n\n            // dp[i][j]: up to i-th char in p, and up to j-th char in s, are matching.\n            // note: i,j are not index\n            boolean[][] dp = new boolean[m + 1][n + 1];\n            dp[0][0] = true; // facilitate loop\n\n            for (int i = 1; i <= n; ++i) {\n                // if p starting with \"\\*\", then all true for dp[0][i]\n                // or else, all false for dp[0][i]\n                if (p.charAt(i - 1) == '\\*') dp[0][i] = dp[0][i - 1];\n            }\n            for (int i = 1; i <= m; ++i) {\n                for (int j = 1; j <= n; ++j) {\n                    if (p.charAt(j - 1) == '\\*') {\n                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                    } else {\n                        dp[i][j] = (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?')\n                            && dp[i - 1][j - 1];\n                    }\n                }\n            }\n            return dp[m][n];\n        }\n    }\n\n\n    public class Solution\\_iteration {\n\n        public boolean isMatch(String s, String p) {\n\n            if (s == null || p == null) {\n                return false;\n            }\n\n            if (p.length() == 0) {\n                return s.length() == 0;\n            }\n\n            if (s.length() == 0) {\n                return p == \"\\*\"; // \\* matching emtpy string\n            }\n\n            int i = 0;\n            int j = 0;\n            int iMark = -1;\n            int jMark = -1;\n\n            while (i < s.length()) {\n                if (j < p.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n                    i++;\n                    j++;\n                } else if (j < p.length() && p.charAt(j) == '\\*') {\n\n                    // record i,j before trying different i positions\n                    iMark = i;\n                    jMark = j;\n\n                    // skip \\* to match its next\n                    j++;\n\n                    //这一步是关键，匹配s中当前字符与p中‘＊’后面的字符，如果匹配，则在第一个if中处理，如果不匹配，则继续比较s中的下一个字符。\n                } else if (jMark != -1) { // if reaching here, meaning one attempt of start at position iMkark failed, try another attempt\n\n                    // another attempt, move iMark next, also move j to marked matching position\n                    iMark++;\n                    j = jMark + 1;\n\n                    i = iMark;\n                } else {\n                    return false;\n                }\n            }\n\n            // now scanned s, but possibly p is not fully scanned. Only remaining of p is all \\* then return true\n            while (j < p.length() && p.charAt(j) == '\\*') {\n                j++;\n            }\n\n            return j == p.length();\n\n        }\n    }\n\n\n    public class Solution\\_over\\_time {\n        /\\*\n test case, over time:\n\n \"aaaabaaaabbbbaabbbaabbaababbabbaaaababaaabbbbbbaabbbabababbaaabaabaaaaaabbaabbbbaababbababaabbbaababbbba\"\n \"\\*\\*\\*\\*\\*b\\*aba\\*\\*\\*babaa\\*bbaba\\*\\*\\*a\\*aaba\\*b\\*aa\\*\\*a\\*b\\*\\*ba\\*\\*\\*a\\*a\\*\"\n\n \\*/\n        public boolean isMatch(String s, String p) {\n\n            if (s == null || p == null) {\n                return false;\n            }\n\n            if (p.length() == 0) {\n                return s.length() == 0;\n            }\n\n            if (s.length() == 0) {\n                return p == \"\\*\"; // \\* matching emtpy string\n            }\n\n            // now length of p and s are at least 1\n            if (p.charAt(0) == '?') {\n                return isMatch(s.substring(1), p.substring(1));\n            } else if (p.charAt(0) == '\\*') {\n                char prev = s.charAt(0);\n                for (int i = 0; i < s.length(); i++) {\n                    // when i=0, it's case: \"b\" matching \"\\*b\"\n                    if (prev == s.charAt(i) && isMatch(s.substring(i + 1), p.substring(1))) { // @note: here i+1 for substring\n                        return true;\n                    }\n                }\n            } else { // normal cases\n                return s.charAt(0) == p.charAt(0) && isMatch(s.substring(1), p.substring(1));\n            }\n\n            return false;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 45,
    "title": "Jump Game II",
    "problem": "\nGiven an array of non-negative integers, you are initially positioned at the first index of\n the array.\n\n\nEach element in the array represents your maximum jump length at that position.\n\n\nYour goal is to reach the last index in the minimum number of jumps.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [2,3,1,1,4]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2.\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Note:**\n\n\nYou can assume that you can always reach the last index.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/45.html>\n\n\n\n```\n45\tJump Game II\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\nFor example:\nInput: [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\n                Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nNote:\nYou can assume that you can always reach the last index.\n\n@tag-array\n@tag-greedy\n\n```\n\nAlgorithm\n=========\n\n\nThe core method is to use `Greedy` idea of ​​the greedy algorithm to solve it. Think about why? In order to jump to the end quickly, I want to know the range of each step. Greed here is not to choose the position with the farthest jumping power in the range of jumping, because this selection is not necessarily the optimal solution, so to speak it doesn’t feel like a greedy algorithm again.\n\n\nIn fact, what is greedy here is the **farthest range** that can be reached. It traverses all the positions that can be reached by the current jump, and then predicts the farthest distance that can be jumped in the next step according to the jump force at that position, and greets the farthest range. Once this range reaches the end, the number of steps currently used must be the minimum number of steps.\n\n\nTwo variables cur and pre are required to save the current farthest position that can be reached and the farthest position that can be reached before. As long as cur does not reach the last position, the loop will continue. Pre is first assigned the value of cur, which means the last loop. The farthest position that can be reached later.\n\n\n* If the current position i is less than or equal to pre, it means that it is still within the range that the previous jump can reach. The current position is added to the jump force to update cur. The method to update cur is to compare the `current cur` and `i + larger value of A[i]`,\n* if it is not stated in the question whether the end can be reached, it can also be judged whether pre and cur are equal at this time. If they are equal, it means that cur has not been updated, that is, the end position cannot be reached, return -1.\n\n\nCode\n====\n\n\nJava\n\n\nThis one is easier to understand, with the `break;` check\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Solution {\n\n\tpublic int jump(int[] A) {\n\t\tint jumps = 0, curEnd = 0, curFarthest = 0;\n\t\tfor (int i = 0; i < A.length - 1; i++) { // @note: i < Len - 1. 也就是停在倒数第二个\n\t\t\tcurFarthest = Math.max(curFarthest, i + A[i]);\n\t\t\tif (i == curEnd) {\n\t\t\t\tjumps++;\n\t\t\t\tcurEnd = curFarthest;\n\n\t\t\t\tif (curEnd >= A.length - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn jumps;\n\t}\n}\n\n\n\npublic class Jump\\_Game\\_II {\n\n\tclass Solution {\n        public int jump(int[] nums) {\n            if (nums == null || nums.length == 0) {\n                return 0;\n            }\n\n            int left = 0; // last jump reaching to\n            int right = 0; // current jump reaching to\n\n            int count = 0;\n\n            for (int i = 0; i < nums.length - 1; i++) { // @note: i < Len - 1. 也就是停在倒数第二个\n                right = Math.max(right, i + nums[i]);\n                if (i == left) { // reaching furthest of last jump\n                    count++;\n                    left = right;\n                }\n            }\n\n            return count;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 46,
    "title": "Permutations",
    "problem": "\nGiven a collection of **distinct** integers, return all possible permutations.\n \n\n\n**Example:**\n\n\n\n```\n\n**Input:** [1,2,3]\n**Output:**\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/46.html>\n\n\n\n```\n46. Permutations\n\nGiven a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].\n\n@tag-backtracking\n\n\n```\n\nAlgorithm\n=========\n\n\nWhen n=1, there is only one number a1 in the array, and there is only one total permutation, which is a1\n\n\nWhen `n=2`, there is `a1a2` in the array at this time, and there are two kinds of full arrays, `a1a2` and `a2a1`. Then, considering the relationship with the above situation at this time, you can find that it is actually added in the two positions before and after a1. A2\n\n\nWhen `n=3`, there are `a1a2a3` in the array. At this time, there are six kinds of full arrays, namely `a1a2a3`, `a1a3a2`, `a2a1a3`, `a2a3a1`, `a3a1a2`, and `a3a2a1`. Then according to the above conclusion, it is actually obtained by adding `a3` at different positions on the basis of a1a2 and a2a1.\n\n\n`_ a1 _ a2 _`: a3a1a2, a1a3a2, a1a2a3\n\n\n`_ a2 _ a1 _`: a3a2a1, a2a3a1, a2a1a3\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Permutations {\n\n\tpublic static void main(String[] args) {\n\t\tPermutations out = new Permutations();\n        Solution\\_iteration s = out.new Solution\\_iteration();\n\n\t\tSystem.out.println(s.permute(new int[]{1, 2, 3}));\n\t}\n\n\t// time: O(N)\n\t// space: O(N)\n\tpublic class Solution\\_iteration {\n\t    public List<List<Integer>> permute(int[] nums) {\n\n\t        List<List<Integer>> list = new ArrayList<>();\n\n\t        if (nums == null || nums.length == 0) {\n\t            return list;\n\t        }\n\n\t        list.add(new ArrayList<Integer>()); // add empty single list, to make below loop going\n\n\t        for (int i = 0; i < nums.length; i++) {\n\t            List<List<Integer>> tmpList = new ArrayList<>();\n\n\t            int insertNum = nums[i];\n\n\t            // get each permutations. eg, [1,2], [2,1]\n\t            for (List<Integer> singlePerm: list) {\n\n\t                // eg. [1,2] and insert 3, there are 3 insert position\n\t                int singleListSize = singlePerm.size();\n\t                for (int index = 0; index <= singleListSize; index++) { // @note: the usage of arraylist add() api: add(atIndex, value)\n\t                    singlePerm.add(index, insertNum);\n\t                    tmpList.add(new ArrayList<Integer>(singlePerm));\n\n\t                    // @note: don't forget roll back\n\t                    singlePerm.remove(index);\n\t                }\n\t            }\n\n\t            // update list. @note: possible issue, this is not deep copy\n\t            list = tmpList;\n\t        }\n\n\t        return list;\n\t    }\n\t}\n\n    // time: O(N)\n    // space: O(N)\n    class Solution\\_dfs {\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        public List<List<Integer>> permute(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return result;\n            }\n\n            dfs(nums, new HashSet<Integer>(), new ArrayList<Integer>()); // hashset 或者是boolean[]\n\n            return result;\n        }\n\n        private void dfs(int[] nums, HashSet<Integer> isVisited, ArrayList<Integer> onePath) {\n\n            if (isVisited.size() == nums.length) {\n                result.add(new ArrayList<>(onePath));\n                return;\n            }\n\n            for (int i = 0; i < nums.length; i++) {\n                if (!isVisited.contains(i)) {\n\n                    isVisited.add(i);\n                    onePath.add(nums[i]);\n\n                    dfs(nums, isVisited, onePath);\n\n                    isVisited.remove(i);\n                    onePath.remove(onePath.size() - 1);\n                }\n            }\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 47,
    "title": "Permutations II",
    "problem": "\nGiven a collection of numbers that might contain duplicates, return all possible unique\n permutations.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [1,1,2]\n**Output:**\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/47.html>\n\n\n\n```\n47 Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[1,1,2], [1,2,1], and [2,1,1].\n\n@tag-backtracking\n\n\n```\n\nAlgorithm\n=========\n\n\nDue to the possibility of repeated numbers in the input array, if you follow the previous algorithm, there will be repeated permutations. We need to avoid repetition. In the recursive function, we must determine whether the previous number is equal to the current number. If it is equal, and its The value in the corresponding visited is 1, the current number can be used (the reason for this will be explained below), otherwise it needs to be skipped, so that no duplication will occur.\n\n\n### Note\n\n\n1 .use the idea of insertion sort:\n Loop through the array, in each iteration, a new number is added to different locations of results of previous iteration.\n\n\n2 . to skip duplicates, two ways:\n 1. act on permutation\\_I result, use a set to filter duplicated results: bulky and extra o(N) operations and o(N) space\n 2. truncate during iteration or recursion, but: need sort nums[] array first, extra o(NlogN) operations\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Permutations\\_II {\n\n\tpublic static void main(String[] args) {\n\t\tPermutations\\_II out = new Permutations\\_II();\n\t\tSolution\\_recursion s = out.new Solution\\_recursion();\n\n\t\tList<ArrayList<Integer>> result = s.permuteUnique(new int[]{1,1,2});\n\t\tSystem.out.println(result.toString()); // output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n\t}\n\n\n    // time: O(N)\n    // space: O(N)\n    public class Solution\\_recursion {\n\n        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\n        public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {\n\n            if (num == null && num.length == 0)\n                return res;\n\n            Arrays.sort(num);\n\n            dfs(num, new boolean[num.length], new ArrayList<Integer>());\n\n            return res;\n        }\n\n        // @para: used by index\n        private void dfs(int[] num, boolean[] used, ArrayList<Integer> onePerm) {\n\n            if (onePerm.size() == num.length) {\n                res.add(new ArrayList<Integer>(onePerm));\n                return;\n            }\n\n            for (int i = 0; i < num.length; i++) {\n\n                // @note: !used[i-1], here “-1” to skip if prev used\n                if (i > 0 && !used[i - 1] && num[i] == num[i - 1])\n                    continue;\n\n                if (!used[i]) {\n                    used[i] = true;\n                    onePerm.add(num[i]);\n\n                    dfs(num, used, onePerm);\n\n                    onePerm.remove(onePerm.size() - 1);\n                    used[i] = false;\n                }\n            }\n        }\n    }\n\n\tpublic class Solution\\_hashset\\_for\\_unique {\n\t    public List<List<Integer>> permuteUnique(int[] nums) {\n\n\t        List<List<Integer>> list = new ArrayList<>();\n\n\t        if (nums == null || nums.length == 0) {\n\t            return list;\n\t        }\n\n\t        list.add(new ArrayList<Integer>()); // add empty single list, to make below loop going\n\n\t        for (int i = 0; i < nums.length; i++) {\n\n\t            List<List<Integer>> tmpList = new ArrayList<>();\n\t            int insertNum = nums[i];\n\n\t            // get each permutations. eg, [1,2], [2,1]\n\t            for (List<Integer> singlePerm: list) {\n\n\t                /\\*\n @note: I made big mistake below, in for(): index<list.size(), but inside add one more to list, so infinite loop...\n \\*/\n\n\t                // eg. [1,2] and insert 3, there are 3 insert position\n\t                // for (int index = 0; index <= singlePerm.size(); index++) { // @note: the usage of arraylist add() api: add(atIndex, value)\n\t                int singleListSize = singlePerm.size();\n\t                for (int index = 0; index <= singleListSize; index++) { // @note: the usage of arraylist add() api: add(atIndex, value)\n\t                    singlePerm.add(index, insertNum);\n\t                    tmpList.add(new ArrayList<Integer>(singlePerm));\n\n\t                    // @note: don't forget roll back\n\t                    singlePerm.remove(index);\n\t                }\n\t            }\n\n\t            // udpate list\n\t            list = tmpList;\n\t        }\n\n\t        /\\*\n \\* option 1: sort, and skip duplicated digits => o(NlogN)\n \\* option 2: keep all, then remove duplication, each pair comparison => o(N^2)\n \\*/\n\n\t        // hacky way, work based on permutation\\_I result\n\t        Set<List<Integer>> hs = new HashSet<>();\n\t        hs.addAll(list);\n\t        list.clear();\n\t        list.addAll(hs);\n\n\t        return list;\n\t    }\n\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 48,
    "title": "Rotate Image",
    "problem": "\nYou are given an *n* x *n* 2D matrix representing an image.\n\n\nRotate the image by 90 degrees (clockwise).\n\n\n**Note:**\n\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means\n you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D\n matrix and do the rotation.\n\n\n**Example 1:**\n\n\n\n```\n\nGiven **input matrix** =\n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix **in-place** such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n\n```\n\n**Example 2:**\n\n\n\n```\n\nGiven **input matrix** =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n],\n\nrotate the input matrix **in-place** such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/48.html>\n\n\n\n```\nYou are given an n x n 2D matrix representing an image.\n\nRotate the image by 90 degrees (clockwise).\n\nExample 1:\n\nGiven input matrix =\n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n\nExample 2:\n\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n\n\nFollow up:\nCould you do this in-place?\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nUse a simple example to analyze:\n\n\n\n```\n1 2 3　　　 　　 7 4 1　\n\n4 5 6　　-->　　 8 5 2　　\n\n7 8 9 　　　 　　 9 6 3\n\n```\n\nThere are many ways to flip 90 degrees, one or more steps can be solved, first look at a direct method, this method is to cover the previous numbers in a clockwise order, starting from the four top corners, and then To traverse in the middle, the coordinates covered each time are the same, as follows:\n\n\n`(i, j) <- (n-1-j, i) <- (n-1-i, n-1-j) <- (j, n-1-i)`\n\n\nThis is actually a cyclic process. The first position covers the fourth position, where the value range of i is [0, n/2), and the value range of j is [i, n-1-i), As for why i and j are in this value range, why i don’t need to traverse [n/2, n). If you carefully observe the relationship between these positions, it is not difficult to find that the range of column j is actually [i, n-1 -i) Turn 90 degrees clockwise, which is exactly the position of [n/2, n) in row i. This method changes four numbers each time through the loop\n\n\n### Note\n\n\nI missed a key concept, I DO NOT have to rotate all numbers on one edge from start to end\n\n\n\n```\n1. for corner positions of each layer, rotate first is also changing end of that layer row\n2. for numbers not corner, rotate them\n\n\neg:\n\t1 2\n\t3 4\n\n\tone rotate is enough, since except corner position, no other positions\n\n\neg:\n\t1   2   3   4   5\n\t6   7   8   9   10\n\t11  12  13  14  15\n\t16  17  18  19  20\n\t21  22  23  24  25\n\n\tlike in row \"1,2,3,4,5\", rotate 1 will also change 5\n\tso, for each edge, rotate to the penultimate one, that is, only rotate \"1,2,3,4\" is enough, and 5 will be processed in the next operation\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\n\npublic class Rotate\\_Image {\n\n\tpublic class Solution {\n\t    /\\* eg:\n\n 1 2 3 4 5\n 6 7 8 9 10\n 11 12 13 14 15\n 16 17 18 19 20\n 21 22 23 24 25\n \\*/\n\n\t    public void rotate(int[][] m) { // m for matrix\n\n\t        if (m == null || m.length == 0) {\n\t            return;\n\t        }\n\n\t        // for each circle, start position is (i,i), length is rectangle size\n\t        // eg. above: (0,0), length=5; (1,1), length=3\n\t        int i = 0;\n\t        int length = m.length;\n\n\t        while (i < m.length / 2) {\n\n\t            int count = 0;\n\t            while (count < length - 1) { // @note: extra attention here \"-1\".\n\t            // while (count < length) {\n\n\t                int tmp = m[i][i + count];\n\n\t                // i+length-1: last index of this rectangle\n\t                // i+length-1 - count: index from backward\n\t                m[i][i + count] = m[i + length - 1 - count][i];\n\t                m[i + length - 1 - count][i] = m[i + length - 1][i + length - 1 - count];\n\t                m[i + length - 1][i + length - 1 - count] = m[i + count][i + length - 1];\n\t                m[i + count][i + length - 1] = tmp;\n\n\t                count++;\n\t            }\n\n\t            length -= 2; // @note: shrink each edge length by 2\n\t            i++; // start point moving along diagonal\n\t        }\n\t    }\n\t}\n\n\t// An Inplace function to rotate a N x N matrix by 90 degrees in anti-clockwise direction\n\tstatic void rotateMatrix\\_anticlock(int N, int mat[][])\n\t{\n\t\t// Consider all squares one by one\n\t\tfor (int x = 0; x < N / 2; x++) {\n\t\t\t// Consider elements in group of 4 in\n\t\t\t// current square\n\t\t\tfor (int y = x; y < N-x-1; y++) {\n\t\t\t\t// store current cell in temp variable\n\t\t\t\tint temp = mat[x][y];\n\n\t\t\t\t// move values from right to top\n\t\t\t\tmat[x][y] = mat[y][N-1-x];\n\n\t\t\t\t// move values from bottom to right\n\t\t\t\tmat[y][N-1-x] = mat[N-1-x][N-1-y];\n\n\t\t\t\t// move values from left to bottom\n\t\t\t\tmat[N-1-x][N-1-y] = mat[N-1-y][x];\n\n\t\t\t\t// assign temp to left\n\t\t\t\tmat[N-1-y][x] = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void rotateMatrix\\_clockwise(int N, int mat[][])\n\t{\n\t\t// Consider all squares one by one\n\t\tfor (int x = 0; x < N / 2; x++) {\n\t\t\t// Consider elements in group of 4 in\n\t\t\t// current square\n\t\t\tfor (int y = x; y < N-x-1; y++) {\n\t\t\t\t// store current cell in temp variable\n\t\t\t\tint temp = mat[x][y];\n\n\t\t\t\t// move values from right to top\n\t\t\t\tmat[x][y] = mat[y][N-1-x];\n\n\t\t\t\t// move values from bottom to right\n\t\t\t\tmat[y][N-1-x] = mat[N-1-x][N-1-y];\n\n\t\t\t\t// move values from left to bottom\n\t\t\t\tmat[N-1-x][N-1-y] = mat[N-1-y][x];\n\n\t\t\t\t// assign temp to left\n\t\t\t\tmat[N-1-y][x] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\nanother way: transpose + reflect\n--------------------------------\n\n\nreference <https://leetcode.com/problems/rotate-image/solution/>\n\n\noriginal\n\n\n\n```\n[\n\t[1,2,3],\n\t[4,5,6],\n\t[7,8,9]\n]\n\n```\n\ndiagonal as reverse base line\n\n\n\n```\n[\n\t[1,4,7],\n\t[2,5,8],\n\t[3,6,9]\n]\n\n```\n\nevery row, to reverse from left to right\n\n\n\n```\n[\n\t[7,4,1],\n\t[8,5,2],\n\t[9,6,3]\n]\n\n```\n\njava implementation\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nclass Solution\\_diagonal {\n\tpublic void rotate(int[][] matrix) {\n\t\ttranspose(matrix);\n\t\treflect(matrix);\n\t}\n\n\tpublic void transpose(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tint tmp = matrix[j][i];\n\t\t\t\tmatrix[j][i] = matrix[i][j];\n\t\t\t\tmatrix[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void reflect(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n / 2; j++) {\n\t\t\t\tint tmp = matrix[i][j];\n\t\t\t\tmatrix[i][j] = matrix[i][n - j - 1];\n\t\t\t\tmatrix[i][n - j - 1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 49,
    "title": "Group Anagrams",
    "problem": "\nGiven an array of strings, group anagrams together.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n**Output:**\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n\n**Note:**\n\n\n* All inputs will be in lowercase.\n* The order of your output does not matter.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/49.html>\n\n\n\n```\n49\tGroup Anagrams\n\nGiven an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\t[\n\t  [\"ate\", \"eat\",\"tea\"],\n\t  [\"nat\",\"tan\"],\n\t  [\"bat\"]\n\t]\n\nNote:\n    For the return value, each inner list's elements must follow the lexicographic order.\n    All inputs will be in lower-case.\n\n@tag-hashtable\n\n```\n\nAlgorithm\n=========\n\n\n### With sort\n\n\nHow to judge whether the two are misplaced words? It can be found that if the character order of the misplaced words is rearranged, the same result will be obtained. Therefore, reordering is a way to judge whether the two are misplaced words.\n\n\nUse the same string as the key, save all misplaced words in the string array, and establish a mapping between the key and the number of different sets of misplaced words. The reason why there is no dislocation between the key and its membership is established here The mapping between word sets uses a small trick to avoid copying the set in the HashMap to the result res at the end.\n\n\nWhen it is detected that the current word is not in the HashMap, it is known that the word will belong to a new set of misplaced words, so it is mapped to the number of the current set of misplaced words, and then an empty set is added to res, so that You can directly find the position of the new misplaced word set through its mapping value, so as to store the new word in the result.\n\n\n### No sort\n\n\nUse an int array with a size of 26 to count the number of occurrences of characters in each word, and then convert the int array into a unique string, and map it with the string array, so that there is no need to sort the strings.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Group\\_Anagrams {\n\n    public static void main(String[] args) {\n        Group\\_Anagrams out = new Group\\_Anagrams();\n\n        System.out.println(out.groupAnagrams(new String[]{\"\", \"\"}));\n\n        System.out.println(out.groupAnagrams(new String[]{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"}));\n\n        char[] a = new char[]{'c','b','a'};\n        Arrays.sort(a);\n        System.out.println(a);\n    }\n\n    // eg: abbccc will be #1#2#3#0#0#0...#0\n    //\n    // Time Complexity: O(NK)\n    // Space Complexity: O(NK)\n    class Solution {\n        public List<List<String>> groupAnagrams(String[] strs) {\n\n            if (strs.length == 0) {\n                return new ArrayList<>();\n            }\n\n            Map<String, List<String>> hm = new HashMap<>();\n            for (String each: strs) {\n                String key = getKey(each);\n\n                if (!hm.containsKey(key)) {\n                    hm.put(key, new ArrayList<>());\n                }\n\n                hm.get(key).add(each);\n            }\n\n            return new ArrayList<>(hm.values());\n        }\n\n        // abbccc will be #1#2#3#0#0#0...#0\n        // or 123000...000 <= better key\n        private String getKey(String s) {\n\n            int[] count = new int[26];\n            for (char each: s.toCharArray()) {\n                count[each - 'a']++;\n            }\n\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < count.length; i++) {\n                sb.append(count[i]);\n            }\n\n            return sb.toString();\n        }\n    }\n\n    // Time Complexity: O(NKlogK)\n    // Space Complexity: O(NK)\n    public List<List<String>> groupAnagrams(String[] array) {\n        List<List<String>> list = new ArrayList<List<String>>();\n\n        if (array == null) {\n            return list;\n        }\n\n        HashMap<String, List<String>> hm = new HashMap<>();\n        for (String each: array) {\t\t// M \\* (NlogN + N) => M \\* NlogN\n            // sort-2\n            char[] charArray = each.toCharArray();\n            Arrays.sort(charArray);\n            // String sorted = charArray.toString(); // @note: return: getClass().getName() + '@' + Integer.toHexString(hashCode())\n\n            // String sorted = new String(charArray); // @note: correct way to convert char[] to string\n            // String sorted = String.valueOf(charArray); // @note: correct way to convert char[] to string\n            String sorted = String.copyValueOf(charArray); // @note: correct way to convert char[] to string\n\n\n\n            if (hm.containsKey(sorted)) {\n                hm.get(sorted).add(each);\n            } else {\n                ArrayList<String> al = new ArrayList<String>();\n\n                al.add(each);\n                hm.put(sorted, al);\n            }\n        }\n\n        list.addAll(hm.values());\n\n        return list;\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 50,
    "title": "Pow(x, n)",
    "problem": "\nImplement [pow(*x*,\n *n*)](http://www.cplusplus.com/reference/valarray/pow/), which calculates *x* raised to the power *n*\n (xn).\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 2.00000, 10\n**Output:** 1024.00000\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 2.10000, 3\n**Output:** 9.26100\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** 2.00000, -2\n**Output:** 0.25000\n**Explanation:** 2-2 = 1/22 = 1/4 = 0.25\n\n```\n\n**Note:**\n\n\n* -100.0 < *x* < 100.0\n* *n* is a 32-bit signed integer, within the range [−231, 231−\n 1]\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/50.html>\n\n\n\n```\n50\tPow(x, n)\n\nImplement pow(x, n).\n\nExample 1:\n\nInput: 2.00000, 10\nOutput: 1024.00000\n\nExample 2:\n\nInput: 2.10000, 3\nOutput: 9.26100\n\nExample 3:\n\nInput: 2.00000, -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\nNote:\n    -100.0 < x < 100.0\n    n is a 32-bit signed integer, within the range [−231, 231 − 1]\n\n\n```\n\nAlgorithm\n=========\n\n\nUse recursion to calculate in half, reduce n by half each time, so that n will eventually be reduced to 0, and any number to the power of 0 will be 1. At this time, multiply it back.\n\n\nIf n is even at this time, directly recurse the last time The obtained value can be returned as a square. If it is an odd number, it needs to be multiplied by the value of x.\n\n\nAnother thing to note is that n may be negative. For the case where n is negative, I can use its absolute value to calculate a result and then take its reciprocal. It was possible before, but now it’s added in the test case After a minus 2 to the 31st power, this will not work, because its absolute value exceeds the integer maximum value, there will be an overflow error, but you can use another way to write only one function, and handle n in each recursion. And then do the corresponding transformation.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Pow\\_x\\_n {\n\n\tpublic class Solution\\_recursion {\n\t    public double myPow(double x, int n) {\n\n\t        // return Math.pow(x, n);\n\n\t        double flag = 1;\n\n\t        if (x < 0 && n % 2 == 1) {\n\t            flag = -1;\n\t            x = x \\* (-1);\n\t        }\n\n\t        if (n == 0) {\n\t            return 1;\n\t        } else if (n > 0) {\n\t            double result = dfs(x, (long)n);\n\t            return result \\* flag;\n\n\t        } else {\n\t            // @note: below n\\*-1 already flowed... (1.00000,-2147483648)\n\t            // double result = dfs(x, (long)(n \\* (-1)));\n\t            double result = dfs(x, (long)n \\* (-1));\n\t            return (1 / result) \\* flag;\n\t        }\n\t    }\n\n\t    // @note: overflowed by input: (1.00000,-2147483648)\n\t    // private double dfs(double x, int n) {\n\t    private double dfs(double x, long n) {\n\n\t        if (n == 1) {\n\t            return x;\n\t        }\n\n\t        double half = dfs(x, n / 2);\n\n\t        if (n % 2 == 0) {\n\t            return half \\* half;\n\t        } else {\n\t            return x \\* half \\* half;\n\t        }\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 51,
    "title": "N-Queens",
    "problem": "\nThe *n*-queens puzzle is the problem of placing *n* queens on an *n*×*n*\n chessboard such that no two queens attack each other.\n\n\n![](https://assets.leetcode.com/uploads/2018/10/12/8-queens.png)\n\n\nGiven an integer *n*, return all distinct solutions to the *n*-queens puzzle.\n \n\n\nEach solution contains a distinct board configuration of the *n*-queens'\n placement, where `'Q'` and `'.'` both indicate a queen\n and an empty space respectively.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 4\n**Output:** [\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/51.html>\n\n\n\n```\n51\tN-Queens\n\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\n\nEach solution contains a distinct board configuration of the n-queens' placement,\nwhere 'Q' and '.' both indicate a queen and an empty space respectively.\n\nFor example,\nThere exist two distinct solutions to the 4-queens puzzle:\n\n[\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n\n```\n\nAlgorithm\n=========\n\n\nThe exhaustive method is to try all combinations. Every time a new queen is placed, it must be ensured that it does not conflict with all the previous queens. If a conflict occurs, it means that the current position cannot be placed, and a new place must be found.\n\n\nThis logic is very suitable for recursion. We first create an array queens of length nxn that is full of points, and then call recursion from line 0. In the recursive function, we first judge whether the current number of rows is already n,\n\n\n* if yes, it means that all the queens have been successfully placed, so we only need to add the queens array to the result.\n* Otherwise, we traverse the position of all the columns of the row, and after the positions of the row and column are determined, we need to verify whether the current position will conflict, then we need to use a sub-function to judge,\n\t+ first verify whether the column has a conflict, it traverses all the previous rows, if there is a queen in the same column in a certain row, the conflict returns false;\n\t+ then verify whether the two diagonals conflict, which is some coordinate conversion, mainly don’t write it wrong,\n* if there is no conflict, then the conflict You can put the queen in the position. After you put the new queen, you can call recursion on the next line. Pay attention to the return state after the recursion.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class N\\_Queens {\n\n    public class Solution {\n\n        List<String[]> list = new ArrayList<String[]>();\n\n        public List<String[]> solveNQueens(int n) {\n\n            if (n <= 0)     return list;\n\n            // index is row-number, place[index] is position of queen on that row\n            int[] place = new int[n];\n\n            dfs(n, 0, place);\n\n            return list;\n        }\n\n        public void dfs(int n, int currentRow, int[] place) {\n            if (currentRow == n) {\n                // save to list\n                saveToList(place);\n                return;\n            }\n\n            for (int i = 0; i < n; i++) {\n\n                if (isValid(i, currentRow, place)) {\n                    place[currentRow] = i; // 1 meaning place queen\n                    dfs(n, currentRow + 1, place);\n                    place[currentRow] = i; // undo place queen\n                }\n            }\n        }\n\n        public boolean isValid(int currentRowPosition, int currentRow, int[] place) {\n            // check all previous rows\n            for (int i = 0; i < currentRow; i++) {\n                // if (place[i] == currentRowPosition || Math.abs(currentRow - i) == Math.abs(place[i] - currentRowPosition))\n                if (place[i] == currentRowPosition || currentRow - i == (int)Math.abs(place[i] - currentRowPosition))\n                    return false;\n            }\n\n            return true;\n        }\n\n        public void saveToList(int[] place) {\n\n            int len = place.length;\n            String[] array = new String[len];\n\n            // construct string of n dots...\n            String row = \"\";\n            for(int i = 0; i < len; i++) {\n                row += \".\";\n            }\n\n            for(int i = 0; i < len; i++) {\n                int rowPosition = place[i]; // at position place[i] on row i\n                array[i] = row.substring(0, rowPosition) + \"Q\" + row.substring(rowPosition + 1);\n            }\n\n            list.add(array);\n        }\n    }\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 52,
    "title": "N-Queens II",
    "problem": "\nThe *n*-queens puzzle is the problem of placing *n* queens on an *n*×*n*\n chessboard such that no two queens attack each other.\n\n\n\n![](https://assets.leetcode.com/uploads/2018/10/12/8-queens.png)\n\n\nGiven an integer *n*, return the number of distinct solutions to\n the *n*-queens puzzle.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown below.\n[\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/52.html>\n\n\n\n```\n Follow up for N-Queens problem.\n\n Now, instead outputting board configurations, return the total number of distinct solutions.\n\n\n```\n\nAlgorithm\n=========\n\n\nIn fact, I think the order of the two Queens-question should be reversed. The previous question is a little more complicated than this one. There is no difference in essence between the two. Both have to be solved by backtracking. If you understand the previous question The idea of the question, this question only needs to make a small change, no need to ask for the specific queen’s pendulum, just need to increase the counter by one every time a solution is generated.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class N\\_Queens\\_II {\n\n\t// just simply return list.size(), seems costly if only count is needed\n\n\tpublic class Solution {\n\n\t\tList<List<String>> list = new ArrayList<List<String>>();\n\n\t\tpublic int totalNQueens(int n) {\n\n\t\t\tif (n <= 0)\n\t\t\t\treturn 0;\n\n\t\t\t// index is row-number, place[index] is position of queen on that\n\t\t\t// row\n\t\t\tint[] place = new int[n];\n\n\t\t\tdfs(n, 0, place);\n\n\t\t\treturn list.size();\n\t\t}\n\n\t\tpublic void dfs(int n, int currentRow, int[] place) {\n\t\t\tif (currentRow == n) {\n\t\t\t\t// save to list\n\t\t\t\tsaveToList(place);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\tif (isValid(i, currentRow, place)) {\n\t\t\t\t\tplace[currentRow] = i; // 1 meaning place queen\n\t\t\t\t\tdfs(n, currentRow + 1, place);\n\t\t\t\t\tplace[currentRow] = i; // undo place queen\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isValid(int currentRowPosition, int currentRow,\n\t\t\t\tint[] place) {\n\t\t\t// check all previous rows\n\t\t\tfor (int i = 0; i < currentRow; i++) {\n\t\t\t    if (place[i] == currentRowPosition\n\t\t\t\t\t\t|| currentRow - i == (int) Math.abs(place[i] - currentRowPosition))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic void saveToList(int[] place) {\n\n\t\t\tint len = place.length;\n\t\t\tList<String> one = new ArrayList<String>(len);\n\n\t\t\t// construct string of n dots...\n\t\t\tString row = \"\";\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\trow += \".\";\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tint rowPosition = place[i]; // at position place[i] on row i\n\t\t\t\tone.add(row.substring(0, rowPosition) + \"Q\"\n\t\t\t\t\t\t+ row.substring(rowPosition + 1));\n\t\t\t}\n\n\t\t\tlist.add(one);\n\t\t}\n\t}\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 53,
    "title": "Maximum Subarray",
    "problem": "\nGiven an integer array `nums`, find the contiguous subarray (containing at\n least one number) which has the largest sum and return its sum.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [-2,1,-3,4,-1,2,1,-5,4],\n**Output:** 6\n**Explanation:** [4,-1,2,1] has the largest sum = 6.\n\n```\n\n**Follow up:**\n\n\nIf you have figured out the O(*n*) solution, try coding another solution using the\n divide and conquer approach, which is more subtle.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/53.html>\n\n\n\n```\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\nFor example, given the array [−2,1,−3,4,−1,2,1,−5,4],\nthe contiguous subarray [4,−1,2,1] has the largest sum = 6.\n\nMore practice:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nThe `O(n)` solution is to define two variables res and curSum, where res holds the final result to be returned, that is, the sum of the largest sub-array.\n\n\nThe initial value of curSum is 0, and each traversal of a number num, compare `curSum + num` and `num`. Store the larger value in curSum, and then store the larger value in res and curSum in res, and so on until the entire array is traversed, and the value of the largest sub-array can be obtained in res.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Maximum\\_Subarray {\n\n\t// o(N)\n\tpublic class Solution\\_oN {\n\t\tpublic int maxSubArray(int[] nums) {\n\t\t\tint res = Integer.MIN\\_VALUE, curSum = 0;\n\t\t\tfor (int num : nums) {\n\t\t\t\t// like a 1D dp[i], 'curSum' is max sum up to index-i\n\t\t\t\t// if 'curSum' is <0 , then it will be num\n\t\t\t\tcurSum = Math.max(curSum + num, num);\n\t\t\t\tres = Math.max(res, curSum);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpublic class Solution {\n\t\tpublic int maxSubArray(int[] nums) {\n\n\t\t\tif (nums == null || nums.length == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// consider input: [-1,-2,-3], and [-3,-2,-1]\n\t\t\tint max = nums[0];\n\n\t\t\tint tmpSum = nums[0]; // @note: cannot set to 0\n\t\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\t\tif (tmpSum < 0) { // even if current number is large positive on, this tmpSum makes no contribution\n\t\t\t\t\ttmpSum = nums[i];\n\t\t\t\t} else {\n\t\t\t\t\ttmpSum += nums[i];\n\t\t\t\t}\n\n\t\t\t\tmax = Math.max(max, tmpSum);\n\n\t\t\t}\n\n\t\t\treturn max;\n\t\t}\n\n\t}\n\n\tpublic class Solution\\_divide\\_conquer {\n\n\t\t/\\* O(n logn), still better than brute force O(n^2)\n\n Time analysis:\n\n 1. Find-Max-Cross-Subarray: O(n) time\n 2. Two recursive calls on input size n/2\n\n Thus:\n T(n) = 2T(n/2) + O(n)\n T(n) = O(n log n)\n\n \\*/\n\t\tpublic int maxSubArray(int[] nums) {\n\n\t\t\tif (nums == null || nums.length == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn dfs(nums, 0, nums.length - 1);\n\t\t}\n\n\t\tprivate int dfs(int[] nums, int start, int end) {\n\n\t\t\tif (start == end) {\n\t\t\t\treturn nums[start];\n\t\t\t}\n\n\t\t\tint mid = (start + end) >> 1; // @note: possible overflow\n\n\t\t\tint left = dfs(nums, start, mid);\n\t\t\tint right = dfs(nums, mid + 1, end);\n\n\t\t\tint leftHalf = 0, rightHalf = 0;\n\n\t\t\tint leftMax = Integer.MIN\\_VALUE;\n\t\t\tint rightMax = Integer.MIN\\_VALUE;\n\n\t\t\tfor (int i = mid + 1; i <= end; i++) {\n\t\t\t\trightHalf += nums[i];\n\t\t\t\trightMax = Math.max(rightHalf, rightMax);\n\t\t\t}\n\n\t\t\tfor (int i = mid; i >= start; i--) {\n\t\t\t\tleftHalf += nums[i];\n\t\t\t\tleftMax = Math.max(leftMax, leftHalf);\n\t\t\t}\n\n\t\t\treturn Math.max(rightMax + leftMax, Math.max(left, right));\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 54,
    "title": "Spiral Matrix",
    "problem": "\nGiven a matrix of *m* x *n* elements (*m* rows, *n* columns),\n return all elements of the matrix in spiral order.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n**Output:** [1,2,3,6,9,8,7,4,5]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n**Output:** [1,2,3,4,8,12,11,10,9,5,6,7]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/54.html>\n\n\n\n```\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\nFor example,\nGiven the following matrix:\n\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nYou should return [1,2,3,6,9,8,7,4,5].\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nDefine p and q to be the height and width of the current loop. When p or q is 1, it means that the last loop has only one row or one column, and you can jump out of the loop. The difficulty of this question lies in the conversion of subscripts. How to correctly convert subscripts is the key to solving this problem. You can complete the subscripts by referring to the 3x3 example above.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Spiral\\_Matrix {\n\n\tpublic class Solution {\n\n\t    List<Integer> list = new ArrayList<Integer>();\n\n\t    public List<Integer> spiralOrder(int[][] matrix) {\n\t        if (matrix == null || matrix.length == 0)   return list;\n\n\t        int row = matrix.length;\n\t        int column = matrix[0].length;\n\n\t        int leftBoundary = 0, upBoundary = 1;\n\t        int rightBoundary = column - 1, downBoundary = row - 1; // marking boundary index\n\n\t        /\\*\n direction: 1 is up, 2 is down, 3 is left, 4 is right\n \\*/\n\n\t        // at beginning direction is right;\n\t        int direction = 4;\n\t        int i = 0, j = 0; // initial position of pointer\n\n\t        int count = 0;\n\t        while (count < row \\* column) { // @note: I see other solutions, with for() inside of while(), maybe a more intuitive way\n\n\t            list.add(matrix[i][j]);\n\n\t            // switch case\n\t            if (direction == 1) { // move right\n\n\t                if (i == upBoundary) {\n\t                    direction = 4;\n\t                    j++;\n\n\t                    upBoundary++;\n\n\t                } else {\n\t                    i--;\n\t                }\n\t            }\n\n\t            else if (direction == 2) {\n\n\t                if (i == downBoundary) {\n\t                    direction = 3;\n\t                    j--;\n\n\t                    // update boundary\n\t                    downBoundary--;\n\t                } else {\n\t                    i++;\n\t                }\n\t            }\n\n\t            else if (direction == 3) {\n\n\t                if (j == leftBoundary) {\n\t                    direction = 1;\n\t                    i--;\n\n\t                    // update boundary\n\t                    leftBoundary++;\n\n\t                } else {\n\t                    j--;\n\t                }\n\t            }\n\n\t            else { // direction == 4\n\n\t                // check boundary\n\t                if (j == rightBoundary) {\n\t                    direction = 2;\n\t                    i++;\n\n\t                    // row boundary is 1 less now\n\t                    rightBoundary--;\n\t                } else {\n\t                    j++;\n\t                }\n\n\t            }\n\t            // end of direction switch-case\n\n\t            count++;\n\t        }\n\n\t        return list;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 55,
    "title": "Jump Game",
    "problem": "\nGiven an array of non-negative integers, you are initially positioned at the first index of\n the array.\n\n\nEach element in the array represents your maximum jump length at that position.\n\n\nDetermine if you are able to reach the last index.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [2,3,1,1,4]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [3,2,1,0,4]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/55.html>\n\n\n\n```\n55\tJump Game\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\nExample 1:\n\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n\n\n@tag-array\n@tag-greedy\n\n\n```\n\nAlgorithm\n=========\n\n\nGreedy Algorithm, because here is not very concerned about the number of remaining steps at each position, but only want to know whether we can reach the end, that is to say we are only interested in the farthest reachable position.\n\n\nSo we maintain a variable reach, represents the farthest reachable position, initialized to 0. Traverse each number in the array,\n\n\n* if the current coordinate is greater than reach or reach has reached the last position, then jump out of the loop,\n* otherwise update the value of reach to the larger value of `i + nums[i]`, where `i + nums[i]` indicates the maximum position that the current position can reach.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Jump\\_Game {\n\n\n    class Solution {\n        public boolean canJump(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return false;\n            }\n\n            int reach = 0;\n            for (int i = 0; i < nums.length; i++) {\n                // first judge, whether the last reach can reach the new i\n                if (reach >= nums.length - 1 || reach < i) { // i > reach, meaning cannot reach\n                    break;\n                }\n\n                reach = Math.max(reach, i + nums[i]);\n            }\n\n            return reach >= nums.length - 1;\n\n        }\n    }\n\n\n    class Solution\\_dp {\n        public boolean canJump(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return false;\n            }\n\n            // 其中 dp[i] 表示达到i位置时剩余的跳力，若到达某个位置时跳力为负了，说明无法到达该位置\n            int[] dp = new int[nums.length];\n\n            for (int i = 1; i < nums.length; i++) { // @note: start from 1, because already at index=0\n                dp[i] = Math.max(dp[i - 1], nums[i - 1]) - 1;\n\n                if (dp[i] < 0) {\n                    return false;\n                }\n            }\n\n            return true;\n\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 56,
    "title": "Merge Intervals",
    "problem": "\nGiven a collection of intervals, merge all overlapping intervals.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [[1,3],[2,6],[8,10],[15,18]]\n**Output:** [[1,6],[8,10],[15,18]]\n**Explanation:** Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [[1,4],[4,5]]\n**Output:** [[1,5]]\n**Explanation:** Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n**NOTE:** input types have been changed on April 15, 2019. Please reset to\n default code definition to get new method signature.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/56.html>\n\n\n56 Merge Intervals\n\n\nGiven a collection of intervals, merge all overlapping intervals.\n\n\nFor example,\n\n\nGiven `[1,3],[2,6],[8,10],[15,18]`,\n\n\nreturn `[1,6],[8,10],[15,18]`.\n\n\nAlgorithm\n=========\n\n\nThe first thing to do is to sort the interval set. Since what we want to sort is a structure, we have to define our own comparator before we can use sort to sort. We sort by the value of start from small to large.\n\n\nAfter sorting, we can Start to merge, first save the first interval in the result, and then traverse the interval set from the second.\n\n\n* If the last interval in the result does not overlap with the current interval traversed, the current interval is directly stored in the result,\n* if there is Overlap, update the end value of the last interval in the result to the larger of the end value of the last interval in the result and the current end value, and then continue to traverse the interval set, and so on to get the final result.\n\n\n### Note\n\n\nIf merge then do not join the list, if there is no merge then add `(i,j)` and then update `i,j`.\n\n\nThe last interval is outside the for, if you want to check, it may be missed.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class Merge\\_Intervals {\n\n\t/\\*\\*\n \\* Definition for an interval.\n \\* public class Interval {\n \\* int start;\n \\* int end;\n \\* Interval() { start = 0; end = 0; }\n \\* Interval(int s, int e) { start = s; end = e; }\n \\* }\n \\*/\n    class Solution\\_optimize {\n        public int[][] merge(int[][] intervals) {\n            if (intervals == null || intervals.length == 0) {\n                return intervals;\n            }\n\n            Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n            List<int[]> result = new ArrayList<>();\n\n            for (int[] each: intervals) {\n                if (result.isEmpty() || result.get(result.size() - 1)[1] < each[0]) {\n                    result.add(each);\n                } else {\n                    result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], each[1]);\n                }\n            }\n\n            int[][] merged = new int[result.size()][];\n            for (int i = 0; i < result.size(); i++) {\n                merged[i] = result.get(i);\n            }\n\n            return merged;\n        }\n    }\n\n\n    class Solution {\n        public int[][] merge(int[][] intervals) {\n\n            if (intervals == null || intervals.length == 0) {\n                return intervals;\n            }\n\n            Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n            List<int[]> result = new ArrayList<>();\n\n            int[] prev = intervals[0];\n            for (int i = 1; i < intervals.length; i++) {\n\n                int[] current = intervals[i];\n\n                if (prev[1] < current[0] || prev[0] > current[1]) { // no overlap\n                    result.add(prev);\n                    prev = current;\n                } else {\n                    prev[0] = Math.min(prev[0], current[0]);\n                    prev[1] = Math.max(prev[1], current[1]);\n                }\n            }\n\n            // @note: must have, final check\n            result.add(prev); // last node\n\n            int[][] merged = new int[result.size()][];\n            for (int i = 0; i < result.size(); i++) {\n                merged[i] = result.get(i);\n            }\n\n            return merged;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 57,
    "title": "Insert Interval",
    "problem": "\nGiven a set of *non-overlapping* intervals, insert a new interval into the intervals\n (merge if necessary).\n\n\nYou may assume that the intervals were initially sorted according to their start times.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** intervals = [[1,3],[6,9]], newInterval = [2,5]\n**Output:** [[1,5],[6,9]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n**Output:** [[1,2],[3,10],[12,16]]\n**Explanation:** Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n```\n\n**NOTE:** input types have been changed on April 15, 2019. Please reset to\n default code definition to get new method signature.\n\n\n\n### \n\n",
    "explanation": "\nFormatted question description: <https://leetcode.ca/all/57.html>\n\n\n57. Insert Interval\n===================\n\n\n* Difficulty: Hard.\n* Related Topics: Array, Sort.\n* Similar Questions: Merge Intervals, Range Module.\n\n\nProblem\n-------\n\n\nGiven a set of **non-overlapping** intervals, insert a new interval into the intervals (merge if necessary).\n\n\nYou may assume that the intervals were initially sorted according to their start times.\n\n\n**Example 1:**\n\n\n\n```\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\n```\n\n**Example 2:**\n\n\n\n```\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n```\n\nAlgorithm\n=========\n\n\nThere are two situations, overlapping or non-overlapping.\n\n\nThe non-overlapping situation is best. Just insert the new interval directly into the corresponding position.\n\n\nThe overlapping situation is more complicated. Sometimes there will be multiple overlaps, and the new interval needs to be updated. Range so as to include all overlaps, then add the new interval to the result res, and finally add the latter interval to the result res. The specific idea is to use a variable cur to traverse the interval.\n\n\n* If the end position of the current cur interval is less than the start position of the interval to be inserted, it means that there is no overlap, then the cur interval is added to the result res, and then cur increments by 1.\n* Until cur goes out of bounds or overlaps the while loop exits, and then uses a while loop to process all overlapping intervals, each time the smaller value of the start position of the two intervals and the larger value of the end position are used to update the insert Interval, then cur increments by 1.\n\n\nThe while loop exits until cur is out of bounds or there is no overlap. Then add the updated new interval to the result res, and then add the interval after cur to the result\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Insert\\_Interval {\n\n\n\tpublic class Solution\\_no\\_boolean\\_flag {\n\n\t    List<Interval> list = new ArrayList<Interval>();\n\n\t    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n\n\t        if (intervals == null || newInterval == null) {\n\t            return list;\n        \t}\n\t        if (intervals.size() == 0) {\n\t            list.add(newInterval);\n\t            return list;\n\t        }\n\n\t        for (int i = 0; i < intervals.size(); i++) {\n\n\t            Interval current = intervals.get(i);\n\n\t            if (current.end < newInterval.start) {\n\t                list.add(current);\n\t            }\n\n\t            else if (newInterval.end < current.start) {\n\t                list.add(newInterval);\n\t                newInterval = current; // @note: update newInterval as the pending to be put in list\n\t            }\n\n\t            else /\\* overlap: if (current.end >= newInterval.start) \\*/ {\n\t                Interval combine =\n                        new Interval(\n                            Math.min(current.start, newInterval.start),\n                            Math.max(current.end, newInterval.end)\n                        );\n\t                // list.add(combine);\n\t                newInterval = combine;\n\t            }\n\t        }\n\n\t        // @note: last one! check lastone is merged\n\t        // [[1,5]], [6,8]\n\t        // [[1,5]], [2,3]\n\t        // Interval lastsecond = list.get(list.size() - 1);\n\t        // if (lastone.start > lastsecond.end) {\n\t        // list.add(lastone);\n\t        // }\n\n\t        list.add(newInterval);\n\n\t        return list;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 58,
    "title": "Length of Last Word",
    "problem": "\nGiven a string *s* consists of upper/lower-case alphabets and empty space characters\n `' '`, return the length of last word in the string.\n\n\nIf the last word does not exist, return 0.\n\n\n**Note:** A word is defined as a character sequence consists of non-space characters only.\n \n\n\n**Example:**\n\n\n\n```\n\n**Input:** \"Hello World\"\n**Output:** 5\n\n```\n\n \n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/58.html>\n\n\n\n```\n58. Length of Last Word\n\nGiven a string s consists of upper/lower-case alphabets and empty space characters ' ',\nreturn the length of last word in the string.\n\nIf the last word does not exist, return 0.\n\nNote: A word is defined as a character sequence consists of non-space characters only.\n\nFor example,\nGiven s = \"Hello World\",\nreturn 5.\n\n\n```\n\nAlgorithm\n=========\n\n\nPreprocess the input string first, remove the spaces at the beginning and the end, and then use a counter to accumulate the length of the non-space string, and clear the counter when it encounters a space.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Length\\_of\\_Last\\_Word {\n\n\tpublic class Solution\\_no\\_extra\\_space { // one scan\n\t    public int lengthOfLastWord(String s) {\n\t        if (s == null || s.length() == 0) {\n\t            return 0;\n\t        }\n\n\t        int count = 0;\n\t        for (int i = s.length() - 1; i >= 0; i--) {\n\n\t            if (count == 0 && s.charAt(i) != ' ') { // skip spaces\n\t                count++;\n\t            } else if (count != 0 && s.charAt(i) == ' ') {\n\t                break;\n\t            } else if (('a' <= s.charAt(i) && s.charAt(i) <= 'z') || ('A' <= s.charAt(i) && s.charAt(i) <= 'Z')) {\n\t                count++;\n\t            }\n\t        }\n\n\t        return count;\n\n\t    }\n\t}\n\n\tpublic class Solution {\n\t    public int lengthOfLastWord(String s) {\n\n\t        if (s == null || s.length() == 0) {\n\t            return 0;\n\t        }\n\n\t        String[] array = s.split(\" \"); // @note: if input is string with spaces “ “, the array length is 0\n\n\t        if (array.length == 0) {\n\t            return 0;\n\t        } else {\n\t            return array[array.length - 1].length();\n\t        }\n\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 59,
    "title": "Spiral Matrix II",
    "problem": "\nGiven a positive integer *n*, generate a square matrix filled with elements from 1 to\n *n*2 in spiral order.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 3\n**Output:**\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/59.html>\n\n\n\n```\nGiven an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\n\nFor example,\nGiven n = 3,\n\nYou should return the following matrix:\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nGiven that the rectangle is a square, we use n / 2 to calculate the number of rings. If n is an odd number, the middle point is not counted in the number of rings, so it needs to be assigned separately in the end, or the problem of subscript conversion Is difficult.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Spiral\\_Matrix\\_II {\n\n\t// @note: compare: very similar to rotate image one, layer by layer, each layer: length-2\n\tpublic class Solution\\_by\\_layer {\n\t    public int[][] generateMatrix(int n) {\n\t        if (n < 0) {\n\t            return null;\n\t        }\n\n\t        int[][] result = new int[n][n];\n\n\t        int xStart = 0;\n\t        int yStart = 0;\n\t        int num = 1;\n\n\t        while (n > 0) {\n\t            if (n == 1) { // if n is even, then no single center point\n\t                result[yStart][xStart] = num++;\n\t                break;\n\t            }\n\n\t            for (int i = 0; i < n - 1; i++) {\n\t                result[yStart][xStart + i] = num++;\n\t            }\n\n\t            for (int i = 0; i < n - 1; i++) {\n\t                result[yStart + i][xStart + n - 1] = num++;\n\t            }\n\n\t            for (int i = 0; i < n - 1; i++) {\n\t                result[yStart + n - 1][xStart + n - 1 - i] = num++;\n\t            }\n\n\t            for (int i = 0; i < n - 1; i++) {\n\t                result[yStart + n - 1 - i][xStart] = num++;\n\t            }\n\n\t            xStart++;\n\t            yStart++;\n\t            n = n - 2;\n\t        }\n\n\t        return result;\n\t    }\n\t}\n\n\n    public class Solution {\n\n        public int[][] generateMatrix(int n) {\n\n            int[][] result = new int[n][n];\n\n            if (n <= 0) {\n                return result;\n            }\n\n            int i = 0, j = 0; // initiate row and column\n\n            int leftBoundary = 0, upBoundary = 1;\n            int rightBoundary = n - 1, downBoundary = n - 1; // marking boundary index\n\n            /\\*\n direction: 1 is up, 2 is down, 3 is left, 4 is right\n \\*/\n\n            // at beginning direction is right;\n            int direction = 4;\n\n            for (int num = 1; num <= n \\* n; num++) {\n\n                result[i][j] = num;\n\n                // switch case\n                if (direction == 1) { // move right\n\n                    if (i == upBoundary) {\n                        direction = 4;\n                        j++;\n\n                        upBoundary++;\n\n                    } else {\n                        i--;\n                    }\n                }\n\n                else if (direction == 2) {\n\n                    if (i == downBoundary) {\n                        direction = 3;\n                        j--;\n\n                        // update boundary\n                        downBoundary--;\n                    } else {\n                        i++;\n                    }\n                }\n\n                else if (direction == 3) {\n\n                    if (j == leftBoundary) {\n                        direction = 1;\n                        i--;\n\n                        // update boundary\n                        leftBoundary++;\n\n                    } else {\n                        j--;\n                    }\n                }\n\n                else { // direction == 4\n\n                    // check boundary\n                    if (j == rightBoundary) {\n                        direction = 2;\n                        i++;\n\n                        // row boundary is 1 less now\n                        rightBoundary--;\n                    } else {\n                        j++;\n                    }\n\n                }\n            }\n\n            return result;\n\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 60,
    "title": "Permutation Sequence",
    "problem": "\nThe set `[1,2,3,...,*n*]` contains a total of *n*! unique\n permutations.\n\n\nBy listing and labeling all of the permutations in order, we get the following sequence for\n *n* = 3:\n\n\n1. `\"123\"`\n2. `\"132\"`\n3. `\"213\"`\n4. `\"231\"`\n5. `\"312\"`\n6. `\"321\"`\n\n\nGiven *n* and *k*, return the *k*th permutation sequence.\n\n\n**Note:**\n\n\n* Given *n* will be between 1 and 9 inclusive.\n* Given *k* will be between 1 and *n*! inclusive.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 3, k = 3\n**Output:** \"213\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 4, k = 9\n**Output:** \"2314\"\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/60.html>\n\n\n\n```\n60. Permutation Sequence\n\nThe set [1,2,3,…,n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order,\nWe get the following sequence (ie, for n = 3):\n\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\nGiven n and k, return the kth permutation sequence.\n\nNote: Given n will be between 1 and 9 inclusive.\n\n@tag-backtracking\n@tag-math\n\n\n```\n\nAlgorithm\n=========\n\n\n### Math\n\n\nAssuming there are `n` elements, the K-th permutation result string is\n`a1, a2, a3, ..... ..., an`\nSo which number is a1?\n\n\nSo here, we remove a1, then the remaining permutation is\n`a2, a3, .... .... an`, a total of n-1 elements. There are n-1 elements in total `(n-1)!` group arrangement, then you can know\n\n\nSet variable `K1 = K`, \n`a1 = K1 / (n-1)!`\n\n\nSimilarly, the value of a2 can be derived as\n\n\n\n```\na2 = K2 / (n-2)!\nK2 = K1 % (n-1)!\n.......\na(n-1) = K(n-1) / 1!\nK(n-1) = K(n-2) / 2!\n\nan = K(n-1)\n\n```\n\n### Cantor Expand\n\n\nHow to find the 16th (lexicographically) {1,2,3,4,5} permutation?\n\n\n1. First use `16-1` to get `15` — @note:@memorize: “-1” is key to understand, `k-th` permutation meaning k-1, (i.e. code line below `k = k - 1; // k 变为 k - 1`)\n\t* `@note@note`: eg: first permutation, k=1, after divided by `4!, 3!, 2!, 1!`, should be `0,0,0,0`,\n\t* but `1/1!` will gerate 1, which is wrong!\n\t* so should be `0/1! = 0`\n2. Divide 4 by 15! Get 0 remaining 15\n3. Divide 3 with 15! Get 2 remaining 3\n4. Divide 2 with 3! Get 1 remaining 1\n5. Divide 1 by 1! Get 1 more than 0\n\n\nThere are 0 numbers smaller than it is 1, so the first digit is 1.\n\n\nThere are 2 numbers that are smaller than it is 3, but 1 has appeared before, so it is 4.\n\n\nThere is 1 number smaller than it is 2, but 1 has appeared before, so it is 3.\n\n\nThere is 1 number smaller than it is 2, but 1, 3, and 4 have all appeared, so it is 5.\n\n\nThe last number can only be 2\n\n\nSo the arrangement is 1 4 3 5 2\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Permutation\\_Sequence {\n\n\tpublic static void main(String[] args) {\n        Permutation\\_Sequence out = new Permutation\\_Sequence();\n        Solution s = out.new Solution();\n\n        System.out.println(s.getPermutation(4, 17)); // 3412\n    }\n\n    // time: O(N)\n    // space: O(N)\n    public class Solution {\n        public String getPermutation(int n, int k) {\n\n            List<Integer> nums = new ArrayList<Integer>();\n            List<Integer> factorial = new ArrayList<Integer>(); // total `n` elements\n            factorial.add(1);\n            for (int i = 1; i <= n; i++) {\n                nums.add(i);\n\n                // size=n+1, will be [1,1,2,6,24]\n                // so that, factorial(k) is `k!`\n                factorial.add(factorial.get(i - 1) \\* i);\n            }\n\n\n            StringBuilder result = new StringBuilder();\n            k = k - 1; // k 变为 k - 1\n            for (int i = n; i > 0; i--) {\n\n                int digit = k / factorial.get(i - 1);\n                result.append(nums.get(digit));\n\n                k %= factorial.get(i - 1);\n                nums.remove(digit); // remove by object\n            }\n            return result.toString();\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 61,
    "title": "Rotate List",
    "problem": "\nGiven a linked list, rotate the list to the right by *k* places, where *k*\n is non-negative.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 1->2->3->4->5->NULL, k = 2\n**Output:** 4->5->1->2->3->NULL\n**Explanation:**\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 0->1->2->NULL, k = 4\n**Output:** 2->0->1->NULL\n**Explanation:**\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right: 0->1->2->NULL\nrotate 4 steps to the right: 2->0->1->NULL\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/61.html>\n\n\n\n```\n61\tRotate List\n\nGiven a list, rotate the list to the right by k places, where k is non-negative.\n\nExample 1:\n\nInput: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\nExplanation:\n    rotate 1 steps to the right: 5->1->2->3->4->NULL\n    rotate 2 steps to the right: 4->5->1->2->3->NULL\n\nExample 2:\n\nInput: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\n    rotate 1 steps to the right: 2->0->1->NULL\n    rotate 2 steps to the right: 1->2->0->NULL\n    rotate 3 steps to the right: 0->1->2->NULL\n    rotate 4 steps to the right: 2->0->1->NULL\n\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nFirst traverse the original linked list to get the length n of the linked list, and then take the remainder of k to n, so that k must be less than n.\n\n\nUse the fast and slow pointers to solve, the fast pointer first walks k steps, and then the two pointers go together, when the fast pointer reaches the end , The next position of the slow pointer is the head node of the new order, so that the linked list can be rotated.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Rotate\\_List {\n\n\t/\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) { val = x; }\n \\* }\n \\*/\n\tpublic class Solution {\n\t    public ListNode rotateRight(ListNode head, int k) {\n\n\t        if (head == null) {\n\t            return head;\n\t        }\n\n\t        // k could be larger than list-length\n\t        int length = 0;\n\t        ListNode p = head;\n\t        while (p != null) {\n\t            length++;\n\t            p = p.next;\n\t        }\n\n\t        // avoid circle rotate\n\t        k = k % length;\n\n\t        if (k == 0) {\n\t            return head;\n\t        }\n\n\t        // two pointers, j is k behind i\n\t        ListNode i = head;\n\t        while (k > 0) {\n\t            i = i.next;\n\t            k--;\n\t        }\n\t        ListNode j = head;\n\n\t        while (i.next != null) { // i will stop at last node, j will stop at after-rotate end node\n\n\t            i = i.next;\n\t            j = j.next;\n\t        }\n\n\t        ListNode newHead = j.next; // @note: here, hidden assumption is \"j.next != null” . eg: input: list=[1], k=0\n\t        j.next = null; // cut\n\t        i.next = head; // link\n\n\t        return newHead;\n\t    }\n\n\t}\n\n\n    public class Solution\\_make\\_circle {\n\n        public ListNode rotateRight(ListNode head, int n) {\n\n            if (head == null || head.next == null || n == 0)\n                return head;\n\n            // compare list length with k, what if k is extremely large\n            ListNode ptail = head;\n            int count = 1;\n            while (ptail.next != null) {\n                count++;\n                ptail = ptail.next;\n            }\n\n            int cutoff = count - (n % count);\n\n\n            ptail.next = head; // @note: connect head tail, making it circular list\n\n            for (int i = 0; i < cutoff; i++) {\n                ptail = ptail.next;\n            }\n\n            ListNode newhead = ptail.next;\n            ptail.next = null;\n            return newhead;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 62,
    "title": "Unique Paths",
    "problem": "\nA robot is located at the top-left corner of a *m* x *n* grid (marked 'Start'\n in the diagram below).\n\n\nThe robot can only move either down or right at any point in time. The robot is trying to\n reach the bottom-right corner of the grid (marked 'Finish' in the diagram\n below).\n\n\nHow many possible unique paths are there?\n\n\n\n![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)  \n\nAbove is a 7 x 3 grid. How many possible unique paths are there?\n\n\n\n**Note:** *m* and *n* will be at most 100.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:**\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** m = 7, n = 3\n**Output:** 28\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/62.html>\n\n\n\n```\n62\tUnique Paths\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time.\nThe robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\nAbove is a 3 x 7 grid. How many possible unique paths are there?\n\nNote: m and n will be at most 100.\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nUsing Dynamic Programming to solve, you can maintain a two-dimensional array dp, where `dp[i][j]` represents the number of different moves to the current position, and then the state transition equation can be obtained as: `dp[i][j ] = dp[i-1][j] + dp[i][j-1]`, here in order to save space, use a one-dimensional array dp, refresh line by line.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Unique\\_Paths {\n\n    class Solution {\n        public int uniquePaths(int m, int n) {\n\n            if (m <= 0 || n <= 0) {\n                return 0;\n            }\n\n            int[][] dp = new int[m][n];\n\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n\n                    if (i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else { // i,j both not 1\n                        dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                    }\n                }\n            }\n\n            return dp[m-1][n-1];\n        }\n    }\n\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 63,
    "title": "Unique Paths II",
    "problem": "\nA robot is located at the top-left corner of a *m* x *n* grid (marked 'Start'\n in the diagram below).\n\n\nThe robot can only move either down or right at any point in time. The robot is trying to\n reach the bottom-right corner of the grid (marked 'Finish' in the diagram\n below).\n\n\nNow consider if some obstacles are added to the grids. How many unique paths would there\n be?\n\n\n\n![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\n\nAn obstacle and empty space is marked as `1` and `0` respectively in\n the grid.\n\n\n**Note:** *m* and *n* will be at most 100.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n**Output:** 2\n**Explanation:**\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/63.html>\n\n\n\n```\n63\tUnique Paths II\n\nFollow up for \"Unique Paths\":\n\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\n\nFor example,\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\n\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nThe total number of unique paths is 2.\n\nNote: m and n will be at most 100.\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nUse Dynamic Programming to solve, using a two-dimensional dp array with size `(m+1) x (n+1)`, where `dp[i][j]` means reaching `(i-1, j-1)`\n\n\nThe number of different paths of the location, then the range of i and j that needs to be updated is `[1, m]` and `[1, n]`. The state transition equation is the same as the previous question, because each position can only be moved from its upper and left positions, so the current dp value is also updated by adding the upper and left dp values, as shown below Show:\n\n\n`dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n\n\nIt can be seen here that the size of the initialized d p array is `(m+1) x (n+1)`, which is for the handle edge case. When i or j is 0, subtracting 1 may be wrong. When a certain position is an obstacle, its dp value is 0, just skip the position directly. Here also need to initialize a certain value of the dp array so that it can accumulate normally. When the starting point is not an obstacle, its dp value should be 1, that is, `dp[1][1] = 1`, because it is updated from `dp[0][1] + dp[1][0]`, so two Any one of them can be initialized to 1.\n\n\nSince LeetCode updated the test case of this question later, the use of int type dp array will have an overflow error, so use `long` type array instead to avoid overflow\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Unique\\_Paths\\_II {\n\n    class Solution {\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n\n            if (obstacleGrid == null) {\n                return 0;\n            }\n\n            int m = obstacleGrid.length;\n            int n = obstacleGrid[0].length;\n\n            int[][] dp = new int[m+1][n+1];\n            dp[0][1] = 1;\n\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= n; j++) {\n\n                    if (obstacleGrid[i-1][j-1] == 0) {\n                        dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                    }\n                    // else, ==1, obstacle, skip and leave as 0\n                }\n            }\n\n            return dp[m][n];\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 64,
    "title": "Minimum Path Sum",
    "problem": "\nGiven a *m* x *n* grid filled with non-negative numbers, find a path from top\n left to bottom right which *minimizes* the sum of all numbers along its path.\n\n\n**Note:** You can only move either down or right at any point in time.\n\n\n**Example:**\n\n\n\n```\n\n**Input:**\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n**Output:** 7\n**Explanation:** Because the path 1→3→1→1→1 minimizes the sum.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/64.html>\n\n\n\n```\nGiven a m x n grid filled with non-negative numbers,\nfind a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\nExample:\n\nInput:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1→3→1→1→1 minimizes the sum.\n\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Minimum\\_Path\\_Sum {\n\n\tpublic static void main (String[] args) {\n\t\tMinimum\\_Path\\_Sum out = new Minimum\\_Path\\_Sum();\n\t\tSolution\\_recursion s = out.new Solution\\_recursion();\n\n\t\tSystem.out.println(s.minPathSum(new int[][]{ {1,3,1}, {1,5,1}, {4,2,1} }));\n\t}\n\n\tpublic class Solution {\n\t    public int minPathSum(int[][] grid) {\n\n\t        if (grid.length == 0 || grid[0].length == 0) {\n\t            return 0;\n\t        }\n\n\t        int m = grid.length;\n\t        int n = grid[0].length;\n\n\t        // dp[i][j] meaning min-sum at (i,j)\n\t        int[][] dp = new int[m][n];\n\n\t        dp[0][0] = grid[0][0];\n\n\t        // pre-process, first row and col\n\t        for (int j = 1; j < n; j++) {\n\t            dp[0][j] = dp[0][j - 1] + grid[0][j];\n\t        }\n\t        for (int i = 1; i < m; i++) {\n\t            dp[i][0] = dp[i - 1][0] + grid[i][0];\n\t        }\n\n\t        for (int i = 1; i < m; i++) {\n\t            for (int j = 1; j < n; j++) {\n\n\t                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n\t            }\n\t        }\n\n\t        return dp[m - 1][n - 1];\n\t    }\n\n\t}\n\n\n\tclass Solution\\_recursion {\n\n\t\tint min = Integer.MAX\\_VALUE;\n\n\t\tpublic int minPathSum(int[][] grid) {\n\n\t\t\tif (grid == null || grid.length == 0 || grid[0].length == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdfs (grid, 0, 0, 0);\n\t\t\treturn min;\n\t\t}\n\n\t\tprivate void dfs(int[][] grid, int i, int j, int sum) {\n\n\t\t\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {\n\t\t\t\t// out of boundary\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (i == grid.length - 1 && j == grid[0].length - 1) {\n\t\t\t\t// reaching termination position\n\t\t\t\tmin = Math.min(sum + grid[i][j], min);\n\t\t\t}\n\n\t\t\tdfs(grid, i + 1, j, sum + grid[i][j]);\n\t\t\tdfs(grid, i, j + 1, sum + grid[i][j]);\n\n\t\t\t// actually, if detour is allowed, then should probe for all 4 directions, since maybe there is a Ingeter.MIN value\n// dfs(grid, i + 1, j, sum + grid[i][j]);\n// dfs(grid, i + 1, j, sum + grid[i][j]);\n\t\t}\n\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 65,
    "title": "Valid Number",
    "problem": "\nValidate if a given string can be interpreted as a decimal number.\n\n\nSome examples:  \n\n`\"0\"` => `true`  \n\n`\" 0.1 \"` => `true`  \n\n`\"abc\"` => `false`  \n\n`\"1 a\"` => `false`  \n\n`\"2e10\"` => `true`  \n\n`\" -90e3   \"` => `true`  \n\n`\" 1e\"` => `false`  \n\n`\"e3\"` => `false`  \n\n`\" 6e-1\"` => `true`  \n\n`\" 99e2.5 \"` => `false`  \n\n`\"53.5e93\"` => `true`  \n\n`\" --6 \"` => `false`  \n\n`\"-+3\"` => `false`  \n\n`\"95a54e53\"` => `false`\n\n\n**Note:** It is intended for the problem statement to be ambiguous. You should\n gather all requirements up front before implementing one. However, here is a list of\n characters that can be in a valid decimal number:\n\n\n* Numbers 0-9\n* Exponent - \"e\"\n* Positive/negative sign - \"+\"/\"-\"\n* Decimal point - \".\"\n\n\nOf course, the context of these characters also matters in the input.\n\n\n**Update (2015-02-10):**  \n\n The signature of the `C++` function had been updated. If you still see your\n function signature accepts a `const char *` argument, please click the reload\n button to reset your code definition.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/65.html>\n\n\n\n```\n65\tValid Number\n\nValidate if a given string is numeric.\n\nSome examples:\n\"0\" => true\n\" 0.1 \" => true\n\"abc\" => false\n\"1 a\" => false\n\"2e10\" => true\nNote: It is intended for the problem statement to be ambiguous.\nYou should gather all requirements up front before implementing one.\n\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated.\nIf you still see your function signature accepts a const char * argument,\nplease click the reload button  to reset your code definition.\n\n\n```\n\nAlgorithm\n=========\n\n\nMaintain a two-dimensional dp array, where dp[i][j] represents the minimum path sum to the current position.\n\n\nNext, look for the state transition formula, because there are only two cases to reach the current position (i, j), either from the top (i-1, j) or from the left (i, j-1), we choose the dp value The smaller path is to compare dp[i-1][j] with dp[i][j-1], and add the smaller value to the current number grid[i][j], which is the current position dp value.\n\n\nHowever, some special cases need to be assigned in advance, such as the starting point position, which is directly assigned to grid[0][0], and the first row and column. The position of the first row can only come from the left, and the position of the first column The position can come from above, so these two lines should be initialized in advance, and then update from the position (1, 1) to the lower right corner.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Valid\\_Number {\n\n\tpublic static void main(String[] args) {\n\n\t\tString s = \"3\";\n\n        boolean yes = s.matches(\"^\\\\s\\*[+-]?(\\\\d+\\\\.?\\\\d\\*|\\\\d\\*\\\\.\\\\d+)(e[+-]?\\\\d+)?\\\\s\\*$\");\n\n// boolean yes = s.matches(\"\\\\de\\\\d+\");\n\n\t\tSystem.out.print(yes);\n\n\t}\n\n\tpublic class Solution {\n\t    public boolean isNumber(String s) {\n\n\t        // @note: matches()\n\t        // return s.matchAll();\n\n\t        // s.matches(\"^\\\\s\\*[+-]?(\\\\d+\\\\.?\\\\d\\*|\\\\d\\*\\\\.\\\\d+)(e[+-]?\\\\d+)?\\\\s\\*\");\n\t        return s.matches(\"^\\\\s\\*[+-]?(\\\\d+\\\\.?\\\\d\\*|\\\\d\\*\\\\.\\\\d+)(e[+-]?\\\\d+)?\\\\s\\*$\");\n\n\n\t        /\\*\n Input: \".\"\n Output: true\n Expected: false\n \\*/\n\t        // make it 2 parts, with \"e\" and without \"e\"\n\t        // return s.matches(\"^\\\\s\\*[+-]?d\\*\\\\.?\\\\d\\*\\\\s\\*$\") || s.matches(\"^\\\\s\\*[+-]?\\\\d+e[+-]?\\\\d+\\\\s\\*$\");\n\t    }\n\t}\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 66,
    "title": "Plus One",
    "problem": "\nGiven a **non-empty** array of digits representing a non-negative integer,\n plus one to the integer.\n\n\nThe digits are stored such that the most significant digit is at the head of the list, and\n each element in the array contain a single digit.\n\n\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [1,2,3]\n**Output:** [1,2,4]\n**Explanation:** The array represents the integer 123.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [4,3,2,1]\n**Output:** [4,3,2,2]\n**Explanation:** The array represents the integer 4321.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/66.html>\n\n\n\n```\nGiven a non-negative number represented as an array of digits, plus one to the number.\n\nThe digits are stored such that the most significant digit is at the head of the list.\n\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\n\nExample 1:\n\nInput: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n\nExample 2:\n\nInput: [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nIf the number at the end is 9, then there will be a carry problem, and if the number in the previous digit is still 9, you need to continue to advance. The specific algorithm is as follows:\n\n\n1. first judge whether the last digit is 9, if not, add one directly to return,\n2. if it is, then assign 0 to the digit, and then continue to check the previous digit, the same method, until the first digit is checked.\n3. If the first digit was originally 9, a new digit will be generated after adding one, then the last thing to do is to check whether the first digit after the calculation is 0, if it is, add a 1 to the top.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Plus\\_One {\n\n    public class Solution\\_clean {\n        public int[] plusOne(int[] digits) {\n            int n = digits.length;\n            for (int i = digits.length - 1; i >= 0; --i) {\n                if (digits[i] < 9) {\n                    ++digits[i];\n                    return digits;\n                }\n                digits[i] = 0; // digits[i] is 9\n            }\n            int[] res = new int[n + 1]; // only reaching here when input is straigh 9s, like [9,9,9,9,9]\n            res[0] = 1;\n            return res;\n        }\n    }\n\n    public class Solution {\n        public int[] plusOne(int[] digits) {\n\n            if (digits == null || digits.length == 0) {\n                return digits;\n            }\n\n            // just note overflow, and when carray array size +1\n            int carry = 1; // initate as 1, as to the \"plus one\"\n\n            for (int i = digits.length - 1; i >= 0; i--) {\n\n                int add = carry + digits[i];\n\n                if (add >= 10) {\n                    carry = add / 10;\n                    add = add % 10;\n                } else {\n                    carry = 0;\n                }\n\n                digits[i] = add;\n            }\n\n            // final check\n            if (carry > 0) {\n                // increase int[] size\n                int[] sizePlusOne = new int[digits.length + 1];\n                sizePlusOne[0] = carry;\n\n                // fill the rest\n                for (int i = 1; i < sizePlusOne.length; i++) {\n                    sizePlusOne[i] = digits[i - 1];\n                }\n\n                digits = sizePlusOne;\n            }\n            // System.out.println(Arrays.toString(digits));\n            return digits;\n        }\n    }\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 67,
    "title": "Add Binary",
    "problem": "\nGiven two binary strings, return their sum (also a binary string).\n\n\nThe input strings are both **non-empty** and contains only characters\n `1` or `0`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** a = \"11\", b = \"1\"\n**Output:** \"100\"\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** a = \"1010\", b = \"1011\"\n**Output:** \"10101\"\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/67.html>\n\n\n\n```\n67\tAdd Binary\n\nGiven two binary strings, return their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".\n\n\n```\n\nAlgorithm\n=========\n\n\nWhen adding each bit, there may be a carry, which will affect the result of the subsequent addition. And the length of the two input strings may also be different. At this time, we need to create a new string, whose length is the larger of the two input strings, and add the character ‘0’ to the beginning of the shorter input string to fill the larger length. At this time, the characters are taken out from the end of the two strings one by one, and then converted into numbers, and added. If it is greater than or equal to 2, mark the carry flag carry, and add a character ‘0’ to the new string.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.math.BigInteger;\n\npublic class Add\\_Binary {\n\n\tpublic class Solution {\n\t    public String addBinary(String a, String b) {\n\n\t        if (a == null || b == null || a.length() == 0 || b.length() == 0) {\n\t            return \"\";\n\t        }\n\n\t        // swap to a is longer than b\n\t        if (a.length() < b.length()) {\n\t            return addBinary(b, a);\n\t        }\n\n\t        String result = \"\";\n\t        int carry = 0;\n\t        int add = -1; // each position add up\n\n\t        int i = a.length() - 1; // pointer of string a\n\t        int j = b.length() - 1; // pointer of string b\n\n\t        while (j >= 0 || i >= 0) {\n\t            add = (a.charAt(i) - '0') + (j < 0? 0 : (b.charAt(j) - '0')) + carry;\n\n\t            if (add >= 2) {\n\t                carry = add / 2;\n\t                add = add % 2;\n\t            } else {\n\t                carry = 0;\n\t            }\n\n\t            result = add + result;\n\n\t            i--;\n\t            j--;\n\t        }\n\n\t        // final check\n\t        if (carry > 0) {\n\t            result = carry + result;\n\t        }\n\n\t        return result;\n\t    }\n\t}\n\n\tpublic class Solution\\_BigInteger { // actually, still possible overflow, just passed OJ test cases\n\t\tpublic String addBinary(String a, String b) {\n\t\t\tif (a == null || b == null)\n\t\t\t\treturn \"\";\n\t\t\tif (a.length() == 0)\n\t\t\t\treturn b;\n\t\t\tif (b.length() == 0)\n\t\t\t\treturn a;\n\n\t\t\t// easily overflow\n\t\t\t// int a = Integer.parseInt(a);\n\n\t\t\tBigInteger aa = new BigInteger(a, 2);\n\t\t\tBigInteger bb = new BigInteger(b, 2);\n\n\t\t\tBigInteger add = aa.add(bb);\n\n\t\t\treturn add.toString(2);\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 68,
    "title": "Text Justification",
    "problem": "\nGiven an array of words and a width *maxWidth*, format the text such that each\n line has exactly *maxWidth* characters and is fully (left and right) justified.\n\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in\n each line. Pad extra spaces `' '` when necessary so that each line has\n exactly *maxWidth* characters.\n\n\nExtra spaces between words should be distributed as evenly as possible. If the number of\n spaces on a line do not divide evenly between words, the empty slots on the left will be\n assigned more spaces than the slots on the right.\n\n\nFor the last line of text, it should be left justified and no **extra** space is\n inserted between words.\n\n\n**Note:**\n\n\n* A word is defined as a character sequence consisting of non-space characters\n only.\n* Each word's length is guaranteed to be greater than 0 and not exceed *maxWidth*.\n* The input array `words` contains at least one word.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nmaxWidth = 16\n**Output:**\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\n**Output:**\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n**Explanation:** Note that the last line is \"shall be    \" instead of \"shall     be\",\n             because the last line must be left-justified instead of fully-justified.\n             Note that the second line is also left-justified becase it contains only one word.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:**\nwords = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\n         \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\nmaxWidth = 20\n**Output:**\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/68.html>\n\n\n\n```\n68\tText Justification\n\nGiven an array of words and a length L, format the text such that each line has exactly L characters\nand is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line.\nPad extra spaces ' ' when necessary so that each line has exactly L characters.\n\nExtra spaces between words should be distributed as evenly as possible.\nIf the number of spaces on a line do not divide evenly between words,\nthe empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is inserted between words.\n\nFor example,\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nL: 16.\n\nReturn the formatted lines as:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\nNote: Each word is guaranteed not to exceed L in length.\n\nCorner Cases:\nA line other than the last line might contain only one word. What should you do in this case?\nIn this case, that line should be left-justified.\n\n\n```\n\nAlgorithm\n=========\n\n\nUse the `greedy` approach.\n\n\nMaintain a line of words and each time try to add a new word followed by a space. If adding a new word (without adding another space) will cause the total width to exceed `maxWidth`, then the new word can’t be added to the current line, so do text justification for the current line, add the jusitified current line to the result list, and add the new word followed by a space in a new line.\n\n\nWhen do justification,\n\n\n1. first remove the last space in the line,\n2. and then calculate the number of spaces to be added between each pair of words.\n\n\nCalculate the remaining spaces and the remaining splits, where the remaining splits equals the number of words in the line minus 1. For each split from right to left, the number of spaces to be added equals the remaining spaces divided by the remaining splits (use integer division). Add the spaces and update the remaining spaces and the remaining splits. Do the process until the remaining spaces becomes 0.\n\n\nFor the last line, remove the last space in the line, and append spaces at the end until the last line’s width equals *maxWidth*.\n\n\nFinally, return the result list.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Text\\_Justification {\n\n    public static void main(String[] args) {\n\n        Text\\_Justification out = new Text\\_Justification();\n        Solution one = out.new Solution();\n\n\n        System.out.println(one.fullJustify(new String[]{\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"}, 16));\n        System.out.println(one.fullJustify(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"}, 1));\n        System.out.println(one.fullJustify(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"}, 3));\n\n    }\n\n    public class Solution {\n        public List<String> fullJustify(String[] words, int maxWidth) {\n            int left = 0; List<String> result = new ArrayList<>();\n\n            while (left < words.length) {\n                int right = findRight(left, words, maxWidth);\n                result.add(justify(left, right, words, maxWidth));\n                left = right + 1;\n            }\n\n            return result;\n        }\n\n        private int findRight(int left, String[] words, int maxWidth) {\n            int right = left;\n            int sum = words[right++].length();\n\n            while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\n                sum += 1 + words[right++].length();\n\n            return right - 1;\n        }\n\n        private String justify(int left, int right, String[] words, int maxWidth) {\n            if (right - left == 0) return padResult(words[left], maxWidth);\n\n            boolean isLastLine = right == words.length - 1;\n            int numSpaces = right - left;\n            int totalSpace = maxWidth - wordsLength(left, right, words);\n\n            String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\n            int remainder = isLastLine ? 0 : totalSpace % numSpaces;\n\n            StringBuilder result = new StringBuilder();\n            for (int i = left; i <= right; i++)\n                result.append(words[i])\n                    .append(space)\n                    .append(remainder-- > 0 ? \" \" : \"\");\n\n            return padResult(result.toString().trim(), maxWidth);\n        }\n\n        private int wordsLength(int left, int right, String[] words) {\n            int wordsLength = 0;\n            for (int i = left; i <= right; i++) wordsLength += words[i].length();\n            return wordsLength;\n        }\n\n        private String padResult(String result, int maxWidth) {\n            return result + blank(maxWidth - result.length());\n        }\n\n        private String blank(int length) {\n            return new String(new char[length]).replace('\\0', ' ');\n        }\n\n    }\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 69,
    "title": "Sqrt(x)",
    "problem": "\nImplement `int sqrt(int x)`.\n\n\nCompute and return the square root of *x*, where *x* is guaranteed to\n be a non-negative integer.\n\n\nSince the return type is an integer, the decimal digits are truncated and only the\n integer part of the result is returned.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 4\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 8\n**Output:** 2\n**Explanation:** The square root of 8 is 2.82842..., and since\n             the decimal part is truncated, 2 is returned.\n\n```\n\n\n### \n\n",
    "explanation": "Not Populated Yet."
  },
  {
    "id": 70,
    "title": "Climbing Stairs",
    "problem": "\nYou are climbing a stair case. It takes *n* steps to reach to the top.\n\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the\n top?\n\n\n**Note:** Given *n* will be a positive integer.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/70.html>\n\n\n\n```\n70\tClimbing Stairs\n\nYou are climbing a stair case. It takes n steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nNote: Given n will be a positive integer.\n\nExample 1:\n\nInput: 2\nOutput:  2\nExplanation:  There are two ways to climb to the top.\n                1. 1 step + 1 step\n                2. 2 steps\n\nExample 2:\n\nInput: 3\nOutput:  3\nExplanation:  There are three ways to climb to the top.\n                1. 1 step + 1 step + 1 step\n                2. 1 step + 2 steps\n                3. 2 steps + 1 step\n\n@tag-dp\n\n```\n\nAlgorithm\n=========\n\n\nYou can only climb 1 or 2 steps at a time, so the method to climb to the nth layer is either from the n-1 layer one step up, or from the n-2 layer 2 steps up, so the recursive formula is very easy We get: dp[n] = dp[n-1] + dp[n-2].\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Climbing\\_Stairs {\n\n\tpublic class Solution {\n\t    public int climbStairs(int n) {\n\n\t        if (n <= 0) {\n\t            return 0;\n\t        }\n\n\t        // dp[i], ways to i\n\t        int[] dp = new int[n + 1];\n\n\t        dp[0] = 1; // to make dp[2] correct when adding up\n\t        dp[1] = 1;\n\n\t        for (int i = 2; i <= n; i++) {\n\t            dp[i] = dp[i - 1] + dp[i - 2];\n\t        }\n\n\t        return dp[n];\n\t    }\n\t}\n\n\n\t/\\*\n Time complexity : O(2^n)\n Size of recursion tree will be 2^n\n \\*/\n\tclass Solution\\_recursive\\_cache {\n\t\tpublic int climbStairs(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tint[] cache = new int[n + 1];\n\t\t\treturn dfs(n, 0, cache);\n\t\t}\n\n\t\tprivate int dfs(int n, int current, int[] cache) {\n\n\t\t\tif (current > n) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (current == n) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (cache[current] > 0) {\n\t\t\t\treturn cache[current];\n\t\t\t}\n\n\t\t\tint combinations = dfs(n, current + 1, cache) + dfs(n, current + 2, cache);\n\t\t\tcache[current] = combinations;\n\n\t\t\treturn combinations;\n\t\t}\n\t}\n\n\n\t/\\*\n Time complexity : O(2^n)\n Size of recursion tree will be 2^n\n\n ref: https://leetcode.com/problems/climbing-stairs/solution/\n \\*/\n\tclass Solution\\_recursive {\n\t\tpublic int climbStairs(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn dfs(n, 0);\n\t\t}\n\n\t\tprivate int dfs(int n, int current) {\n\n\t\t\tif (current > n) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (current == n) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn dfs(n, current + 1) + dfs(n, current + 2);\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 71,
    "title": "Simplify Path",
    "problem": "\nGiven an **absolute path** for a file (Unix-style), simplify it. Or in other\n words, convert it to the **canonical path**.\n\n\nIn a UNIX-style file system, a period `.` refers to the current directory.\n Furthermore, a double period `..` moves the directory up a level. For more\n information, see: [Absolute path vs relative path in Linux/Unix](https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/)\n\n\n\nNote that the returned canonical path must always begin with a slash `/`, and\n there must be only a single slash `/` between two directory names. The\n last directory name (if it exists) **must not** end with a trailing `/`.\n Also, the canonical path must be the **shortest** string representing the\n absolute path.\n\n\n \n\n\n**Example 1:**\n\n\n\n```\n\n**Input: \"**/home/\"\n**Output: \"**/home\"\n**Explanation:** Note that there is no trailing slash after the last directory name.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input: \"**/../\"\n**Output: \"**/\"\n**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input: \"**/home//foo/\"\n**Output: \"**/home/foo\"\n**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one.\n\n```\n\n**Example 4:**\n\n\n\n```\n\n**Input: \"**/a/./b/../../c/\"\n**Output: \"**/c\"\n\n```\n\n**Example 5:**\n\n\n\n```\n\n**Input: \"**/a/../../b/../c//.//\"\n**Output: \"**/c\"\n\n```\n\n**Example 6:**\n\n\n\n```\n\n**Input: \"**/a//b////c/d//././/..\"\n**Output: \"**/a/b/c\"\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/71.html>\n\n\n\n```\n71\tSimplify Path\n\nGiven an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\nclick to show corner cases.\n\nCorner Cases:\n    Did you consider the case where path = \"/../\"?\n        In this case, you should return \"/\".\n    Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\n        In this case, you should ignore redundant slashes and return \"/home/foo\".\n\n@tag-stack\n\n```\n\nAlgorithm\n=========\n\n\nAccording to the example given in the title, it is really not easy to summarize the rules. Two more examples should be added `path = \"/a/./b/../c/\", => \"/a/c\"` and `path = \"/a/./b/c/\", => \"/a/b/c\"`.\n\n\nWe can know the “.” in the middle and delete it directly, and delete it when it is “..” path next to it, and in some cases given by the following boundary conditions, it can be known that if it is empty, “/” is returned, and if there are multiple “/”, only one is retained. Then we can take the path as a number of substrings separated by one or more “/”, and extract them one by one.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Stack;\n\npublic class Simplify\\_Path {\n\n\tpublic class Solution {\n\t    public String simplifyPath(String path) {\n\n\t        if (path == null || path.length() == 0) {\n\t            return path;\n\t        }\n\n\t        String result = \"\";\n\n\t        String[] array = path.split(\"/\");\n\t        Stack<String> sk = new Stack<>();\n\n\t        int i = 0;\n\t        while (i < array.length) {\n\n\t            if (array[i].equals(\"..\")) {\n\t                if (!sk.isEmpty()) {\n\t                    sk.pop();\n\t                }\n\t            } else if (!array[i].equals(\".\") && !array[i].equals(\"\")) {\n\t                sk.push(array[i]);\n\t            }\n\n\t            i++;\n\t        }\n\n\t        // @note: I missed this one\n\t        if (sk.isEmpty())   return \"/\";\n\n\t        while (!sk.isEmpty()) {\n\t            result = \"/\" + sk.pop() + result;\n\t        }\n\n\t        return result;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 72,
    "title": "Edit Distance",
    "problem": "\nGiven two words *word1* and *word2*, find the minimum number of operations\n required to convert *word1* to *word2*.\n\n\nYou have the following 3 operations permitted on a word:\n\n\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** word1 = \"horse\", word2 = \"ros\"\n**Output:** 3\n**Explanation:**\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** word1 = \"intention\", word2 = \"execution\"\n**Output:** 5\n**Explanation:**\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/72.html>\n\n\n\n```\n72\tEdit Distance\n\nGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\n\nYou have the following 3 operations permitted on a word:\n\na) Insert a character\nb) Delete a character\nc) Replace a character\n\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation:\n    horse -> rorse (replace 'h' with 'r')\n    rorse -> rose (remove 'r')\n    rose -> ros (remove 'e')\n\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation:\n    intention -> inention (remove 't')\n    inention -> enention (replace 'i' with 'e')\n    enention -> exention (replace 'n' with 'x')\n    exention -> exection (replace 'n' with 'c')\n    exection -> execution (insert 'u')\n\n\n```\n\nAlgorithm\n=========\n\n\n### DFS\n\n\nFor the two characters `word1[i]` and `word2[j]` currently compared, if they are the same, skip to the next position directly.\n\n\nIf they are not the same, there are three treatment methods,\n\n\n* First, insert a `word2[j]` directly, then the character at `word2[j]` will be skipped, and then compare `word1[i]` and `word2[j+1]`.\n* The second method is to delete, that is, delete the characters in `word1[i]` directly, and then compare `word1[i+1]` and `word2[j]`.\n* The third is to modify `word1[i]` to `word2[j]`, and then compare `word1[i+1]` and `word[j+1]`.\n\n\nAt this point in the analysis, you can write the recursive code directly, but unfortunately it will be `Time Limited Exceed`, so the time complexity must be optimized, and a large amount of repeated calculations need to be removed.\n\n\nHere, the memory array memo is used to save the calculated state, so that you can Through OJ, note that the insertCnt, deleteCnt, and replaceCnt here just indicate that the current corresponding position uses insert, delete, and replace operations, respectively. The overall return minimum distance, the latter position will still call recursion to return the smallest\n\n\n### DP\n\n\nHere we need to maintain a two-dimensional array dp, whose size is m\\*n, and m and n are the lengths of word1 and word2 respectively.\n\n\n`dp[i][j]` represents the steps required to convert from the first i characters of word1 to the first j characters of word2. First assign a value to the first row and first column of the two-dimensional array dp.\n\n\nThis is very simple, because there is always a string corresponding to the first row and the first column that is an empty string, so the conversion step is completely the length of another string . Similar to the previous DP problem, the difficulty lies in finding the state transition equation. Take an example. For example, word1 is “bbc” and word2 is “abcd”. You can get the dp array as follows:\n\n\n\n```\n  Ø a b c d\nØ 0 1 2 3 4\nb 1 1 1 2 3\nb 2 2 1 2 3\nc 3 3 2 1 2\n\n```\n\nWhen `word1[i] == word2[j]`, `dp[i][j] = dp[i-1][j-1]`, in other cases, `dp[i][j]` is its left and upper left, The minimum value of the three values above is increased by 1. In fact, the left, top, and top left here correspond to the addition, deletion, and modification operations respectively. For details, please refer to the explanation part of the first solution, then the state transition equation can be obtained as\n\n\n\n```\ndp[i][j] =      /    dp[i - 1][j - 1]                                                                   if word1[i - 1] == word2[j - 1]\n\n                  \\    min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1            else\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Edit\\_Distance {\n\n\tpublic class Solution {\n\t    public int minDistance(String w1, String w2) {\n\n\t        if (w1 == null || w2 == null) {\n\t            return 0;\n\t        }\n\n\t        // dp[i][j]\n\t        int[][] dp = new int[w1.length() + 1][w2.length() + 1];\n\n\t        // initiation\n\t        // dp[0][0] = 0;\n\t        for (int i = 1; i < w2.length() + 1; i++) {\n\t            // case when w1 is empty string\n\t            dp[0][i] = i;\n\t        }\n\t        for (int i = 1; i < w1.length() + 1; i++) {\n\t            // case when w2 is empty string\n\t            dp[i][0] = i;\n\t        }\n\n\t        for (int i = 1; i < w1.length() + 1; i++) {\n\t            for (int j = 1; j < w2.length() + 1; j++) {\n\n\t                if (w1.charAt(i - 1) == w2.charAt(j - 1)) {\n\t                    dp[i][j] = dp[i - 1][j - 1];\n\t                } else {\n\t                    int tmpMin = Math.min(dp[i - 1][j], dp[i][j - 1]);\n\t                    tmpMin = Math.min(tmpMin, dp[i - 1][j - 1]);\n\t                    dp[i][j] = 1 + tmpMin;\n\t                }\n\t            }\n\t        }\n\n\t        return dp[w1.length()][w2.length()];\n\t    }\n\t}\n\n\n\t// recursion method, \"Time Limit Exceeded\"\n\tpublic class Solution\\_recursion {\n\n\t    public int minDistance(String w1, String w2) {\n\n\t        if (w1.length() == 0 || w1 == null)   return w2.length();\n\t        if (w2.length() == 0 || w2 == null)   return w1.length();\n\n\t        if (w1.length() > w2.length())      return minDistance(w2, w1);\n\n\t        if (w1.charAt(0) == w2.charAt(0)) {\n\n\t            return minDistance(w1.substring(1), w2.substring(1)); // @note: this is the min possible, no need to try the other 2 possibility (i+1,j) or (i,j+1)\n\t        }\n\n\t        else {\n\t            int delete = minDistance(w1, w2.substring(1)) + 1;\n\t            int replace = minDistance(w1.substring(1), w2.substring(1)) + 1;\n\n\t            return Math.min(delete, replace);\n\t        }\n\t    }\n\t}\n\n\tclass Solution\\_recursion2 {\n\t\tint min = Integer.MAX\\_VALUE;\n\n\t\tpublic int minDistance(String word1, String word2) {\n\t\t\tif (word1 == null || word2 == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (word1.length() > word2.length()) {\n\t\t\t\treturn minDistance(word2, word1);\n\t\t\t}\n\n\t\t\tdfs(word1, word2, 0, 0, 0);\n\t\t\treturn min;\n\t\t}\n\n\t\tprivate void dfs(String word1, String word2, int i, int j, int count) {\n\n// System.out.println(\"i:\"+i+\", j:\"+j);\n\n\t\t\t// word1 is the shorter string\n\t\t\tif (i == word1.length()) { // reaching end\n\n\t\t\t\tint distance = count + word2.length() - j;\n\t\t\t\tmin = Math.min(min, distance);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (j == word2.length()) { // @note: case: 'aaaaaaa', 'ab', now i is larger than j\n\t\t\t\tint distance = count + word1.length() - i;\n\t\t\t\tmin = Math.min(min, distance);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (i > word1.length() || j > word2.length()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint extra = word1.charAt(i) == word2.charAt(j) ? 0: 1;\n\n\t\t\tdfs(word1, word2, i + 1, j, count + 1);\n\t\t\tdfs(word1, word2, i, j + 1, count + 1);\n\t\t\tdfs(word1, word2, i + 1, j + 1, count + extra);\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 73,
    "title": "Set Matrix Zeroes",
    "problem": "\nGiven a *m* x *n* matrix, if an element is 0, set its entire row and column to\n 0. Do it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).\n \n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n**Output:**\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n**Output:**\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n\n```\n\n**Follow up:**\n\n\n* A straight forward solution using O(*m**n*) space is probably a bad idea.\n* A simple improvement uses O(*m* + *n*) space, but still not the best\n solution.\n* Could you devise a constant space solution?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/73.html>\n\n\n\n```\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n\nExample 1:\n\nInput:\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\nOutput:\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n\nExample 2:\n\nInput:\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\nOutput:\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n\n\nclick to show follow up.\n\nFollow up:\n    Did you use extra space?\n    A straight forward solution using O(mn) space is probably a bad idea.\n    A simple improvement uses O(m + n) space, but still not the best solution.\n    Could you devise a constant space solution?\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nThe requirement of this question is to use O(1) space, then we cannot create a new array. We consider using the first row and first column of the original array to record whether each row and column has 0.\n\n\n* Scan the first row and first column first, if there is 0, set the respective flag to true\n* Then scan to remove the entire array of the first row and first column, if there is 0, assign 0 to the corresponding number in the first row and first column\n* Traverse the entire array again except the first row and first column. If one of the corresponding numbers in the first row and the first column is 0, assign the current value to 0\n* Finally update the first row and first column according to the flag in the first row and first column\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Set\\_Matrix\\_Zeroes {\n\n\tpublic class Solution {\n\t    public void setZeroes(int[][] matrix) {\n\n\t        if (matrix == null || matrix.length == 0) {\n\t            return;\n\t        }\n\n\t        int m = matrix.length;\n\t        int n = matrix[0].length;\n\n\t        // use first row and first column as marker\n\t        // first row/col itself 0 or not? use a boolean flag\n\t        boolean isFirstRowZero = false;\n\t        boolean isFirstColZero = false;\n\n\t        for (int i = 0; i < n; i++) {\n\t            if (matrix[0][i] == 0) {\n\t                isFirstRowZero = true;\n\t                break;\n\t            }\n\t        }\n\n\t        for (int i = 0; i < m; i++) {\n\t            if (matrix[i][0] == 0) {\n\t                isFirstColZero = true;\n\t                break;\n\t            }\n\t        }\n\n\t        for (int i = 1; i < m; i++) {\n\t            for (int j = 1; j < n; j++) {\n\t                if (matrix[i][j] == 0) {\n\n\t                    matrix[0][j] = 0;\n\t                    matrix[i][0] = 0;\n\t                }\n\t            }\n\t        }\n\n\t        // set 0: rest first, first-row/col last\n\t        for (int col = 1; col < n; col++) {\n\t            if (matrix[0][col] == 0) {\n\n\t                int i = 1;\n\t                while (i < m) {\n\t                    matrix[i][col] = 0;\n\t                    i++;\n\t                }\n\t            }\n\t        }\n\t        for (int row = 1; row < m; row++) {\n\t            if (matrix[row][0] == 0) {\n\n\t                int j = 1;\n\t                while (j < n) {\n\t                    matrix[row][j] = 0;\n\t                    j++;\n\t                }\n\t            }\n\t        }\n\n\t        if (isFirstRowZero) {\n\t            int j = 0;\n\t            while (j < n) {\n\t                matrix[0][j] = 0;\n\t                j++;\n\t            }\n\t        }\n\t        if (isFirstColZero) {\n\t            int i = 0;\n\t            while (i < m) {\n\t                matrix[i][0] = 0;\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 74,
    "title": "Search a 2D Matrix",
    "problem": "\nWrite an efficient algorithm that searches for a value in an *m* x *n* matrix.\n This matrix has the following properties:\n\n\n* Integers in each row are sorted from left to right.\n* The first integer of each row is greater than the last integer of the previous row.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\n**Output:** false\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/74.html>\n\n\n\n```\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\nIntegers in each row are sorted from left to right.\nThe first integer of each row is greater than the last integer of the previous row.\nFor example,\n\nExample 1:\n\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\nOutput: true\n\n\nExample 2:\n\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\nOutput: false\n\n@tag-array\n@tag-binarysearch\n\n```\n\nAlgorithm\n=========\n\n\nIt is also possible to use double pointers, `i` points to 0, `j` points to the number of columns, so the first number to be verified is the number in the upper right corner of the two-dimensional array.\n\n\n* If this number is equal to target, return true directly;\n* if it is greater than target, it means to decrease For small numbers, the number of columns j will decrease by 1;\n* if it is less than target, it means that the number should be increased, and the number of rows i will increase by 1.\n* If the while loop exits and the target is not found, return false directly\n\n\n### Note\n\n\nTried two options:\n\n\n1. The diagonal line from the upper left to the lower right is the baseline to find, because this diagonal is the CLP after the matrix is flattened into a sorted list. But no, moving `row+1` or `col-1` will skip possible targets\n2. Then I tried again. The first column is a binary search first, and then a binary search of the target row. Similarly, some targets may be skipped, when the pointer is +1 or -1\n\n\nThe key is to find a turning point, a certain point, the front is smaller than him, and the back is bigger than him: in this question, it is the point in the upper right corner.\n\n\nThe same is true for the lower left corner.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Search\\_a\\_2D\\_Matrix {\n\n    class Solution\\_binarySearch {\n        public boolean searchMatrix(int[][] matrix, int target) {\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n                return false;\n            }\n\n            int left = 0, right = matrix.length;\n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (matrix[mid][0] == target) return true;\n                if (matrix[mid][0] < target) left = mid + 1;\n                else right = mid;\n            }\n\n            int tmp = (right > 0) ? (right - 1) : right;\n            left = 0;\n            right = matrix[tmp].length;\n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (matrix[tmp][mid] == target) return true;\n                if (matrix[tmp][mid] < target) left = mid + 1;\n                else right = mid;\n            }\n            return false;\n\n        }\n    }\n\n    public class Solution {\n        public boolean searchMatrix(int[][] m, int target) {\n\n            if (m == null || m.length == 0)     return false;\n            if (m[0].length == 0)   return false;\n\n            // start from top right\n            int i = 0, j = m[0].length - 1;\n\n            while (i < m.length && j >= 0) {\n\n                if (target > m[i][j])   i++;\n                else if (target < m[i][j])  j--;\n                else    return true;\n            }\n\n            return false;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\nAlgorithm - binary search\n=========================\n\n\nSince the matrix is sorted ascending in each row, and the first integer of each row is greater than the last integer of the previous row, the *m* x *n* matrix can be `reshaped to a 1D array`, where each row is concatenated after the previous row, and binary search can be done on the 1D array.\n\n\nIn practice, the reshape procedure is not necessary and only the idea needs to be used. Initially, set `low` to be 0 and `high` to be `m x n - 1`. The loop condition is `low <= high`. Each time, select `mid` to be the average of `low` and `high`, find the row and the column according to `mid`, and check the number. The rest procedure is the same as binary search.\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nclass Solution\\_2d\\_to\\_1d {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\n            return false;\n        int rows = matrix.length;\n        int columns = matrix[0].length;\n        int low = 0;\n        int high = rows \\* columns - 1;\n        while (low <= high) {\n            int mid = (high - low) / 2 + low;\n            int num = matrix[mid / columns][mid % columns];\n            if (num == target)\n                return true;\n            else if (num > target)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return false;\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 75,
    "title": "Sort Colors",
    "problem": "\nGiven an array with *n* objects colored red, white or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**so\n that objects of the same color are adjacent, with the colors in the order red, white and\n blue.\n\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue\n respectively.\n\n\n**Note:** You are not suppose to use the library's sort function for\n this problem.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [2,0,2,1,1,0]\n**Output:** [0,0,1,1,2,2]\n```\n\n**Follow up:**\n\n\n* A rather straight forward solution is a two-pass algorithm using counting sort.  \n\n First, iterate the array counting number of 0's, 1's, and 2's, then\n overwrite array with total number of 0's, then 1's and followed by 2's.\n* Could you come up with a one-pass algorithm using only constant space?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/75.html>\n\n\n\n```\nGiven an array with n objects colored red, white or blue,\nsort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\nExample:\n\nInput: [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\n\nNote:\nYou are not suppose to use the library's sort function for this problem.\n\nclick to show follow up.\n\nFollow up:\n    A rather straight forward solution is a two-pass algorithm using counting sort.\n    First, iterate the array counting number of 0's, 1's, and 2's,\n    then overwrite array with total number of 0's, then 1's and followed by 2's.\n\n    Could you come up with an one-pass algorithm using only constant space?\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\n### Freq stats\n\n\nThe essence of this question is still a sorting question. The question gives a hint that it can be sorted by counting. You need to traverse the array twice. Then let’s look at this method first. Because there are only three different elements in the array, it is very easy to implement. easy.\n\n\n1. First traverse the original array and record the numbers of 0, 1, and 2 respectively.\n2. Then update the original array and assign 0, 1, 2 according to the number.\n\n\n### Two pointers\n\n\nIn the problem, it is necessary to traverse the array `only once` to solve it, so you need to use a double pointer to do it, and move from the beginning and the end of the original array to the center.\n\n\n1. Define the red pointer to point to the beginning and the blue pointer to point to the end.\n2. Traverse the original array from the beginning,\n\t* if it encounters 0, exchange the value and the value pointed to by the red pointer, and move the red pointer one bit backward.\n\t* If it encounters 2, exchange the value and the value pointed to by the blue pointer, and move the blue pointer forward one bit. If it encounters 1, continue to traverse.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\n\npublic class Sort\\_Colors {\n\n\tpublic static void main(String[] args) {\n\t\tSort\\_Colors out = new Sort\\_Colors();\n\t\tSolution s = out.new Solution();\n\n\t\ts.sortColors(new int[]{0, 0});\n\t}\n\n\tpublic class Solution {\n\t    public void sortColors(int[] nums) {\n\t        if (nums == null || nums.length == 0) {\n\t            return;\n\t        }\n\n\t        // idea is: move all \"2\" to end, all \"0\" front, then 1 is done itself\n\t        // 3 pointers, last-0, current scan, first-2\n\n\t        int p0 = 0; // last-0\n\t        int p2 = nums.length - 1;\n\t        int p = 0; // scan pointer\n\n\t        while (p <= p2) {\n\n\t            if (nums[p] == 0) {\n\n\t                // swap 0 to front. eg: 0,1,1,1,1,1,1,0. or: 0,0,0,0,0,1\n\n\t                int tmp = nums[p0];\n\t                nums[p0] = nums[p];\n\t                nums[p] = tmp;\n\n\t                p0++;\n\t                p++;\n\n\t            } else if (nums[p] == 2) {\n\t                // swap \"2\" to end\n\t                int tmp = nums[p2];\n\t                nums[p2] = nums[p];\n\t                nums[p] = tmp;\n\n\t                p2--;\n\t            } else { // assumption: only 0,1,2, so here nums[p]==1\n\t                p++;\n\t            }\n\t        }\n\t    }\n\t}\n\n\tpublic void sortColors(int[] A) {\n\t    if(A==null || A.length==0)\n\t        return;\n\t    int idx0 = 0;\n\t    int idx1 = 0;\n\t    for(int i=0;i<A.length;i++)\n\t    {\n\t        if(A[i]==0)\n\t        {\n\t            A[i] = 2;\n\t            A[idx1++] = 1;\n\t            A[idx0++] = 0;\n\t        }\n\t        else if(A[i]==1)\n\t        {\n\t            A[i] = 2;\n\t            A[idx1++] = 1;\n\t        }\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 76,
    "title": "Minimum Window Substring",
    "problem": "\nGiven a string S and a string T, find the minimum window in S which will contain all the\n characters in T in complexity O(n).\n\n\n**Example:**\n\n\n\n```\n\n**Input: S** = \"ADOBECODEBANC\", **T** = \"ABC\"\n**Output:** \"BANC\"\n\n```\n\n**Note:**\n\n\n* If there is no such window in S that covers all characters in T, return the empty string\n `\"\"`.\n* If there is such window, you are guaranteed that there will always be only one unique\n minimum window in S.\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/76.html>\n\n\n\n```\n76. Minimum Window Substring\n\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n\nFor example,\nS = \"ADOBECODEBANC\"\nT = \"ABC\"\nMinimum window is \"BANC\".\n\nNote:\nIf there is no such window in S that covers all characters in T, return the empty string \"\".\n\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n\n\n```\n\nAlgorithm\n=========\n\n\nSwipe directly from one direction on the left.\n\n\n1 . The key point is how to move the left pointer when scanning a string. The i in for is equivalent to the right pointer.\nMove left to the char in the first target, while ensuring that the found number of this char is greater than the number in the target\n\n\n2 . The question of when to compare with min, I started with the same length as count and target, so I directly compared with min\nThis is wrong. For example, AAAABC, count is equal only when it reaches C, but you must shrink first, and then compare with min\n\n\n3 . When the while loop moves to the left, `found[s.charAt(left)]> 1`, I wrote it wrong, not `1`, but the number required in the target `found[s.charAt(left)]> target[s.charAt(left)`\n\n\n* Must be `greater than`, because entering while requires –, - and then it is exactly equal to what target needs\n\n\n4 . The processing of result, at the beginning I wrote two ints to record the position of the smallest window. In fact, you can directly write a string to be initially empty, and assign min every time\n\n\n* This way, you don’t need to judge whether int is negative or not, to see if there are results.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Minimum\\_Window\\_Substring {\n\n    public static void main(String[] args) {\n        Minimum\\_Window\\_Substring out = new Minimum\\_Window\\_Substring();\n        Solution s = out.new Solution();\n\n        System.out.println(s.minWindow(\"ADOBECODEBANC\", \"ABC\")); // output: \"BANC\"\n    }\n\n    public class Solution\\_easy\\_understand {\n        public String minWindow(String s, String t) {\n\n            if (s == null || t == null || s.length() == 0) {\n                return \"\";\n            }\n\n            // left,right pointing to window range\n            int left = 0; // left\n            int right = 0; // right\n\n            int[] foundMap = new int[256]; // count of each char in this window range\n            int[] targetMap = new int[256];\n\n            int countInRange = 0;\n            int neededInRange = t.length();\n\n            int minSize = Integer.MAX\\_VALUE;\n            String result = \"\";\n\n            // pre-process\n            for (int i = 0; i < t.length(); i++) {\n\n                char current = t.charAt(i);\n\n                targetMap[current]++;\n            }\n\n            // start scanning\n            while (right < s.length()) {\n                char c = s.charAt(right);\n\n                if (targetMap[c] > 0) {\n\n                    if (foundMap[c] < targetMap[c]) {\n                        countInRange++;\n                    }\n                    foundMap[c]++;\n\n                    // if all found in s, record window size\n                    if (countInRange == neededInRange) {\n\n                        // eg: \"ADOBBECAODEBANNNNC\" . when at 2nd \"A\", will enter this if, and do the shrink first, the check min\n                        while (\n                            left < s.length()\n                            &&\n                            (\n                                targetMap[s.charAt(left)] == 0 // not in target[]\n                                || (targetMap[s.charAt(left)] > 0 && foundMap[s.charAt(left)] > targetMap[s.charAt(left)]) // more than needed in target[]\n                            )\n                        ) {\n                            // @review: June-21-2016, \"(targetMap[s.charAt(l)] > 0\" NOT necessary, since statement before || is covering it\n\n                            foundMap[s.charAt(left)]--;\n\n                            // @note: no need to countInRange-1, since while condition ensured countInRange will always be equal to neededCharCount\n                            left++;\n                        }\n\n                        // check minSize, only after shrinking window\n                        if (right - left + 1 < minSize) {\n                            minSize = right - left + 1;\n                            result = s.substring(left, right + 1);\n                        }\n                    }\n\n                }\n\n                right++;\n            }\n\n            return result;\n        }\n    }\n\n    class Solution {\n\n        public String minWindow(String s, String t) {\n\n            if (s == null || t == null || s.length() == 0) {\n                return \"\";\n            }\n\n            // left,right pointing to window range\n            int left = 0; // left\n            int right = 0; // right\n\n            int[] countMap = new int[256]; // target chars needed\n\n\n            for (char each : t.toCharArray()) {\n                countMap[each]++;\n            }\n\n            int countInRange = 0;\n            int minSize = Integer.MAX\\_VALUE;\n            String result = \"\";\n\n            while (right < s.length()) {\n                --countMap[s.charAt(right)];\n                if (countMap[s.charAt(right)] >= 0) { // @note: >=\n                    countInRange++;\n                }\n\n                while (countInRange == t.length()) {\n                    if (minSize > right - left + 1) {\n                        minSize = right - left + 1;\n                        result = s.substring(left, right + 1);\n                    }\n\n                    ++countMap[s.charAt(left)]; // '--' above if, so '++' back\n                    if (countMap[s.charAt(left)] > 0) {\n                        countInRange--;\n                    }\n                    left++;\n                }\n\n                right++;\n            }\n\n            return result;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 77,
    "title": "Combinations",
    "problem": "\nGiven two integers *n* and *k*, return all possible combinations of *k*\n numbers out of 1 ... *n*.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** n = 4, k = 2\n**Output:**\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/77.html>\n\n\n\n```\n 77. Combinations\n\n Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n\n You may return the answer in any order.\n\n\n Example 1:\n\n Input: n = 4, k = 2\n Output:\n [\n [2,4],\n [3,4],\n [2,3],\n [1,2],\n [1,3],\n [1,4],\n ]\n\n\n Example 2:\n\n Input: n = 1, k = 1\n Output: [[1]]\n\n\n Constraints:\n\n 1 <= n <= 20\n 1 <= k <= n\n\n\n```\n\nAlgorithm\n=========\n\n\n### DFS\n\n\nDepth-first search DFS to solve, create a large set res that saves the final result, and define a small set out that saves each combination, and put one count into out each time.\n\n\nIf the number in out reaches k, then Save out to the final result, otherwise continue to call recursion in the next layer.\n\n\n### Iteration\n\n\nEach time the rightmost number is incremented and stored in the result res. When the right number exceeds n, the left number is increased, and then the current array is assigned to the left number, and then incremented one by one until the leftmost number is also If n is exceeded, the loop is stopped.\n\n\nFor `n=4`, `k=2`, the order of traversal is as follows:\n\n\n\n```\n0 0 #initialization\n1 0\n1 1\n1 2 #push_back\n1 3 #push_back\n1 4 #push_back\n1 5\n2 5\n2 2\n2 3 #push_back\n2 4 #push_back\n...\n3 4 #push_back\n3 5\n4 5\n4 4\n4 5\n5 5 #stop\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Combinations {\n\n    public class Solution\\_dfs {\n\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> tmp = new ArrayList<>();\n\n        public List<List<Integer>> combine(int n, int k) {\n\n            if (k > n || n <= 0 || k <= 0) {\n                return result;\n            }\n\n            dfs(n, k, 1);\n\n            return result;\n\n        }\n\n        private void dfs(int n, int k, int start) {\n\n            if (k == 0) {\n                result.add(new ArrayList<>(tmp));\n                return;\n            }\n\n            for (int i = start; i <= n; i++) {\n                tmp.add(i);\n                dfs(n, k - 1, i + 1);\n                tmp.remove(tmp.size() - 1);\n            }\n\n        }\n    }\n\n    public class Solution\\_iteration {\n        public List<List<Integer>> combine(int n, int k) {\n\n            List<List<Integer>> res = new ArrayList<>();\n            int[] out = new int[k];\n\n            int i = 0;\n            while (i >= 0) {\n                ++out[i];\n                if (out[i] > n) --i;\n                else if (i == k - 1) res.add(Arrays.stream(out).boxed().collect(Collectors.toList()));\n                else {\n                    ++i;\n                    out[i] = out[i - 1];\n                }\n            }\n\n            return res;\n        }\n    }\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 78,
    "title": "Subsets",
    "problem": "\nGiven a set of **distinct** integers, *nums*, return all possible subsets\n (the power set).\n\n\n**Note:** The solution set must not contain duplicate subsets.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** nums = [1,2,3]\n**Output:**\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/78.html>\n\n\n\n```\n78. Subsets\n\nGiven a set of distinct integers, nums, return all possible subsets.\n\nNote:\nElements in a subset must be in non-descending order.\nThe solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [],\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2]\n]\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nFor the example `[1,2,3]` given in the title,\n\n\n* it is an empty set at the beginning,\n* then we have to deal with 1, add 1 to the empty set, which is `[1]`, and now we have two selves `[]` And `[1]`,\n* let’s deal with 2, we add 2 to each of the previous subsets, and we can get `[2], [1, 2]`, then all the subsets are now `[], [1], [2], [1, 2]`,\n* in the same way, we can get `[3], [1, 3], [2, 3], [1, 2, 3]`, plus all of previous the subsets\n\n\n\n```\n[]\n[1]\n[2]\n[1 2]\n[3]\n[1 3]\n[2 3]\n[1 2 3]\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Subsets {\n\n    public class Solution {\n        public List<List<Integer>> subsets(int[] nums) {\n\n            List<List<Integer>> list = new ArrayList<>();\n            if (nums == null || nums.length == 0) {\n                return list;\n            }\n\n            Arrays.sort(nums); // requirement: non-descending order\n\n            // prepare, add empty one to start looping then.\n            // @note: I forgot empty\n            ArrayList<Integer> empty = new ArrayList<>();\n            list.add(empty);\n\n            for (int i = 0; i < nums.length; i++) {\n                int numToAdd = nums[i];\n                List<List<Integer>> newlyAddedList = new ArrayList<>(list);\n\n                for (List<Integer> each : list) {\n                    ArrayList<Integer> newOne = new ArrayList<Integer>(each); // deep copy\n\n                    newOne.add(numToAdd);\n                    newlyAddedList.add(newOne);\n\n                }\n\n                list = newlyAddedList;\n            }\n\n            return list;\n        }\n    }\n\n    class Solution\\_dfs {\n\n        public List<List<Integer>> subsets(int[] nums) {\n            List<List<Integer>> ans = new ArrayList<>();\n            getAns(nums, 0, new ArrayList<>(), ans);\n            return ans;\n        }\n\n        private void getAns(int[] nums, int start, ArrayList<Integer> temp, List<List<Integer>> ans) {\n            ans.add(new ArrayList<>(temp)); // @note: deep copy\n            for (int i = start; i < nums.length; i++) {\n                temp.add(nums[i]);\n                getAns(nums, i + 1, temp, ans);\n                temp.remove(temp.size() - 1);\n            }\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 79,
    "title": "Word Search",
    "problem": "\nGiven a 2D board and a word, find if the word exists in the grid.\n\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\"\n cells are those horizontally or vertically neighboring. The same letter cell may not be used\n more than once.\n\n\n**Example:**\n\n\n\n```\n\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\nGiven word = \"**ABCCED**\", return **true**.\nGiven word = \"**SEE**\", return **true**.\nGiven word = \"**ABCB**\", return **false**.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/79.html>\n\n\n\n```\n79. Word Search\n\nGiven a 2D board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nThis question is a typical application of depth-first traversal DFS. The original two-dimensional array is like a maze. You can walk in four directions. We use each number in the two-dimensional array as a starting point to match a given string. We also need a visited array of the same size as the original array, which is of bool type to record whether the current location has been visited, because the topic requires that a cell can only be visited once.\n\n\nIf the current character of the two-dimensional array board is equal to the character corresponding to the target string word, then the DFS recursive function is called respectively for the four adjacent characters of the `upper, lower, left, and right` directions. As long as one of them returns true, then the corresponding string can be found. Otherwise it can’t be found\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Word\\_Search {\n\n    public class Solution {\n\n        int m;\n        int n;\n\n        public boolean exist(char[][] board, String word) {\n            m = board.length;\n            n = board[0].length;\n\n            boolean result = false;\n\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dfs(board, word, i, j, 0)) {\n                        return true;\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        public boolean dfs(char[][] board, String word, int i, int j, int wordPos) {\n\n            if (wordPos == word.length()) {\n                return true;\n            }\n\n            // @note: here, return check can remove the boundary check in each recursion, nice!\n            if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] != word.charAt(wordPos)) {\n                return false;\n            }\n\n            char temp = board[i][j];\n\n            board[i][j] = '#';\n\n            boolean result = ( dfs(board, word, i - 1, j, wordPos + 1)\n                            || dfs(board, word, i + 1, j, wordPos + 1)\n                            || dfs(board, word, i, j - 1, wordPos + 1)\n                            || dfs(board, word, i, j + 1, wordPos + 1));\n\n            // restore from `#`\n            board[i][j] = temp;\n\n            return result;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 80,
    "title": "Remove Duplicates from Sorted Array\n                II",
    "problem": "\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that duplicates appeared at most *twice*\n and return the new length.\n\n\nDo not allocate extra space for another array, you must do this by **modifying the\n input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**\n with O(1) extra memory.\n\n\n**Example 1:**\n\n\n\n```\n\nGiven *nums* = **[1,1,1,2,2,3]**,\n\nYour function should return length = **`5`**, with the first five elements of *`nums`* being **`1, 1, 2, 2`** and **3** respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n**Example 2:**\n\n\n\n```\n\nGiven *nums* = **[0,0,1,1,1,1,2,3,3]**,\n\nYour function should return length = **`7`**, with the first seven elements of *`nums`* being modified to **`0`**, **0**, **1**, **1**, **2**, **3** and **3** respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n\n```\n\n**Clarification:**\n\n\nConfused why the returned value is an integer but your answer is an array?\n\n\nNote that the input array is passed in by **reference**, which means\n modification to the input array will be known to the caller as well.\n\n\nInternally you can think of this:\n\n\n\n```\n\n// **nums** is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to **nums** in your function would be known by the caller.\n// using the length returned by your function, it prints the first **len** elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/80.html>\n\n\n\n```\n 80. Remove Duplicates from Sorted Array II\n\n Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\n\n Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\n Example 1:\n\n Given nums = [1,1,1,2,2,3],\n\n Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\n It doesn't matter what you leave beyond the returned length.\n\n Example 2:\n\n Given nums = [0,0,1,1,1,1,2,3,3],\n\n Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.\n\n It doesn't matter what values are set beyond the returned length.\n\n\n Clarification:\n\n Confused why the returned value is an integer but your answer is an array?\n\n Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\n\n Internally you can think of this:\n\n // nums is passed in by reference. (i.e., without making a copy)\n int len = removeDuplicates(nums);\n\n // any modification to nums in your function would be known by the caller.\n // using the length returned by your function, it prints the first len elements.\n for (int i = 0; i < len; i++) {\n print(nums[i]);\n }\n\n @tag-array\n\n```\n\nAlgorithm\n=========\n\n\nThe maximum number of repetitions allowed is two, then a variable cnt can be used to record and several repetitions are allowed, cnt is initialized to 1, if there is one repetition, cnt is decremented by 1, then the next time there is a repetition, the fast pointer is directly moving forward, if it is not repeated at this time, cnt is restored to 1.\n\n\nSince the entire array is ordered, once a non-repeating number appears, it must be greater than this number, and there will be no more duplicates after this number.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Remove\\_Duplicates\\_from\\_Sorted\\_Array\\_II {\n\n    class Solution {\n        public int removeDuplicates(int[] nums) {\n            int i = 0;\n            for (int num : nums) {\n                if (i < 2 || num > nums[i - 2]) {\n                    nums[i++] = num;\n                }\n            }\n            return i;\n        }\n    }\n\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        int pre = 0, cur = 1, dupAllowed = 1, n = nums.length;\n        while (cur < n) {\n            if (nums[pre] == nums[cur] && dupAllowed == 0) {\n                ++cur;\n            } else {\n                if (nums[pre] == nums[cur]) {\n                    --dupAllowed;\n                } else {\n                    dupAllowed = 1;\n                }\n\n                nums[++pre] = nums[cur++];\n            }\n        }\n\n        return pre + 1;\n    }\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 81,
    "title": "Search in Rotated Sorted Array II\n",
    "problem": "\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you\n beforehand.\n\n\n(i.e., `[0,0,1,2,2,5,6]` might become `[2,5,6,0,0,1,2]`).\n\n\nYou are given a target value to search. If found in the array return `true`,\n otherwise return `false`.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [2,5,6,0,0,1,2], target = 0\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [2,5,6,0,0,1,2], target = 3\n**Output:** false\n```\n\n**Follow up:**\n\n\n* This is a follow up problem to [Search\n in Rotated Sorted Array](http://206.81.6.248/problems/search-in-rotated-sorted-array/description/), where `nums` may contain duplicates.\n* Would this affect the run-time complexity? How and why?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/81.html>\n\n\n\n```\nYou are given a target value to search. If found in the array return true, otherwise return false.\n\nExample 1:\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\n\nExample 2:\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\nFollow up for \"Search in Rotated Sorted Array\":\n    What if duplicates are allowed?\n\nWould this affect the run-time complexity? How and why?\n\nWrite a function to determine if a given target is in the array.\n\n@tag-array\n\n\n```\n\nAlgorithm\n=========\n\n\nSince the previous question `Search in Rotated Sorted Array` does not have the same value, when we compare the middle value and the rightmost value, we are in full compliance with the previous rule:\n\n\n* if the number in the middle is less than the rightmost number, the right half is in order.\n* If the number is greater than the rightmost number, the left half is ordered.\n\n\nAnd if there can be repeated values, there will be two situations, [3 1 1] and [1 1 3 1]. For these two situations, when the intermediate value is equal to the rightmost value, the target value 3 can be either on the left or on the right.\n\n\nIt can be on the right, then what should we do? In this case, it is actually very simple. Just move the rightmost value to the left to continue the loop. If it is still the same, continue to move until it reaches a different value, and then the other parts are still Use the method in `Search in Rotated Sorted Array`\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Search\\_in\\_Rotated\\_Sorted\\_Array\\_II {\n\n    // time: O(1)\n    // space: O(N)\n\tpublic class Solution {\n\t    public boolean search(int[] nums, int target) {\n\n\t        if (nums == null || nums.length == 0) {\n\t            return false;\n\t        }\n\n\t        int i = 0; // left pointer\n\t        int j = nums.length - 1; // right pointer\n\n\t        while(i <= j) {\n\t            int mid = (i + j) / 2;\n\n\t            if (nums[mid] == target) {\n\t                return true;\n\t            }\n\n\t            // @note: if (nums[0] <= nums[mid]) {\n\t            if (nums[i] <= nums[mid]) { // left half ordered, right half not ordered\n\n\t                // if (target <= nums[mid]) {\n\t                if (nums[i] <= target && target <= nums[mid]) {\n\t                    j = mid;\n\t                } else {\n\t                    i++;\n\t                }\n\t            } else { // right half ordered, left half not ordered\n\n\t                // if (target <= nums[mid]) {\n\t                if (nums[mid] <= target && target <= nums[j]) {\n\t                    i = mid;\n\t                } else {\n\t                    j--;\n\t                }\n\t            }\n\t        }\n\n\t        return false;\n\t    }\n\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 82,
    "title": "Remove Duplicates from Sorted List\n                II",
    "problem": "\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct*\n numbers from the original list.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 1->2->3->3->4->4->5\n**Output:** 1->2->5\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 1->1->1->2->3\n**Output:** 2->3\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/82.html>\n\n\n\n```\n82\tRemove Duplicates from Sorted List II\n\nGiven a sorted linked list, delete all nodes that have duplicate numbers,\nleaving only distinct numbers from the original list.\n\nFor example,\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nHere we need to delete all the duplicates. Because there may be duplicates at the beginning of the linked list, the head pointer will change if it is deleted, but the head pointer of the linked list needs to be returned in the end.\n\n\nTherefore, you need to define a new node, then link the original linked list, and then define a precursor pointer and a current pointer. Each current pointer points to the newly created node. The current pointer starts from the next position and traverses down.\n\n\n* If the same is encountered, it will continue. Next, until a different item is encountered, the next of the predecessor pointer points to the different element below.\n* If the first element traversed by the current pointer is not the same, move the predecessor pointer down one place.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Remove\\_Duplicates\\_from\\_Sorted\\_List\\_II {\n\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\n\t\tListNode prev = dummy;\n\t\tListNode current = head;\n\n\t\twhile (current != null) {\n\n\t\t\tboolean dup = false;\n\n\t\t\t// probe next to see if duplicate\n\t\t\twhile (current.next != null && current.val == current.next.val) {\n\t\t\t\tcurrent = current.next;\n\t\t\t\tdup = true;\n\t\t\t}\n\n\t\t\tif (dup) { // prev staying the same\n\t\t\t\tprev.next = current.next;\n\t\t\t\tcurrent = current.next;\n\t\t\t} else {\n\t\t\t\tprev = current;\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t}\n\n\t\treturn dummy.next;\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 83,
    "title": "Remove Duplicates from Sorted\n                List",
    "problem": "\nGiven a sorted linked list, delete all duplicates such that each element appear only\n *once*.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 1->1->2\n**Output:** 1->2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 1->1->2->3->3\n**Output:** 1->2->3\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/83.html>\n\n\n\n```\n 83\tRemove Duplicates from Sorted List\n\n Given a sorted linked list, delete all duplicates such that each element appear only once.\n\n Example 1:\n\n Input: 1->1->2\n Output: 1->2\n\n Example 2:\n\n Input: 1->1->2->3->3\n Output: 1->2->3\n\n @tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nTraverse this linked list, and compare each node with the following nodes. If the value of the node is the same, just skip the next pointer of the previous node with the same value and point to the next node. After traversing in this way, all duplicate nodes will be skipped, and the linked list left will have no duplicates.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Remove\\_Duplicates\\_from\\_Sorted\\_List {\n    /\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) {\n \\* val = x;\n \\* next = null;\n \\* }\n \\* }\n \\*/\n    public class Solution {\n        public ListNode deleteDuplicates(ListNode head) {\n            if (head == null || head.next == null)  return head;\n\n            // ListNode dummy = new ListNode(0);\n            // dummy.next = head;\n\n            ListNode prev = head;\n            ListNode p = head.next;\n\n            while (p != null) {\n                if (p.val == prev.val) {\n                    prev.next = p.next;\n                    p = p.next;\n                } else {\n                    prev = p;\n                    p = p.next;\n                }\n\n            }\n\n            return head;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 84,
    "title": "Largest Rectangle in Histogram\n",
    "problem": "\nGiven *n* non-negative integers representing the histogram's bar height where the\n width of each bar is 1, find the area of largest rectangle in the histogram.\n\n\n \n\n\n\n![](img/84_1.png)  \n\nAbove is a histogram where width of each bar is 1, given height =\n `[2,1,5,6,2,3]`.\n \n\n\n\n \n\n\n\n![](img/84_2.png)  \n\nThe largest rectangle is shown in the shaded area, which has area = `10`\n unit.\n \n\n\n\n \n\n\n**Example:**\n\n\n\n```\n\n**Input:** [2,1,5,6,2,3]\n**Output:** 10\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/84.html>\n\n\n\n```\n84\tLargest Rectangle in Histogram\n\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1,\nfind the area of largest rectangle in the histogram.\n\n\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n\nFor example,\nGiven heights = [2,1,5,6,2,3],\nreturn 10.\n\n@tag-stack\n\n```\n\nAlgorithm\n=========\n\n\n### keyword: “Eliminate the shadow”, that is, the lowest bar is the length of a side\n\n\nIntuitively, the area of ​​the two bars depends on the shortest and lowest bar among them.\n\n\nMy own doubt is if it is `[1,2,3,4,1,2,3,4]`.\n\n\nHow to prove that the first 1 and last 4 restricted rectangles will definitely not be the largest? Because the stack only maintains the current one, note that there is only one, an increasing sequence.\n\n\nSimplified to `[1,2,1,2]`, then the maximum area is the area 4 formed by the first 1 and the last 2\n\n\n* So the key is that the push and pop conditions of the stack must ensure that the `lowest bar` is always in the stack.\n\n\nExtend to eg. `[3,1,2,1,2]`, the largest area also comes from the area formed by the first and last bar at 5.\n\n\nBecause the lowest one will always be in the stack, and the stack will eventually pop to empty,\nThe last pop is the smallest bar. At this time, the shortest bar is multiplied by the length from the first to the last.\n\n\nThe whole question will be clear if you understand this: `int currentWidth = sk.isEmpty()? i: (i-1-sk.peek());`\n\n\n`sk.peek()` is definitely the essence of the quintessence, to find the width of the largest rectangle, I wrote `i-currentIndex` at the beginning, but I ignored the situation when counting 4 in `2, 8, 8, 4, 6, 8`. There are two `88` in front of 4, that is, the width should be from the first 8 to the last 8.\nAt this time, to find this width, you need sk.peek() to find the previous small index\n\n\nThere is another pit, which is the application of dummy end, which has the same effect as dummy head, allowing the for loop to start and run normally.\n\n\n`Arrays.copyOfRange(origin, start, end)`, if end exceeds the length of the origin array, 0 will be added automatically\n\n\nThe best test case:\n\n\n* 2,1,2\n* 2,0,2\n* 2,0,2,1,2\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\nimport java.util.Stack;\n\npublic class Largest\\_Rectangle\\_in\\_Histogram {\n\n    public int largestRectangleArea(int[] rowarray) {\n\n        // stack is to push array index of each element\n        Stack<Integer> sk = new Stack<Integer>();\n\n        // length+1, in the end add a dummy element as 0\n        int[] row = new int[rowarray.length + 1];\n        // @note: Arrays.copyOf()\n        row = Arrays.copyOf(rowarray, rowarray.length + 1);\n\n        int max = 0;\n\n        // for (int i = 0; i < row.length; i++) {\n        int i = 0;\n        while (i < row.length) {\n\n            // @note: careful about duplicate numbers being pushed\n            // \"<=\" and \"<\" both AC, since same height bar will be popped and checked anyway, just a matter of when popped\n            // if (sk.isEmpty() || row[sk.peek()] <= row[i]) { @note: this is AC also\n            if (sk.isEmpty() || row[sk.peek()] < row[i]) {\n                sk.push(i);\n                i++;\n            } else { // value of index-i is smaller than current stack top\n\n                // @note: to get lowest bar, since other bars are all larger than it\n                int currentLowestBarIndex = sk.pop();\n                int edge1 = row[currentLowestBarIndex];\n                // @note: empty meaning just popped lowest bar\n                // @note: sk.peek() is\n                int edge2 = sk.isEmpty() ? i : (i - 1 - sk.peek()); // i-1-peek is ok, since it's monotonic increasing stack\n\n                // calculate area\n                max = Math.max(max, edge1 \\* edge2);\n            }\n        }\n\n        return max;\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 85,
    "title": "Maximal Rectangle",
    "problem": "\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle\n containing only 1's and return its area.\n\n\n**Example:**\n\n\n\n```\n\n**Input:**\n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"**1**\",\"**1**\",\"**1**\"],\n  [\"1\",\"1\",\"**1**\",\"**1**\",\"**1**\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\n**Output:** 6\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/85.html>\n\n\n\n```\n85\tMaximal Rectangle\n\nGiven a 2D binary matrix filled with 0's and 1's,\nfind the largest rectangle containing all ones and return its area.\n\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nExample:\n\nInput:\n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\nOutput: 6\n\n@tag-stack\n\n```\n\nAlgorithm\n=========\n\n\nThis question is an extension of the previous `84. Largest Rectangle in Histogram`. The two-dimensional matrix of this question can be seen as a **histogram at each level upwards**.\n\n\nFor each histogram to call the method in `84. Largest Rectangle in Histogram` to get the largest rectangle area.\n\n\nThen the only thing to do in this question is to treat each layer as the bottom layer of the histogram, and construct the entire histogram upwards. Since the question limits the characters of the input matrix to only ‘0’ and ‘1’, it is processed It is also relatively simple. The method is, for each point, if it is ‘0’, assign 0, if it is ‘1’, assign the previous height value plus 1.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\nimport java.util.Stack;\n\npublic class Solution {\n        public int maximalRectangle(char[][] m) {\n            /\\*\n original:\n\n \"0010\",\n \"1111\",\n \"1111\",\n \"0111\",\n \"1100\",\n \"1111\",\n \"1110\"\n\n \\*/\n\n\n\n\t    \t/\\*\n \"01101\",\n \"11010\",\n \"01110\",\n \"11110\",\n \"11111\",\n \"00000\",\n\n\n [0, 1, 1, 0, 1],\n [1, 2, 0, 1, 0],\n [0, 3, 1, 2, 0],\n [1, 4, 2, 3, 0],\n [2, 5, 3, 4, 1],\n [0, 0, 0, 0, 0]]\n \\*/\n\n            if (m == null || m.length == 0) {\n                return 0;\n            }\n\n\n            int row = m.length;\n            int col = m[0].length;\n\n            // build dp, dp[i][j]就是当前的第j列的，从上面开始到第i行连续1的个数\n            int[][] dp = new int[row][col];\n\n            // process first row\n            for (int j = 0; j < col; j++) {\n                dp[0][j] = m[0][j] - '0';\n            }\n\n            //@note: assumption, at least 2 rows\n            for (int i = 1; i < row; i++) {\n                for (int j = 0; j < col; j++) {\n                    if (m[i][j] - '0' != 0) {\n                        dp[i][j] = 1 + dp[i - 1][j];\n                    }\n                }\n            }\n\n            if (m.length == 1) {\n                return findRowMax(dp[0]);\n            }\n\n\n            // search each row of dp array\n            int max = 0;\n            for (int i = 0; i < row; i++) {\n                int rowMax = findRowMax(dp[i]);\n                max = max > rowMax ? max : rowMax;\n            }\n\n            return max;\n        }\n\n        public int findRowMax(int[] rowOriginal) {\n\n            int[] row = new int[rowOriginal.length + 1];\n            row = Arrays.copyOfRange(rowOriginal, 0, rowOriginal.length + 1);\n\n            int max = 0;\n            int length = row.length;\n\n            // stack store index, not the actual value\n            Stack<Integer> sk = new Stack<>();\n            int i = 0;\n            while (i < length) {\n                // if (i == 0 || row[i] >= row[sk.peek()]) {\n                if (sk.isEmpty() || row[i] >= row[sk.peek()]) {\n                    sk.push(i);\n                    i++;\n                } else {\n\n                    // while (!sk.isEmpty() && row[i] < row[sk.peek()]) {\n\n                    // int index = sk.pop();\n                    // int prevIndex = sk.isEmpty()? 0 : sk.peek();\n\n                    // int area = (i - 1 - prevIndex) \\* row[index]; // i-1 is the highest bar before i\n                    // max = max > area ? max : area;\n\n                    // }\n\n                    int index = sk.pop();\n                    // int prevIndex = sk.isEmpty()? 0 : sk.peek();\n                    // int prevIndex = sk.isEmpty() ? i : sk.peek();\n\n                    // 这里是：高度(row[index]) \\* 长度\n                    int area = (sk.isEmpty() ? i : (i - 1 - sk.peek())) \\* row[index]; // i-1 is the highest bar before i\n                    max = max > area ? max : area;\n\n                    // sk.push(i++);\n                }\n            }\n\n            // final check when reaching end of array. OR add dummy number to array end\n            // while (!sk.isEmpty()) {\n\n            // int index = sk.pop();\n            // int prevIndex = sk.isEmpty()? 0 : sk.peek();\n\n            // int area = (i - 1 - prevIndex) \\* row[index]; // i-1 is the highest bar before i\n            // max = max > area ? max : area;\n            // }\n\n            return max;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 86,
    "title": "Partition List",
    "problem": "\nGiven a linked list and a value *x*, partition it such that all nodes less than\n *x* come before nodes greater than or equal to *x*.\n\n\nYou should preserve the original relative order of the nodes in each of the two\n partitions.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** head = 1->4->3->2->5->2, *x* = 3\n**Output:** 1->2->2->4->3->5\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/86.html>\n\n\n\n```\n86\tPartition List\n\nGiven a linked list and a value x, partition it such that all nodes less than x come before\nnodes greater than or equal to x.\n\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nFor example,\nGiven 1->4->3->2->5->2 and x = 3,\nreturn 1->2->2->4->3->5.\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nAll nodes less than the given value are taken out to form a new linked list. At this time, the values of the remaining nodes in the original linked list are greater than or equal to the given value, as long as the original linked list is directly connected to the new linked list.\n\n\n\n```\nOriginal: 1 -> 4 -> 3 -> 2 -> 5 -> 2\nNew:\n\nOriginal: 4 -> 3 -> 2 -> 5 -> 2\nNew:　  1\n\nOriginal: 4 -> 3 -> 5 -> 2\nNew:　  1 -> 2\n\nOriginal: 4 -> 3 -> 5\nNew:　  1 -> 2 -> 2\n\nOriginal:\nNew:　  1 -> 2 -> 2 -> 4 -> 3 -> 5\n\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Partition\\_List {\n\n\t/\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) { val = x; }\n \\* }\n \\*/\n\tpublic class Solution {\n\t    public ListNode partition(ListNode head, int x) {\n\t        if (head == null) {\n\t            return head;\n\t        }\n\n\t        ListNode lessList = new ListNode(0);\n\t        ListNode moreList = new ListNode(0);\n\n\t        ListNode lessHeadCopy = lessList;\n\t        ListNode moreHeadCopy = moreList;\n\n\t        int xCount = 0;\n\t        ListNode current = head;\n\t        while (current != null) {\n\t            int num = current.val;\n\n\t            if (num < x) {\n\t                lessList.next = new ListNode(num);\n\t                lessList = lessList.next;\n\t            } else {\n\t                moreList.next = new ListNode(num);\n\t                moreList = moreList.next;\n\t            }\n\n\t            current = current.next;\n\t        }\n\n\t        // append target x\n\t        while (xCount > 0) {\n\t            lessList.next = new ListNode(x);\n\t            lessList = lessList.next;\n\n\t            xCount--;\n\t        }\n\n\t        // connect two lists\n\t        lessList.next = moreHeadCopy.next;\n\n\t        return lessHeadCopy.next;\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 87,
    "title": "Scramble String",
    "problem": "\nGiven a string *s1*, we may represent it as a binary tree by partitioning it to two\n non-empty substrings recursively.\n\n\nBelow is one possible representation of *s1* = `\"great\"`:\n\n\n\n```\n\n    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n\n```\n\nTo scramble the string, we may choose any non-leaf node and swap its two children.\n\n\nFor example, if we choose the node `\"gr\"` and swap its two children, it\n produces a scrambled string `\"rgeat\"`.\n\n\n\n```\n\n    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n\n```\n\nWe say that `\"rgeat\"` is a scrambled string of\n `\"great\"`.\n\n\nSimilarly, if we continue to swap the children of nodes `\"eat\"` and\n `\"at\"`, it produces a scrambled string `\"rgtae\"`.\n \n\n\n\n```\n\n    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n\n```\n\nWe say that `\"rgtae\"` is a scrambled string of\n `\"great\"`.\n\n\nGiven two strings *s1* and *s2* of the same length, determine if *s2* is\n a scrambled string of *s1*.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"great\", s2 = \"rgeat\"\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"abcde\", s2 = \"caebd\"\n**Output:** false\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/87.html>\n\n\n\n```\n87\tScramble String\n\nGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n\nBelow is one possible representation of s1 = \"great\":\n\n    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\nTo scramble the string, we may choose any non-leaf node and swap its two children.\n\nFor example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\n\n    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\nWe say that \"rgeat\" is a scrambled string of \"great\".\n\nSimilarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\n\n    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\nWe say that \"rgtae\" is a scrambled string of \"great\".\n\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n\n@tag-dp\n\n```\n\nAlgorithm\n=========\n\n\n### DFS\n\n\nIf s1 and s2 are scramble, then there must be a length l1 on s1, which divides s1 into s11 and s12, and there are also s21 and s22, then either s11 and s21 are scramble and s12 and s22 are scramble; or s11 and s22 are scramble and s12 and s21 are scramble.\n\n\nTake the example of rgeat and great in the title. rgeat can be divided into rg and eat, and great can be divided into gr and eat. rg and gr are scrambled, and eat and eat are of course scrambled.\n\n\n### DP\n\n\nFor the subject of three-dimensional dynamic programming, use a three-dimensional array dp[i][j][n], where i is the starting character of s1, j is the starting character of s2, and n is the current string length, dp[i ][j][len] indicates whether the string with length len starting from i and j as s1 and s2 are scrambles for each other.\n\n\nWith the dp array, let’s look at the state transition equation, which is how to get dp[i][j][len] based on historical information. To judge whether this is satisfied, first split the current s1[i…i+len-1] string into two parts, and then divide into two cases:\n\n\n* the first is the left side and s2[j…j+ len-1] Is the left part a scramble, and whether the right part and s2[j…j+len-1] is a scramble;\n* the second case is the left part and s2[j…j+len-1] Whether the right part is a scramble, and whether the right part and the left part of s2[j…j+len-1] is a scramble.\n\t+ If one of the above two conditions is true, it means that s1[i…i+len-1] and s2[j…j+len-1] are scramble.\n\tThere is historical information for judging whether these left and right parts are scramble, because all the cases where the length is less than n have been solved before (that is, the length is the outermost loop).\n\n\nThe above is the case of splitting. For s1[i…i+len-1], there are len-1 splitting methods. As long as one of these splitting methods is established, then the two strings are scramble. In summary, the state transition equation is:\n\n\n\n\n|  |  |  |  |  |\n| --- | --- | --- | --- | --- |\n| `dp[i][j][len] = |  | (dp[i][j][k] && dp[i+k][j+k][len-k] |  | dp[i][j+len-k][k] && dp[i+k][j][len-k]) |\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Scramble\\_String {\n\n\tpublic class Solution {\n\t    public boolean isScramble(String s1, String s2) {\n\t        if (s1 == null || s2 == null || s1.length() != s2.length()) {\n\t            return false;\n\t        }\n\n\t        int len = s1.length();\n\n\t        // dp[i][j], i,j not index, substring i to j of s1/s2 are scrambled\n\t        boolean[][][] dp = new boolean[len][len][len + 1];\n\n\t        for (int i = 0; i < len; i++) {\n\t            for (int j = 0; j < len; j++) {\n\t                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\n\t            }\n\t        }\n\n\t        for (int n = 1; n < len + 1; n++) {\n\t            for (int i = 0; i + n - 1 < len; i++) { // @note: here boundary check, I missed\n\t                for (int j = 0; j + n - 1 < len; j++) {\n\n\t                    for (int sublen = 1; sublen < n; sublen++) {\n\n\t                        // same strings: s1=\"abcde\", s2=\"abcde\"\n\t                        boolean ifSame = dp[i][j][sublen] && dp[i + sublen][j + sublen][n - sublen];\n\n\t                        // swapped strings: s1=\"abcde\", s2=\"cdeab\"\n\t                        // @note: especially for the index here, using an example for assistance\n\t                        boolean ifSwapped = dp[i][j + n - sublen][sublen] && dp[i + sublen][j][n - sublen];\n\n\t                        // dp[i][j][n] = ifSame || ifSwapped; // @note: stupid...being overwritten\n\t                        if (ifSame || ifSwapped) {\n\t                            dp[i][j][n] = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return dp[0][0][len];\n\n\t    }\n\t}\n\n\tpublic class Solution\\_over\\_time { // clearly a lot of repeated calculation during recursion\n\t    public boolean isScramble(String s1, String s2) {\n\t        if (s1 == null || s2 == null || s1.length() != s2.length()) {\n\t            return false;\n\t        }\n\n\t        if (s1.length() == 0) {\n\t            return s2.length() == 0;\n\t        }\n\n\t        if (s1.length() == 1) {\n\t            return s1.charAt(0) == s2.charAt(0);\n\t        }\n\n\t        // basically swap happens for a node of 2 children\n\t        if (s1.length() == 2) {\n\t            boolean isSame = s1.equals(s2);\n\t            boolean isSwapped = s1.charAt(0) == s2.charAt(1) && s1.charAt(1) == s2.charAt(0);\n\n\t            return isSame || isSwapped;\n\t        }\n\n\t        for (int i = 1; i < s1.length(); i++) {\n\n\t            // @note: left and right child chould NOT be empty\n\t            // int splitIndex = i;\n\t            boolean isThisScramble = isScramble(s1.substring(0, i), s2.substring(0, i))\n\t                                        && isScramble(s1.substring(i), s2.substring(i));\n\t            if (isThisScramble) {\n\t                return true;\n\t            }\n\t        }\n\n\t        return false;\n\n\t    }\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 88,
    "title": "Merge Sorted Array",
    "problem": "\nGiven two sorted integer arrays *nums1* and *nums2*, merge *nums2* into\n *nums1* as one sorted array.\n\n\n**Note:**\n\n\n* The number of elements initialized in *nums1* and *nums2* are *m*\n and *n* respectively.\n* You may assume that *nums1* has enough space (size that is greater or equal to\n *m* + *n*) to hold additional elements from *nums2*.\n\n\n**Example:**\n\n\n\n```\n\n**Input:**\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n**Output:** [1,2,2,3,5,6]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/88.html>\n\n\n88. Merge Sorted Array\n======================\n\n\nLevel\n-----\n\n\nEasy\n\n\nDescription\n-----------\n\n\nGiven two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n\n\nNote:\n\n\n* The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n* You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n\n\n**Example:**\n\n\n**Input:**\n\n\nnums1 = [1,2,3,0,0,0], m = 3\n\n\nnums2 = [2,5,6], n = 3\n\n\n**Output:** [1,2,2,3,5,6]\n\n\nSolution\n--------\n\n\nTo avoid overwriting elements in `nums1` before the elements are put in the correct positions, start from the end of the array and put elements to the correct positions backwards.\n\n\nLet `index1` and `index2` be indices in original arrays `nums1` and `nums2`, and `index` be the index in merged array `nums1`. Initially, `index1 = m - 1`, `index2 = n - 1` and `index = m + n - 1`.\n\n\nWhile both `index1` and `index2` are greater than or equal to 0, each time compare the elements `nums1[index1]` and `nums2[index2]`, and put the greater elements to `nums1[index]`. Reduce `index1` by 1, and reduce either `index1` or `index2` by 1 where the element is put to `nums1[index]`.\n\n\nWhen only one array has remaining elements, put the elements from the array to the remaining positions in `nums1[index]`.\n\n\n2 pitfalls\n\n\n* 1) Don’t use nums1.length if you give m, because nums1 is followed by a row of 0\n* 2) Note that the pointer of p1 or p2 will be reduced to a negative number, then index error, so add a check\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Arrays;\n\npublic class Merge\\_Sorted\\_Array {\n\n\tpublic static void main(String[] args) {\n\t\tMerge\\_Sorted\\_Array out = new Merge\\_Sorted\\_Array();\n\n\t\tSolution s = out.new Solution();\n\n\t\tint[] nums1 = new int[]{1};\n\t\ts.merge(new int[]{}, 0, nums1, 1);\n\t\tSystem.out.println(Arrays.toString(nums1));\n\t}\n\n    class Solution {\n        public void merge(int[] nums1, int m, int[] nums2, int n) {\n\n            if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {\n                return;\n            }\n\n            int p1 = m - 1;\n            int p2 = n - 1;\n            for (int i = m + n - 1; i>= 0; i--) {\n\n                int v1 = nums1[p1];\n                int v2 = p2 >= 0 ? nums2[p2] : Integer.MIN\\_VALUE;\n                if (v1 > v2) {\n                    nums1[i] = nums1[p1--];\n                } else {\n                    nums1[i] = nums2[p2--];\n                }\n            }\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 89,
    "title": "Gray Code",
    "problem": "\nThe gray code is a binary numeral system where two successive values differ in only one\n bit.\n\n\nGiven a non-negative integer *n* representing the total number of bits in the code,\n print the sequence of gray code. A gray code sequence must begin with 0.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** 2\n**Output:** [0,1,3,2]\n**Explanation:**\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\nFor a given *n*, a gray code sequence may not be uniquely defined.\nFor example, [0,2,3,1] is also a valid gray code sequence.\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** 0\n**Output:** [0]\n**Explanation:** We define the gray code sequence to begin with 0.\n             A gray code sequence of *n* has size = 2n, which for *n* = 0 the size is 20 = 1.\n             Therefore, for *n* = 0 the gray code sequence is [0].\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/89.html>\n\n\n\n```\n89\tGray Code\n\nThe gray code is a binary numeral system where two successive values differ in only one bit.\n\nGiven a non-negative integer n representing the total number of bits in the code,\nprint the sequence of gray code. A gray code sequence must begin with 0.\n\nFor example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\n\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\nNote:\nFor a given n, a gray code sequence is not uniquely defined.\n\nFor example, [0,2,3,1] is also a valid gray code sequence according to the above definition.\n\n```\n\nAlgorithm\n=========\n\n\nFor n=3:\n\n\n\n```\nInt    Grey Code    Binary\n 0  　　  000        000\n 1  　　  001        001\n 2   　 　011        010\n 3   　 　010        011\n 4   　 　110        100\n 5   　 　111        101\n 6   　 　101        110\n 7   　　 100        111\n\n```\n\nMy idea is using left shifts, and then operate the lowest bit, followed by 0 or 1.\n\n\nAnother idea is to get the highest position directly, and then add all the previous ones to the highest one\n\n\n* Note that a for loop starts from 0, if it is n, then «n-1 is enough\n* The second for loop must be reversed from list-size-1 to 0.\n\n\nIf it starts from 0, then the list keeps getting new homes, the size keeps increasing, and it loops endlessly.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Gray\\_Code {\n\n\tpublic static void main(String[] args) {\n\t\tGray\\_Code out = new Gray\\_Code();\n\t\tSolution\\_optimize\\_on\\_highest\\_digit s = out.new Solution\\_optimize\\_on\\_highest\\_digit();\n\n\t\tSystem.out.println(s.grayCode(3)); // output: [0, 1, 3, 2, 6, 7, 5, 4]\n\t}\n\n\t// 0 => 0,1 => 10,11\n\tpublic class Solution\\_optimize\\_on\\_highest\\_digit {\n\t\tpublic List<Integer> grayCode(int n) {\n\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\n\t\t\tlist.add(0); // special case\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint highestBit = 1 << (i - 1);\n\n\t\t\t\t// @note:@memorize: nice cutoff! no need to use an extra tmpList\n\t\t\t\tfor (int j = list.size() - 1; j >= 0; j--) {\n\t\t\t\t\tlist.add(highestBit + list.get(j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\t}\n\n\n\tpublic class Solution\\_on\\_highest\\_digit {\n\t    public List<Integer> grayCode(int n) {\n\n\t        List<Integer> list = new ArrayList<Integer>();\n\n\t        if (n < 0) {\n\t            return list;\n\t        }\n\n\t        // init\n\t        list.add(0);\n\n\t        // @note: append 1 at highest digit position\n\t        for (int i = 1; i <= n; i++) {\n\n\t            // int prevLen = list.size();\n\t            List<Integer> tmpList = new ArrayList<Integer>(list);\n\t            for (int each: list) {\n\t                tmpList.add(each + (1 << (i - 1)));\n\t            }\n\n\t            list = tmpList;\n\t        }\n\n\t        return list;\n\t    }\n\t}\n\n\n\tpublic class Solution\\_on\\_lowest\\_digit {\n\t\tpublic List<Integer> grayCode(int n) {\n\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\n\t\t\tif (n == 0) {\n\t\t\t\tlist.add(0);\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tlist.add(0);\n\t\t\tlist.add(1);\n\n\t\t\tfor (int i = 2; i <= n; i++) {\n\n\t\t\t\tList<Integer> allprev = new ArrayList<Integer>(list);\n\n\t\t\t\tfor (int each : allprev) {\n\t\t\t\t\teach <<= 1;\n\n\t\t\t\t\tif (!list.contains(each))\n\t\t\t\t\t\tlist.add(each);\n\t\t\t\t\tif (!list.contains(each + 1))\n\t\t\t\t\t\tlist.add(each + 1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\t}\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 90,
    "title": "Subsets II",
    "problem": "\nGiven a collection of integers that might contain duplicates, ***nums***,\n return all possible subsets (the power set).\n\n\n**Note:** The solution set must not contain duplicate subsets.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [1,2,2]\n**Output:**\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/90.html>\n\n\n\n```\n90. Subsets II\n\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets.\n\nNote:\nElements in a subset must be in non-descending order.\nThe solution set must not contain duplicate subsets.\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\n@tag-array\n\n```\n\nAlgorithm\n=========\n\n\nTake the example `[1 2 2]` in the title for analysis. According to the analysis in Subsets before, when the first 2 is processed, the subsets at this time are `[], [1], [2], [1, 2]`, and when processing the second 2 at this time, if you add 2 directly after `[]` and `[1]`, there will be duplication, so you can `only` add 2 after the last two subsets generated by the `previous loop`.\n\n\nWe use last to record the last processed number, and then determine whether the current number is the same as the above.\n\n\n* If it is different, the loop will continue from 0 to the number of the current subset.\n* If the same, then The number of new subsets minus the number of subsets in the previous loop is used as the starting point to loop, so that there will be no duplication\n\n\nMy solving process:\n\n\n\n```\nnums = [1,2,2,2]\n[],1,\t2,12,\t2,12,22,122,\t2,12,22,122,22,122,222,1222\n\n```\n\nfrom above, every time the new add is doubled, count: `1,2,4,8`\nso, the 1st half is duplicated, and 2nd half is NOT duplicated\nso, when going into a new loop, append duplicated num to ONLY 2nd half elements\n\n\nthen:\n\n\n\n```\n[],1\n\n```\n\nappend 2, not duplicated, append as normal:\n\n\n\n```\n[],1,\t2, 12\n\n```\n\nappend 2, same as previous 2, then append last 2 elements - “2,12”\n\n\n\n```\n[],1,\t2, 12,\t\t22,122\n\n```\n\nappend 2, same as previous 2, then append last 2 elements - “22,122”\n\n\n\n```\n[],1,\t2, 12,\t\t22,122,\t\t222,1222\n\n```\n\nappend 2, same as previous 2, then append last 2 elements - “222,1222”\n\n\n\n```\n[],1,\t2, 12,\t\t22,122,\t\t222,1222,\t\t2222,12222\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Subsets\\_II {\n\n    public static void main(String[] args) {\n        Subsets\\_II out = new Subsets\\_II();\n        Solution s = out.new Solution();\n\n        for (List<Integer> each : s.subsetsWithDup(new int[]{1, 1})) {\n            System.out.println(each.toString());\n        }\n    }\n\n    class Solution {\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\n            List<List<Integer>> list = new ArrayList<>();\n            if (nums == null || nums.length == 0) {\n                return list;\n            }\n\n            Arrays.sort(nums); // requirement: non-descending order\n\n            // prepare, add empty one to start looping then.\n            // @note: I forgot empty\n            ArrayList<Integer> empty = new ArrayList<>();\n            list.add(empty);\n\n            int prevIndex = 0;\n\n            for (int i = 0; i < nums.length; i++) {\n                int numToAdd = nums[i];\n                List<List<Integer>> newlyAddedList = new ArrayList<>(list);\n\n                int start = (i > 0 && nums[i] == nums[i - 1]) ? prevIndex : 0;\n\n                for (int j = start; j < list.size(); j++) {\n                    List<Integer> each = list.get(j);\n                    ArrayList<Integer> newOne = new ArrayList<Integer>(each); // deep copy\n\n                    newOne.add(numToAdd);\n                    newlyAddedList.add(newOne);\n\n                }\n\n                prevIndex = list.size();\n                list = newlyAddedList;\n            }\n\n            return list;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 91,
    "title": "Decode Ways",
    "problem": "\nA message containing letters from `A-Z` is being encoded to numbers using the\n following mapping:\n\n\n\n```\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\n```\n\nGiven a **non-empty** string containing only digits, determine the total number\n of ways to decode it.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** \"12\"\n**Output:** 2\n**Explanation:** It could be decoded as \"AB\" (1 2) or \"L\" (12).\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** \"226\"\n**Output:** 3\n**Explanation:** It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/91.html>\n\n\n\n```\n91\tDecode Ways\n\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits, determine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\", it could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2.\n\n@tag-dp\n\n```\n\nAlgorithm\n=========\n\n\nCreate a one-dimensional dp array, where `dp[i]` represents the number of decoding methods for the substring composed of the first i characters in s. The length is one more than the input array, and `dp[0]` is initialized to 1.\n\n\nNow let’s look for the state transition equation. The value of `dp[i]` is inextricably linked to the previous state. Let’s analyze the example `226`.\n\n\n* When `i=1`, the corresponding character in s is `s[0]='2'`, there is only one split method, which is 2.\n\t+ Note that `s[0]` must not be 0, otherwise it cannot be split.\n* When i=2, the corresponding character in s is `s[1]='2'`. Since `s[1]` is not 0, it can be split separately, which can be in the previous `dp[i-1]`\n\t+ In each case, a single 2 is added, so that `dp[i]` can have at least as many splits as `dp[i-1]`.\n\n\nNext, it depends on whether it can be combined with the previous number. If the two digits are `less than or equal to 26` and `greater than or equal to 10` (because the high digit of the two digits cannot be 0), then you can add this two digit in each case of `dp[i-2]`.\n\n\nSo In the end, `dp[i] = dp[i-1] + dp[i-2]`, is it found to be consistent with the nature of the Fibonacci sequence? Therefore, 0 is a very special existence. If the current position is 0, it must not be separated separately, that is, `dp[i-1]` cannot be added, and it can only be seen whether the previous number is greater than or equal to 10 and less than or equal to 26, you can add `dp[i-2]` if you can, otherwise it can only be kept at 0.\n\n\nThe specific operation steps are, in the process of traversal, first check whether each number is 0, if so, assign `dp[i]` to 0, if not, assign the value of `dp[i-1]`, and then see Whether the previous digit of the array exists, if it exists and meets that the previous digit is 1, or the two digits formed by the current digit are not greater than 26, then the current `dp[i]` value is added to `dp[i-2]`. Finally returns the last value of the dp array.\n\n\n\n```\nF(n) = F(n-1) + F(n-2)     \t\t\n* if s[n] is a valid encoding digit and s[n-1]s[n] is also a valid encoding number.\n\nF(n) = F(n-1)                   \n* if s[n] is a valid encoding digit and s[n-1]s[n] is NOT a valid encoding number.\n\nF(n) = F(n-2)                   \n* if s[n] is NOT a valid encoding digit and s[n-1]s[n] is  a valid encoding number.\n\nF(n) = 0                        \n* if s[n] is NOT a valid encoding digit and s[n-1]s[n] is NOT  a valid encoding number.\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Decode\\_Ways {\n\n    public static void main(String[] args) {\n        Decode\\_Ways out = new Decode\\_Ways();\n        Solution\\_fromStart s = out.new Solution\\_fromStart();\n\n        System.out.println(s.numDecodings(\"123\"));\n    }\n\n\n    public class Solution {\n        public int numDecodings(String s) {\n\n            if(s.length() == 0) return 0;\n\n            int length = s.length();\n            int[] dp = new int[length + 1]; // dp[i] => at index i, its decode ways\n\n            dp[length] = 1; // 初始值，启动值很重要，1 就是默认有一种解码方式\n            dp[length - 1] = s.charAt(length - 1) == '0' ? 0 : 1;\n\n            for(int i = length - 2; i >= 0; i--){\n                if(s.charAt(i) == '0') continue;\n                int tem = Integer.valueOf(s.substring(i,i + 2));\n\n                if(tem > 26){\n                    dp[i] = dp[i + 1];\n                }else{\n                    dp[i] = dp[i + 1] + dp[i + 2];\n                }\n            }\n            return dp[0];\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 92,
    "title": "Reverse Linked List II",
    "problem": "\nReverse a linked list from position *m* to *n*. Do it in one-pass.\n\n\n**Note:**1 ≤ *m* ≤ *n* ≤ length of list.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 1->2->3->4->5->NULL, *m* = 2, *n* = 4\n**Output:** 1->4->3->2->5->NULL\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/92.html>\n\n\n\n```\n92\tReverse Linked List II\n\nReverse a linked list from position m to n. Do it in-place and in one-pass.\n\nFor example:\nGiven 1->2->3->4->5->NULL, m = 2 and n = 4,\n\nreturn 1->4->3->2->5->NULL.\n\nNote:\nGiven m, n satisfy the following condition:\n1 ≤ m ≤ n ≤ length of list.\n\n@tag-linkedlist\n\n```\n\nAlgorithm\n=========\n\n\nTake the example in the title, the three points that are transformed are `2, 3, and 4`. We need to find the first node before the transformation node, as long as the pre is moved backward by `m-1` steps.\n\n\nWhy do you want to subtract 1, because the problem is counting from 1, here only one step is taken, which is node 1, and use pre to point to it. What if the node 1 starts to change? This is why we use the dummy node. Pre can also point to the dummy node. Then the exchange is about to begin. Since only two nodes can be exchanged at a time, we follow the exchange sequence as follows:\n\n\n\n```\n1 -> 2 -> 3 -> 4 -> 5 -> NULL\n\n1 -> 3 -> 2 -> 4 -> 5 -> NULL\n\n1 -> 4 -> 3 -> 2 -> 5 -> NULL\n\n```\n\nThis problem is a follow-up problem for [problem 206](https://leetcode.ca/2016-06-23-206-Reverse-Linked-List/). In this problem, only the nodes from position *m* to *n* should be reversed, and the reverse operation should be done in one-pass. The iterative solution for problem 206 can be adapted here, with some modification.\n\n\nObviously, if the list is null, or there is only one element in the list, or position `m` is the same as position `n`, then no reverse needs to be done and just return the original list.\n\n\nSince the head may also be reversed, create a `dummyHead` whose next pointer points to `head`. Find the reverse start node, the reverse end node, the last node before reverse and the first node after reverse, and then do the reverse operation.\n\n\nFor example, for linked list `1->2->3->4->5->NULL`, *m* = 2, *n* = 4, the reverse start node is 2, the reverse end node is 4, the last node before reverse is 1, and the first node after reverse is 5.\n\n\nLike the iterative solution for [problem 206](https://leetcode.ca/2016-06-23-206-Reverse-Linked-List/), use two pointers `prev` and `curr` to do the iteration. After the loop, set the last node before reverse to point to the reverse end node (which is the start of the reverse part after reverse), and set the reverse start node (which is the end of the reverse part after reverse) to point to the first node after reverse.\n\n\nFinally, return `dummyHead.next`.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.Stack;\n\npublic class Reverse\\_Linked\\_List\\_II {\n\n\t/\\*\\*\n \\* Definition for singly-linked list.\n \\* public class ListNode {\n \\* int val;\n \\* ListNode next;\n \\* ListNode(int x) { val = x; }\n \\* }\n \\*/\n\n\tpublic class Solution\\_optimize {\n\t    public ListNode reverseBetween(ListNode head, int m, int n) {\n\n\t        ListNode dummy = new ListNode(0);\n\t        ListNode prev = dummy;\n\n\t        // I missed this one\n\t        prev.next = head;\n\n\t        ListNode p = head;\n\n\t        for (int i = 1; i < m; i++) {\n\t            prev = p;\n\t            p = p.next;\n\t        }\n\n\t        // @note:@memorize: now p is pointing to m-th node\n\t        ListNode originalFirst = p;\n\t        for (int i = m; i < n; i++) {\n\t            ListNode currentHead = prev.next;\n\t            ListNode futureHead = originalFirst.next;\n\n\t            // swap\n\t            // prev.next = currentHead.next;\n\t            prev.next = futureHead;\n\t            // currentHead.next = futureHead.next;\n\t            originalFirst.next = futureHead.next;\n\t            futureHead.next = currentHead;\n\t        }\n\n\t        return dummy.next;\n\t    }\n\t}\n\n\n\tpublic class Solution {\n\t    public ListNode reverseBetween(ListNode head, int m, int n) {\n\n\t    \tif (m > n) {\n\t        \treturn reverseBetween(head, n, m);\n\t        }\n\n\t    \tint diff = n - m;\n\t    \tif (diff == 0) {\n\t    \t\treturn head;\n\t    \t}\n\n\t    \tListNode p1 = head;\n\n\t    \t// set diff for both pointers\n\t    \t// @note: corner case: n-m > list-length\n\t    \twhile (diff > 0 && p1 != null) {\n\t    \t\tp1 = p1.next;\n\t    \t\tdiff--;\n\t    \t}\n\n\t    \tListNode dummy = new ListNode(0);\n\t    \tdummy.next = head;\n\n\t    \tListNode prev = dummy;\n\t    \tListNode p2 = head;\n\n\t    \tint mm = m;\n\t    \twhile (mm - 1> 0) {\n\t    \t\tprev = prev.next;\n\t    \t\tp1 = p1.next;\n\t    \t\tp2 = p2.next;\n\n\t    \t\tmm--;\n\t    \t}\n\n\t    \tListNode nextRecord = p1.next;\n\t    \tdiff = n - m;\n\n\t    \t// start reverse from p1 to p2\n\t    \t// 1->2->3->4->5\n\t    \tStack<ListNode> sk = new Stack<>();\n\t    \twhile (p2 != p1.next) { // @note: here, when p1==p2 should enter loop\n\t    \t\tsk.push(p2);\n\t    \t\tp2 = p2.next;\n\t    \t}\n\n\t    \twhile (!sk.isEmpty()) {\n\t    \t\tprev.next = sk.pop();\n\t    \t\tprev = prev.next;\n\t    \t}\n\n\t    \tprev.next = nextRecord;\n\n\t    \treturn dummy.next;\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 93,
    "title": "Restore IP Addresses",
    "problem": "\nGiven a string containing only digits, restore it by returning all possible valid IP address\n combinations.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** \"25525511135\"\n**Output:** [\"255.255.11.135\", \"255.255.111.35\"]\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/93.html>\n\n\n\n```\n93\tRestore IP Addresses\n\nGiven a string containing only digits, restore it by returning all possible valid IP address combinations.\n\nFor example:\nGiven \"25525511135\",\n\nreturn [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter)\n\n\n```\n\nAlgorithm\n=========\n\n\nFor the segmentation problem of character strings, add three dots to the input character string and divide the character string into four segments. Each segment must be legal. Seek all possible situations.\n\n\nBased on so many questions so far, two experiences have been drawn.\n\n\n* One is that as long as the subsequence or registration problem of a string is encountered, the `dynamic programming` DP is first considered;\n* the other is that as long as all possible situations need to be requested, `recursion` is first considered.\n\n\nThis question is not a question of seeking a subsequence or registration of a string, but more in line with the second case, so we have to use recursion to solve it.\n\n\nWe use k to represent the number of segments that still need to be divided. If k = 0, it means that three points have been added and four segments have been formed. If the string is just empty at this time, the current divided result will be saved. If k != 0, then for each segment, we use one, two, and three digits to try and judge whether it is legal or not. If it is legal, call recursion to continue dividing the remaining strings, and finally sum All legal combinations\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Restore\\_IP\\_Addresses {\n\n\tpublic static void main(String[] args) {\n\n\t\t// @note:@memorize: test substring boundary\n\t\tString a = \"abc\";\n\t\t// a = a.substring(0, 4); // String index out of range: 4\n\t\ta = a.substring(0, 3); // ok\n\t\tSystem.out.println(a);\n\n\t\tRestore\\_IP\\_Addresses out = new Restore\\_IP\\_Addresses();\n\t\tSolution s = out.new Solution();\n\n\t\tfor (String each: (s.restoreIpAddresses(\"25525511135\"))) {\n\t\t\tSystem.out.println(each);\n\t\t}\n\t}\n\n\tList<String> list = new ArrayList<>();\n\n\tpublic class Solution {\n\t    public List<String> restoreIpAddresses(String s) {\n\n\t    \tif (s.length() < 4 || s.length() > 12 || !s.matches(\"\\\\d+\")) {\n\t        \treturn list;\n\t        }\n\n\t    \trestore(s, \"\", 0);\n\n\t    \treturn list;\n\t    }\n\n\t    // seg: segment, in total 4\n\t    private void restore(String s, String result, int seg) {\n\t    \tif (seg == 4) {\n\t    \t\tif (s.length() == 0) {\n\n\t    \t\t\t// remove last \".\"\n\t    \t\t\tresult = result.substring(0, result.length() - 1);\n\n\t    \t\t\tlist.add(result);\n\t    \t\t}\n\n\t    \t\treturn;\n\t    \t}\n\n\t    \t// for (int i = 0; i < 3; i++) { // @note: out of boundary\n\t    \tfor (int i = 0; i < 3 && i < s.length(); i++) {\n\t    \t\tString thisSeg = s.substring(0, i + 1);\n\n\t    \t\tif (isValid(thisSeg)) {\n\t    \t\t\trestore(s.substring(i + 1), result + thisSeg + \".\", seg + 1);\n\t    \t\t}\n\t    \t}\n\t    }\n\n\t    private boolean isValid(String s) {\n\n\t    \t// can NOT be: 10.01.1.1\n\t    \tif (s.length() > 1 && s.startsWith(\"0\")) {\n\t    \t\treturn false;\n\t    \t}\n\n\t    \tint n = Integer.valueOf(s);\n\t    \tif (n > 255) {\n\t    \t\treturn false;\n\t    \t}\n\n\t    \treturn true;\n\t    }\n\t}\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 94,
    "title": "Binary Tree Inorder Traversal\n",
    "problem": "\nGiven a binary tree, return the *inorder* traversal of its nodes' values.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n**Output:** [1,3,2]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/94.html>\n\n\n\n```\n94. Binary Tree Inorder Traversal\n\nGiven a binary tree, return the inorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n   1\n    \\\n     2\n    /\n   3\nreturn [1,3,2].\n\nNote: Recursive solution is trivial, could you do it iteratively?\n\n@tag-tree\n\n```\n\nAlgorithm\n=========\n\n\n### Using stack\n\n\nThe iterative solution using the stack is also one of the solutions that meet the requirements of this question. It needs to be done with a `stack`.\n\n\nThe idea is to start from the root node, first push the root node into the stack, and then push all its left child nodes into the stack, then take out the top node of the stack, save the node value, and then move the current pointer to its right child node. If there is a right child node, all the left child nodes can be pushed onto the stack in the next cycle. This ensures that the access sequence is `left-root-right`.\n\n\n### No stack\n\n\nNeither recursion nor stack can be used, so how to ensure that the access sequence is the left-root-right of the in-order traversal. It turns out that a binary tree of clues needs to be constructed, and all the empty right child nodes need to be pointed to the next node traversed by the in-order, so that after the in-order traverses the left child node, it can smoothly return to its root node and continue the traversal.\n\n\nThe specific algorithm is as follows:\n\n\n1 . Initialize the pointer cur to point to root\n\n\n2 . When cur is not empty\n\n\n　\\* if cur has no left child node\n\n\n\n```\n　* a) Print out the value of cur\n\n　* b) Point the cur pointer to its right child node\n\n```\n\n* on the contrary, has left child node. Point the pre pointer to the rightmost child node in the left subtree of cur\n\n\n　　　 \\* If pre does not have a right child node\n\n\n\n```\n　　　 * a) Point its right child node back to cur\n\n　　　 * b) cur points to its left child node\n\n  * on the contrary\n\n```\n\n　　　　　 \\* a) Empty the right child node of pre\n\n\n　　　　　 \\* b) Print the value of cur\n\n\n　　　　　 \\* c) Point the cur pointer to its right child node\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Binary\\_Tree\\_Inorder\\_Traversal {\n\n\t/\\*\\*\n \\* Definition for a binary tree node.\n \\* public class TreeNode {\n \\* int val;\n \\* TreeNode left;\n \\* TreeNode right;\n \\* TreeNode(int x) { val = x; }\n \\* }\n \\*/\n\n    class Solution\\_noStack {\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            List<Integer> result = new ArrayList<>();\n            TreeNode current = root;\n            TreeNode prev;\n\n            while (current != null) {\n                if (current.left == null) {\n                    result.add(current.val);\n\n                    // only handle right child\n                    current = current.right; // move to next right node\n                } else { // has a left subtree\n                    prev = current.left;\n                    while (prev.right != null) { // find rightmost\n                        prev = prev.right;\n                    }\n                    prev.right = current; // put cur after the pre node\n                    TreeNode temp = current; // store cur node\n                    current = current.left; // move cur to the top of the new tree\n                    temp.left = null; // original cur left be null, avoid infinite loops\n                }\n            }\n\n            return result;\n        }\n    }\n\n    public class Solution\\_optmize {\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            List<Integer> list = new ArrayList<Integer>();\n            if (root == null) {\n                return list;\n            }\n\n            Stack<TreeNode> sk = new Stack<>();\n            TreeNode current = root;\n\n            while (!sk.isEmpty() || current != null) {\n\n                while (current != null) {\n                    sk.push(current);\n                    current = current.left;\n                } // @note: 一逼撸到最左边\n\n                // @note: 没有push left的操作，就不会无限循环，也不需要mark是否visited\n                TreeNode leftOrMiddle = sk.pop();\n                list.add(leftOrMiddle.val);\n\n                current = leftOrMiddle.right; // if right is null here, next time pop parent node\n            }\n\n            return list;\n        }\n    }\n\n\n    public class Solution {\n\n        List<Integer> list = new ArrayList<Integer>();\n\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            // mark if a node is visited already: true is visited. or, just use a Set\n            HashSet<TreeNode> hs = new HashSet<>();\n\n            Stack<TreeNode> sk = new Stack<>();\n            sk.push(root);\n\n            while (!sk.isEmpty()) {\n\n                TreeNode current = sk.pop();\n\n                if (current == null) {\n                    continue;\n                }\n\n                // @note: careful to check left visited, or else infinite looping\n                if (current.left != null && !hs.contains(current.left)) {\n                    sk.push(current);\n                    sk.push(current.left);\n\n                } else {\n\n                    if (current.right != null && !hs.contains(current.right)) {\n                        sk.push(current.right);\n                    }\n\n                    hs.add(current);\n                    list.add(current.val);\n                }\n            }\n\n            return list;\n        }\n    }\n\n    class Solution\\_recursion {\n\n        List<Integer> result = new ArrayList<>();\n\n        public List<Integer> inorderTraversal(TreeNode root) {\n            dfs(root);\n            return result;\n        }\n\n        public void dfs(TreeNode root) {\n            if (root == null) {\n                return;\n            }\n\n            dfs(root.left);\n            result.add(root.val);\n            dfs(root.right);\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 95,
    "title": "Unique Binary Search Trees II\n",
    "problem": "\nGiven an integer *n*, generate all structurally unique **BST's**\n (binary search trees) that store values 1 ... *n*.\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 3\n**Output:**\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n**Explanation:**\nThe above output corresponds to the 5 unique BST's shown below:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/95.html>\n\n\n\n```\n95\tUnique Binary Search Trees II\n\nGiven n, generate all structurally unique BST's (binary search trees) that store values 1...n.\n\nFor example,\nGiven n = 3, your program should return all 5 unique BST's shown below.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n@tag-tree\n@tag-divideconquer\n\n```\n\nAlgorithm\n=========\n\n\nThis kind of tree building problem is generally solved by `recursion`, and this problem is no exception, dividing the left and right subtrees, and recursive construction.\n\n\nThis actually uses the well-known divide and conquer method Divide and Conquer, and similar problems are the same as the previous `Different Ways to Add Parentheses` method, using recursion to solve, dividing the left and right sub-arrays, recursive construction.\n\n\nAt the beginning, consider the interval [1, n] as a whole, and then you need to treat each number as the root node, which divides the left and right sub-intervals, and then call the recursive function separately, you will get two Node array, the next thing to do is to take one node each time from these two arrays, as the left and right child nodes of the current root node, and then add the root node to the result array.\n\n\n### Pitfalls\n\n\n1. When start>end, if you directly return an empty list, size=0, then inserting the left and right subtrees will not work, i=0, i<left.size() loop will not enter\nSo I use if-else to determine whether the list is empty\nSo you must add a null to the list, let size=1\n2. To create a root node, it must be in two for loops, because each time is an independent tree.\nI created the root node first, and then went into the for loop, but the result was repeated, because each for was operated on the same tree, and the added tree was changed.\n\n\nI thought of the idea of creating left and right subtrees, but I didn’t figure out how to implement it and how to return the built subtrees to the upper level. This generate(start, end) is great.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Unique\\_Binary\\_Search\\_Trees\\_II {\n\n    public static void main(String[] args) {\n        Unique\\_Binary\\_Search\\_Trees\\_II out = new Unique\\_Binary\\_Search\\_Trees\\_II();\n        Solution s = out.new Solution();\n\n        for (TreeNode each: s.generateTrees(3)) {\n            System.out.println(each);\n        }\n    }\n\n\t/\\*\\*\n \\* Definition for a binary tree node.\n \\* public class TreeNode {\n \\* int val;\n \\* TreeNode left;\n \\* TreeNode right;\n \\* TreeNode(int x) { val = x; }\n \\* }\n \\*/\n\n    // optimized\n    public class Solution {\n\n        public List<TreeNode> generateTrees(int n) {\n            if (n == 0) {\n                return new ArrayList<TreeNode>();\n            }\n\n            return generate(1, n);\n        }\n\n        public ArrayList<TreeNode> generate(int start, int end) {\n\n            ArrayList<TreeNode> result = new ArrayList<TreeNode>();\n\n            if (start > end) {\n                result.add(null); // @note:@memorize:这里就是空的左树或者右树，是关键\n                return result;\n            }\n\n            for (int i = start; i <= end; i++) {\n\n                // i as root\n                ArrayList<TreeNode> left = generate(start, i - 1);\n                ArrayList<TreeNode> right = generate(i + 1, end);\n\n                // append left subtree and right subtree\n                // @note@note: should put inside for looping!, or, reference is modified onstantly!\n                for (TreeNode l : left) {\n                    for (TreeNode r : right) {\n\n                        // 每次都要复制一个\n                        TreeNode currentRoot = new TreeNode(i); // 当前的i作为head node\n\n                        currentRoot.left = l;\n                        currentRoot.right = r;\n\n                        result.add(currentRoot);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n    }\n\n    // DP version\n    public class Solution\\_iterative {\n\n        public List<TreeNode> generateTrees(int n) {\n\n            if (n == 0) {\n                return new ArrayList<TreeNode>();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            List<TreeNode>[] result = new ArrayList[n + 1]; // @note: just like: new int[10]\n\n            result[0] = new ArrayList<TreeNode>(); // empty tree\n            result[0].add(null);\n\n            for (int i = 1; i <= n; i++) {\n                result[i] = new ArrayList<TreeNode>(); // store all combinations when n is i\n\n                for (int leftIndex = 0; leftIndex < i; leftIndex++) {\n                    for (TreeNode leftSub : result[leftIndex]) { // get ONE left subtree\n                        for (TreeNode rightSub : result[i - leftIndex - 1]) { // get One right subtree\n                            TreeNode tmpRoot = new TreeNode(leftIndex + 1);\n                            tmpRoot.left = leftSub;\n\n                            // @note:@memorize: key is here. should generate right subtree, where the start number is \"1 + leftIndex\"\n                            tmpRoot.right = clone(rightSub, leftIndex + 1);\n                            result[i].add(tmpRoot);\n                        }\n                    }\n                }\n            }\n            return result[n];\n        }\n\n        // apply offset is still a local recursion\n        private TreeNode clone(TreeNode n, int offset) { // name is nice, self-explanatory\n\n            if (n == null) return null;\n            TreeNode node = new TreeNode(n.val + offset);\n            node.left = clone(n.left, offset);\n            node.right = clone(n.right, offset);\n            return node;\n        }\n\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 96,
    "title": "Unique Binary Search Trees",
    "problem": "\nGiven *n*, how many structurally unique **BST's** (binary search\n trees) that store values 1 ... *n*?\n\n\n**Example:**\n\n\n\n```\n\n**Input:** 3\n**Output:** 5\n**Explanation:**Given *n* = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/96.html>\n\n\n\n```\n96\tUnique Binary Search Trees\n\nGiven n, how many structurally unique BST's (binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n@tag-tree\n\n```\n\nAlgorithm\n=========\n\n\nLet’s first look at the situation when n = 1, only a single binary search tree can be formed. The situations where n is 1, 2, and 3 are as follows:\n\n\n\n```\n\t\t\t1                        n = 1\n\n\n\n                2        1                   n = 2\n               /          \\\n              1            2\n\n\n\n   1         3     3      2      1           n = 3\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n```\n\nWe assign 1 when n = 0, because the empty tree is also a binary search tree, then the situation when n = 1 can be regarded as the number of left subtrees multiplied by the number of right subtrees, and the left and right subtrees Trees are all empty trees, so 1 by 1 is still 1. Then when n = 2, since both 1 and 2 can be roots, you can calculate them separately and add them together. The case of n = 2 can be calculated by the following formula (where `dp[i]` represents the number of BST that can be composed of i numbers):\n\n\n\n```\ndp[2] = \n\n\tdp[0] * dp[1]　　　 \n\t(If 1 is the root, the left subtree must not exist, and the right subtree can have a number)\n\n\t+ \n\n\tdp[1] * dp[0]　　 \n\t(If 2 is the root, the left subtree can have a number, and the right subtree must not exist)\n\n```\n\nIn the same way, the calculation method for n = 3 can be written:\n\n\n\n```\ndp[3] = \n\tdp[0] * dp[2]　　　 \n\t(If 1 is the root, the left subtree must not exist, and the right subtree can have two numbers)\n\n\t+ \n\t\n\tdp[1] * dp[1]　　 \n\t(If 2 is the root, the left and right subtrees can each have a number)\n\n 　  + \n \n \tdp[2] * dp[0]　　 \n\t(If 3 is the root, the left subtree can have two numbers, and the right subtree must not exist)\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Unique\\_Binary\\_Search\\_Trees {\n\n    public static void main(String[] args) {\n        Unique\\_Binary\\_Search\\_Trees out = new Unique\\_Binary\\_Search\\_Trees();\n        Solution s = out.new Solution();\n\n        System.out.println(s.numTrees(3));\n    }\n\n    public class Solution {\n        public int numTrees(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n\n            // dp[i] represents the number of BST that can be composed of i numbers\n            int[] dp = new int[n + 1];\n            dp[0] = 1; // null is counted as one unique tree\n\n            for (int i = 1; i <= n; i++) { // 1...n\n\n                for (int j = 1; j <= i; j++) {\n                    // for each fixed n, calculate its sum\n                    dp[i] += dp[j - 1] \\* dp[i - j];\n                }\n            }\n\n            return dp[n];\n        }\n    }\n\n    public class Solution\\_recursion {\n        public int numTrees(int n) {\n            if (n < 0) {\n                return 0;\n            }\n\n            if (n == 0 || n == 1) {\n                return 1;\n            }\n\n            int sum = 0;\n\n            for (int i = 1; i <= n; i++) {\n\n                // 2 conditions: unique && BST. => inorder-visit will generate ordered sequence\n                // so, if decide root, then left and right can be calculated\n                // @note: root is \"i\", left has \"i-1\" nodes, right has \"n - (i - 1) - 1\"==\"n - i\" nodes\n                sum += numTrees(i - 1) \\* numTrees(n - i);\n            }\n\n            return sum;\n        }\n    }\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 97,
    "title": "Interleaving String",
    "problem": "\nGiven *s1*, *s2*, *s3*, find whether *s3* is formed by the\n interleaving of *s1* and *s2*.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"aabcc\", s2 = \"dbbca\", *s3* = \"aadbbcbcac\"\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"aabcc\", s2 = \"dbbca\", *s3* = \"aadbbbaccc\"\n**Output:** false\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/97.html>\n\n\n\n```\n97\tInterleaving String\n\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n\nFor example,\nGiven:\ns1 = \"aabcc\",\ns2 = \"dbbca\",\n\nWhen s3 = \"aadbbcbcac\", return true.\nWhen s3 = \"aadbbbaccc\", return false.\n\n@tag-dp\n\n```\n\nAlgorithm\n=========\n\n\nManually write out the two-dimensional array dp as follows:\n\n\n\n```\nØ d b b c a\nØ T F F F F F\na T F F F F F\na T T T T T F\nb F T T F T F\nc F F T T T T\nc F F F T F T\n\n```\n\nThe major premise of this question is that the sum of the lengths of the strings `s1` and `s2` must be equal to the length of `s3`. If they are not equal, false is definitely returned.\n\n\nThen when s1 and s2 are empty strings, s3 must be an empty string, and true is returned. So directly assign true to `dp[0][0]`,\n\n\nAnd then if one of s1 and s2 is an empty string, then the other must have the same length as s3, and then compare bitwise. If the same and the previous position is true, set True for dp, and assign False in other cases, so that the edge of the two-dimensional array dp is initialized.\n\n\nNext, we only need to find the state transition equation to update the entire array. We found that at any non-edge position `dp[i][j]`, its left or upper side may be True or False, and both sides can be updated. As long as there is a path through, then this point can be True. Then we have to look at it separately, if the left one is True, then we remove the character string `s2[j-1]` in the current corresponding s2 compared with the character in the corresponding position in s3 (when calculating the corresponding position, consider the matched The character in s1) is `s3[j-1 + i]`. If they are equal, then assign True, otherwise assign False. The situation where the above is True is similar, so the state transition equation can be calculated as:\n\n\n`dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i-1 + j]) || (dp[i][j-1] && s2 [j-1] == s3[j-1 + i]);`\n\n\n* Where `dp[i][j]` indicates whether the first `i` characters of s2 and the first `j` characters of s1 match the first `i+j` characters of s3\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Interleaving\\_String {\n\n    public class Solution {\n        public boolean isInterleave(String s1, String s2, String s3) {\n            if (s1.length() == 0 || s1 == null) {\n                return s2.equals(s3);\n            }\n\n            if (s2.length() == 0 || s2 == null) {\n                return s1.equals(s3);\n            }\n\n            // @note: missed this simple check\n            if (s1.length() + s2.length() != s3.length()) {\n                return false;\n            }\n\n            // 1-to-i of s1, and 1-to-j of s2, can for 1-to-(i+j) of s3\n            boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; // +1 for empty string\n\n            dp[0][0] = true;\n\n            // pre-process for empty string case\n            for (int i = 1; i < s1.length() + 1; i++) {\n                dp[i][0] = (s1.charAt(i - 1) == s3.charAt(i - 1))\n                    && dp[i - 1][0];\n            }\n            for (int i = 1; i < s2.length() + 1; i++) {\n                dp[0][i] = (s2.charAt(i - 1) == s3.charAt(i - 1))\n                    && dp[0][i - 1];\n            }\n\n            for (int i = 1; i < s1.length() + 1; i++) {\n                for (int j = 1; j < s2.length() + 1; j++) {\n\n                    boolean withS1 = s1.charAt(i - 1) == s3.charAt(i - 1 + j) && dp[i - 1][j];\n                    boolean withS2 = s2.charAt(j - 1) == s3.charAt(i - 1 + j) && dp[i][j - 1];\n\n                    dp[i][j] = withS1 || withS2;\n                }\n            }\n\n            return dp[s1.length()][s2.length()];\n        }\n    }\n\n\n    public class Solution\\_over\\_time {\n        public boolean isInterleave(String s1, String s2, String s3) {\n\n            if (s1.length() == 0 || s1 == null) {\n                return s2.equals(s3);\n            }\n\n            if (s2.length() == 0 || s2 == null) {\n                return s1.equals(s3);\n            }\n\n            boolean withS1 = false;\n            boolean withS2 = false;\n\n            if (s1.charAt(0) == s3.charAt(0)) {\n                withS1 = isInterleave(s1.substring(1), s2, s3.substring(1));\n            }\n            if (s2.charAt(0) == s3.charAt(0)) {\n                withS2 = isInterleave(s1, s2.substring(1), s3.substring(1));\n            }\n\n            return withS1 || withS2;\n        }\n    }\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 98,
    "title": "Validate Binary Search Tree",
    "problem": "\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\n\nAssume a BST is defined as follows:\n\n\n* The left subtree of a node contains only nodes with keys **less than** the\n node's key.\n* The right subtree of a node contains only nodes with keys **greater than**\n the node's key.\n* Both the left and right subtrees must also be binary search trees.\n\n\n \n\n\n**Example 1:**\n\n\n\n```\n\n    2\n   / \\\n  1   3\n\n**Input:** [2,1,3]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n\n**Input:** [5,1,4,null,null,3,6]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/98.html>\n\n\n\n```\n98\tValidate Binary Search Tree\n\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n    The left subtree of a node contains only nodes with keys less than the node's key.\n    The right subtree of a node contains only nodes with keys greater than the node's key.\n    Both the left and right subtrees must also be binary search trees.\n\n@tag-tree\n\n```\n\nAlgorithm\n=========\n\n\nMake use of the nature of BST, bring the maximum and minimum values of the system during initialization, and replace them with their own node values in the recursive process.\n\n\nThe use of long instead of int is to include the boundary conditions of int.\n\n\nFor below BFS solution, we can also define a new data structure `MyNode`\n\n\n\n```\n\nclass MyNode {\n\n    TreeNode node;\n    int upper;\n    int lower;\n}\n\n```\n\nThen initiate as\n\n\n\n```\nnew MyNode(node, Integer.Max, Integer.Min)\n\n```\n\nAnd enqueue as\n\n\n\n```\nqueue.offer(new MyNode(node.left, lower, currentNode.val))\nqueue.offer(new MyNode(node.right, currentNode.val, upper))\n\n```\n\n### Note: remember below in invalid, 7 should go right of 5\n\n\n\n```\n   5\n  / \\\n 1   8\n  \\   \\\n   7   10\n\n```\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\nimport java.util.LinkedList;\n\npublic class Validate\\_Binary\\_Search\\_Tree {\n\n\t/\\*\\*\n \\* Definition for a binary tree node.\n \\* public class TreeNode {\n \\* int val;\n \\* TreeNode left;\n \\* TreeNode right;\n \\* TreeNode(int x) { val = x; }\n \\* }\n \\*/\n\n    public class Solution { // dfs\n\n        public boolean isValidBST(TreeNode root) {\n            return isValidBST(root, Long.MIN\\_VALUE, Long.MAX\\_VALUE);\n        }\n\n        public boolean isValidBST(TreeNode root, long min, long max) { // int will be overflow by input [2147483647]\n            if (root == null) {\n                return true;\n            }\n            if (root.val >= max || root.val <= min) { // @note: must be <= and >=, eg. [1,1]\n                return false;\n            }\n\n            // below code, check with left/right children not necessary, since min/max updated already\n            return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n        }\n    }\n\n    class Solution\\_iteration {\n\n        LinkedList<TreeNode> queue = new LinkedList<>(); // store node, and its associated low/high in other two lists\n        LinkedList<Integer> uppers = new LinkedList<>();\n        LinkedList<Integer> lowers = new LinkedList<>();\n\n        public void update(TreeNode root, Integer lower, Integer upper) {\n            queue.add(root);\n            lowers.add(lower);\n            uppers.add(upper);\n        }\n\n        public boolean isValidBST(TreeNode root) {\n            Integer lower = null;\n            Integer upper = null;\n            int val;\n            update(root, lower, upper);\n\n            while (!queue.isEmpty()) {\n                root = queue.poll();\n                lower = lowers.poll();\n                upper = uppers.poll();\n\n                if (root == null) continue;\n                val = root.val;\n                if (lower != null && val <= lower) return false;\n                if (upper != null && val >= upper) return false;\n                update(root.right, val, upper);\n                update(root.left, lower, val);\n            }\n            return true;\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 99,
    "title": "Recover Binary Search Tree",
    "problem": "\nTwo elements of a binary search tree (BST) are swapped by mistake.\n\n\nRecover the tree without changing its structure.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** [1,3,null,null,2]\n\n   1\n  /\n 3\n  \\\n   2\n\n**Output:** [3,1,null,null,2]\n\n   3\n  /\n 1\n  \\\n   2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** [3,1,4,null,null,2]\n\n  3\n / \\\n1   4\n   /\n  2\n\n**Output:** [2,1,4,null,null,3]\n\n  2\n / \\\n1   4\n   /\n  3\n\n```\n\n**Follow up:**\n\n\n* A solution using O(*n*) space is pretty straight forward.\n* Could you devise a constant space solution?\n\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/99.html>\n\n\n\n```\n99\tRecover Binary Search Tree\n\nTwo elements of a binary search tree (BST) are swapped by mistake.\n\nRecover the tree without changing its structure.\n\nNote:\nA solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\n\n@tag-tree\n\n```\n\nAlgorithm\n=========\n\n\nThree pointers are needed, `first` and `second` respectively represent the first and second disordered nodes, and `pre` points to the previous node of the current node’s in-order traversal.\n\n\nThe traditional in-order traversal recursion is used here, but where the node value should be output, it is replaced by judging the size of pre and the current node value. If pre is larger, if first is empty, `first` point to the node pointed to by `pre`, or else, set `second` to the `current` node.\n\n\nIn this way, the in-order traverses the entire tree, and if both first and second exist, then their node values can be exchanged. The space complexity of this algorithm is still `O(n)`, where n is the height of the tree.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\n\npublic class Recover\\_Binary\\_Search\\_Tree {\n\n    public static void main(String[] args) {\n\n    }\n\n    /\\*\\*\n \\* Definition for a binary tree node.\n \\* public class TreeNode {\n \\* int val;\n \\* TreeNode left;\n \\* TreeNode right;\n \\* TreeNode(int x) { val = x; }\n \\* }\n \\*/\n\n    public class Solution {\n\n        TreeNode n1;\n        TreeNode n2;\n        TreeNode prev; // @note:@memorize: key is use prev!\n\n        public void recoverTree(TreeNode root) {\n            inOrderTraversal(root); // will record 2 swapped nodes\n            swap(); // swap 2 nodes\n        }\n\n        private void inOrderTraversal(TreeNode root) {\n\n            if (root == null) {\n                return;\n            }\n\n            inOrderTraversal(root.left);\n\n\n            // @note: 1,6,3,4,5,2 => NOT next to each other => n1=6-prev, but n2=2-root\n            // @note: 1,2,4,3,5,6 => when next to each other, n2 needs to be root\n            // bigger than next, then wrong\n\n            if (prev != null && prev.val >= root.val) {\n                if (n1 == null) {\n                    n1 = prev;\n                    n2 = root; // @note:@memorize: here is key, for case when in total two nodes\n                } else {\n                    // n2 = prev; @note:@memorize: n1 and n2, n1=prev but n2=root\n                    n2 = root;\n                }\n            }\n\n            prev = root;\n\n            inOrderTraversal(root.right);\n        }\n\n        // @note: concern about n1 or n2 is null? by question definition, if swapped, then at least 2 nodes\n        private void swap() {\n            int tmp = n1.val;\n            n1.val = n2.val;\n            n2.val = tmp;\n        }\n    }\n\n}\n\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  },
  {
    "id": 100,
    "title": "Same Tree",
    "problem": "\nGiven two binary trees, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical and the nodes\n have the same value.\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:**     1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:**     1         1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n**Output:** false\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:**     1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n**Output:** false\n\n```\n\n\n### \n\n",
    "explanation": "\nQuestion\n========\n\n\nFormatted question description: <https://leetcode.ca/all/100.html>\n\n\n\n```\n100\tSame Tree\n\nGiven two binary trees, write a function to check if they are equal or not.\n\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\n\n@tag-tree\n\n```\n\nAlgorithm\n=========\n\n\nDepth first search DFS to recurse.\n\n\nCode\n====\n\n\nJava\n\n\n* [Java](#)\n* [C++](#)\n* [Python](#)\n\n\n* ```\npublic class Same\\_Tree {\n\n    /\\*\\*\n \\* Definition for a binary tree node.\n \\* public class TreeNode {\n \\* int val;\n \\* TreeNode left;\n \\* TreeNode right;\n \\* TreeNode(int x) { val = x; }\n \\* }\n \\*/\n\n    public class Solution\\_iteration {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == null) {\n                return q == null;\n            }\n\n            if (q == null) {\n                return p == null;\n            }\n\n            Stack<TreeNode> sk1 = new Stack<TreeNode>();\n            Stack<TreeNode> sk2 = new Stack<TreeNode>();\n\n            sk1.push(p);\n            sk2.push(q);\n\n            while (!sk1.isEmpty() && !sk2.isEmpty()) {\n                TreeNode current1 = sk1.pop();\n                TreeNode current2 = sk2.pop();\n\n                if (current1 == null && current2 == null) {\n                    continue; // @note: missed both null check\n                } else if (current1 == null && current2 != null) {\n                    return false;\n                } else if (current1 != null && current2 == null) {\n                    return false;\n                } else if (current1.val != current2.val) {\n                    return false;\n                }\n\n                sk1.push(current1.left);\n                sk2.push(current2.left);\n\n                sk1.push(current1.right);\n                sk2.push(current2.right);\n\n            }\n\n            // final check\n            if (!sk1.isEmpty() || !sk2.isEmpty()) {\n                return false;\n            }\n\n            return true;\n\n        }\n    }\n\n\n    public class Solution\\_recursion {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n\n            if (p == null) {\n                return q == null;\n            }\n\n            if (q == null) {\n                return p == null;\n            }\n\n            if (p.val != q.val) {\n                return false;\n            }\n\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n\n}\n\n```\n* ```\nprintf(\"%s\\n\",\"Todo\".c\\_str());\n\n```\n* ```\nprint(\"Todo!\")\n\n```\n\n\n"
  }
]